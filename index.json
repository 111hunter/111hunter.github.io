[{"categories":["coding"],"content":"我们知道，如今流行的前端框架都是 SPA(单页应用)，在投入生产时会出现中首屏加载慢，不利于 SEO 等问题。于是，现代前端同构框架应运而生。Next.js 是 React 的同构框架，它的页面由 React 组件构成。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:0:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"路由系统 Next.js 的路由系统基于文件路径自动映射，一般约定在根目录的 pages 文件夹内： pages/index.js –\u003e / pages/about.js –\u003e /about pages/blog/[slug].js –\u003e /blog/:slug( slug 是动态生成的) pages/post/[...all].js–\u003e /post/*(匹配 /post,/post/a,/post/a/b 等) Next.js 创建的是多页应用，pages 内的每个文件都是单个页面。Next.js 中用形如 [params] 文件(文件夹)表示动态路由页面。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:1:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"路由跳转 Next.js 中路由跳转方式有两种，使用的 api 分别是 next/link 和 next/router。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"next/link 从 next/link 导入的 \u003cLink\u003e 是 React 组件，可接收以下属性: href 是导航到的路径，是页面跳转的必需属性，href 可以是字符串或者对象 \u003cLink href=\"/about?name=jackylin\"\u003e\r//这里 href 有两层 {}, github page 无法识别语法，只能写为一层了\r\u003cLink href={ pathname: \"/about\", query: { name: \"jackylin\" },}\u003e\r as 是浏览器 url 栏显示的路径，当 href 中包含动态页面 ([param]) 时使用 const pids = ['id1', 'id2', 'id3']\r{\rpids.map((pid, index) =\u003e (\r\u003cLink href='/post/[pid]' as={`/post/${pid}`} key='index'\u003e\r\u003ca\u003ePost {pid}\u003c/a\u003e\r\u003c/Link\u003e\r))}\r passHref 将 \u003cLink\u003e 的 href 传递给子项，当子项是包装 \u003ca\u003e 的组件时，此属性必需 prefetch 预加载，将页面提前加载到本地缓存 官方文档还有一些其他 属性 和用法示例，需要注意的是 \u003cLink\u003e 只能有一个子项。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"next/router 相较于 next/link，next/router 能自定义配置复杂的路由跳转。next/router 提供如下 api： useRouter 是 React hook，只能用于函数组件 withRouter 是高阶组件，可用于类组件和函数组件 他们的实例对象 router 具有以下的属性，方法，事件等。 属性：pathname 是文件名，query 是查询参数，asPath 是浏览器中显示的路径。 方法：router.push(url, as, options) 是路由跳转方法，跳转的页面路径(url)必需。url 可以是字符串形式，也可以是对象形式。在需路由跳转的元素上绑定点击事件。 export default function ReadPost({ post }) {\rconst router = useRouter()\rreturn (\r\u003cspan\ronClick={() =\u003e {\rrouter.push({\rpathname: '/post/[pid]',\rquery: { pid: post.id },\r})\r}}\r\u003e\r查看文章\r\u003c/span\u003e\r)\r}\r 对比前面讲的 \u003cLink\u003e 组件，能看出 \u003cLink\u003e 组件其实是封装了 router，点击事件等。 事件：Next.js 在路由跳转的生命周期内置了一些的钩子事件，若我们有监听路由变化的需求，可订阅这些钩子事件来实现需求。具体用法请参阅 官方文档。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"路由传参 Next.js 支持查询字符串格式的参数传递，参数以字符串或者对象的格式传递: \u003cLink\u003e 的 href 属性或者 router.push 中的 url。参数的接收可以用 useRouter 或 withRouter: // router 直接读取参数\rconst Post = () =\u003e {\rconst router = useRouter();\rreturn (\r\u003cdiv\u003e文章编号：{router.query.pid}\u003c/div\u003e\r)\r}\rexport default Post\r //使用 withRouter 接收参数时，router 作为组件参数\rconst Post = ({ router }) =\u003e {\rreturn (\r\u003cdiv\u003e文章编号：{router.query.pid}\u003c/div\u003e\r)\r}\rexport default withRouter(Post)\r ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"获取数据 Next.js 中获取数据的方法有 getServerSideProps，getStaticProps 和 getStaticPaths。还有一个 getInitialProps，官方文档已不推荐使用。这些方法都是服务端的异步方法，只能在 pages 文件夹内使用。 Next.js 有两种预渲染形式： 服务端渲染(SSR)：html 在每次访问路由时都会重新生成。对应的数据获取方法：getServerSideProps。由于“服务端渲染”比“静态生成”慢，因此常用于数据频繁更新的页面。 静态生成(SSG)：html 是在构建时生成的，并且会在每次请求时重用。对应的数据获取方法： getStaticProps 和 getStaticPaths。这对于可以在用户请求之前就预渲染的页面非常有用，可以将其与客户端渲染结合使用以引入其他数据。 Next.js 引入了自动静态优化的功能，就是说如果页面中没有使用 SSR 方法，Next.js 在 build 阶段就会生成 html，访问页面路由直接返回生成的 html，以此来提升性能。 选择 SSR 还是 SSG？ 如果页面内容真动态(例如来源数据库且经常变化)，使用 SSR。 如果是静态页面或者伪动态(来源数据库但是不变化)，使用 SSG。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"getServerSideProps 在数据频繁更新的页面使用，每次访问路由时都会调用。getServerSideProps 方法是升级了 9.3 之前的 getInitialProps 方法。 const Blog = ({ data }) =\u003e {\rreturn \u003cdiv\u003etitle: {data.title}\u003c/div\u003e\r}\r// 在每次页面请求时才会运行，在构建时不运行。\rexport async function getServerSideProps() {\rconst res = await fetch('https://jsonplaceholder.typicode.com/todos/1')\rconst data = await res.json()\rreturn { props: {data} }\r}\rexport default Blog\r ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"getStaticProps 页面内容取决于外部数据时使用。 // posts 依赖外部数据\rconst Blog = ({ posts }) =\u003e {\rreturn \u003cdiv\u003etitle: {posts.title}\u003c/div\u003e\r}\r// 此函数只在构建时被调用一次，后面不会再次调用\rexport async function getStaticProps() {\r// 调用外部 API 获取内容\r const res = await fetch('https://jsonplaceholder.typicode.com/todos/1')\rconst posts = await res.json()\r// 在构建时将接收到 `posts` 参数\r return {\rprops: {\rposts,\r},\r}\r}\rexport default Blog\r ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"getStaticPaths 页面路径取决于外部数据时使用，结合 getStaticProps 使用。 const Post = ({ post }) =\u003e {\rreturn (\r\u003cdiv\u003e文章id: {post.id}, 文章标题: {post.title}\u003c/div\u003e\r)\r}\r// 此函数只在构建时被调用一次，后面不会再次调用\rexport async function getStaticPaths() {\r// 取全部文章数据\r const res = await fetch('https://jsonplaceholder.typicode.com/todos')\rconst posts = await res.json()\rconst paths = posts.map(post =\u003e `/posts/${post.id}`)\r// fallback为 false，表示不在 getStaticPaths 的路径是 404 页面。\r return { paths, fallback: false }\r}\r// params 来自 paths: [{ params: { ... } }]\rexport async function getStaticProps({ params }) {\r// 取具体文章数据\r const res = await fetch(`https://jsonplaceholder.typicode.com/todos/${params.id}`)\rconst post = await res.json()\rreturn { props: { post } }\r}\rexport default Post\r api 的更多细节用法请阅读 官方文档。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"其他功能 ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"自定义配置 Next.js 在 pages 文件夹内的默认配置文件有 _app.js,_document.js,404.js 等。 以 _app.js 为例，它的功能是初始化当前路由的页面组件，接口如下： /**\r* Component 是当前路由的页面组件，每次路由切换时，Component 都会更新\r* pageProps 是初始属性，该初始属性由某个数据获取方法预先加载到你的页面中，否则它将是一个空对象\r*/\rfunction MyApp({ Component, pageProps }) {\rreturn \u003cComponent {...pageProps} /\u003e\r}\rexport default MyApp\r 比如我们要使用 recoil 进行状态管理，所有页面组件都应该为 \u003cRecoilRoot\u003e 的子组件。 import { RecoilRoot } from 'recoil'\rexport default function MyApp({ Component, pageProps }) {\rreturn (\r\u003cRecoilRoot\u003e\r\u003cComponent {...pageProps} /\u003e\r\u003c/RecoilRoot\u003e\r)\r}\r 其他配置文件的作用请阅读 官方文档。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"自定义构建 Next.js 根目录 next.config.js 可配置项目构建。例如扩展默认 webpack 配置，接口如下： module.exports = {\rwebpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) =\u003e {\r// Note: we provide webpack above so you should not `require` it\r config.plugins.push(new webpack.IgnorePlugin(/\\/__tests__\\//))\r// Important: return the modified config\r return config\r},\r}\r 例如在 Next.js 默认的 babel 配置中添加一个 loader： // https://github.com/vercel/next.js/tree/canary/packages/next-mdx\rmodule.exports = {\rwebpack: (config, options) =\u003e {\rconfig.module.rules.push({\rtest: /\\.mdx/,\ruse: [\roptions.defaultLoaders.babel,\r{\rloader: '@mdx-js/loader',\roptions: pluginOptions.options,\r},\r],\r})\rreturn config\r},\r}\r ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":"api 路由 Next.js 提供简单的后端 api 能力，在 pages/api 内的文件都将映射为 /api/* 的后端接口。它们不会和页面一起打包。 // pages/api/post.js\r\rimport {getPosts} from 'lib/posts'\rconst Posts = async (req, res) =\u003e {\rconst posts = await getPosts()\rres.statusCode = 200\rres.setHeader('Content-Type', 'application/json')\rres.end(JSON.stringify(posts))\r}\rexport default Posts\r 目前 Next.js 没有提供数据库和测试相关的功能，需自行配置或与其他框架配合使用。 参考资料 Next.js 官方文档 Next.js 简明教程 手把手带你入门 NextJs ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["coding"],"content":" 在计算机科学中，函数式编程是一种编程范式，其中通过应用和组合函数来构造程序。它是一种声明式编程范式，其中函数定义是每个返回一个值的表达式树，而不是一系列更改程序状态的命令性语句。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:0:0","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"声明式与命令式 假设我们有个需求：把下面字符串变成每个单词首字母大写。 var string = 'functional programming is great';\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:0","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"命令式 如果你没有听说过函数式编程，用传统的编程思路，很自然的写出如下 命令式编程 代码： var string = 'functional programming is great';\rvar arrays = string.split(' ');\rvar newArray = [];\rfor (var i = 0; i \u003c arrays.length; i++){\rvar str = arrays[i].slice(0, 1).toUpperCase() + arrays[i].slice(1);\rnewArray.push(str);\r}\rvar newString = newArray.join(' ');\r 这样当然能完成任务，结果是产生了一堆临时变量。光是变量名就不好想，同时过程中掺杂了大量逻辑，一个函数需要从头读到尾才知道它具体做了什么，并且一旦出问题很难定位。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:1","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"声明式 声明式编程 被看做是形式逻辑的理论，把计算看做推导。常见的声明式编程有数据库查询(SQL语句)，正则表达式，函数式编程等。函数式编程倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 var string = 'functional programming is great';\rvar newString = string\r.split(' ')\r.map(str =\u003e str.slice(0, 1).toUpperCase() + str.slice(1))\r.join(' ');\r 函数式编程的核心思想：通过函数转换数据，组合多个函数来求结果。 对比两种编程思想：命令式编程考虑我该如何做，而声明式编程考虑我要做什么。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:2","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"核心概念-纯函数 函数式编程中的“函数”指满足以下特性的函数，也被称为 纯函数： 输出仅取决于输入(无状态，每次的执行结果都是可预测和易测试的) 不产生副作用(只计算输出值，不修改输入值，不做其他任何操作) 因此纯函数更像数学中的函数，只是描述输入与输出之间映射关系的表达式。 一个典型的纯函数设计是 redux 中的 reducer。好的我懂了，但是为什么要强调纯函数呢？因为纯函数的特性决定了它的众多优点： ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:0","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"易读易推理 纯函数容易阅读和推理，因为所有依赖关系都由参数提供。这意味着我们只需阅读函数的声明即可快速了解函数的作用及其依赖关系，而不用担心函数内有其他行为(副作用)。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:1","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"移植性 对于常见的普通函数，同一函数不能直接在移植到别的上下文中使用，通常会为了实现同一类功能而编写不同的函数。 // 普通函数\rvar signUp = function(attrs) {\rvar user = saveUser(attrs);\rwelcomeUser(user);\r};\r// 依赖 Db\rvar saveUser = function(attrs) {\rvar user = Db.save(attrs);\r...\r};\r// 依赖 Email\rvar welcomeUser = function(user) {\rEmail(user, ...);\r...\r};\r 编写纯函数的好处是它需要的东西都在输入参数中已经声明，所以它方便移植到别的地方，因为它的依赖关系是很清晰的。 // 纯函数\rvar signUp = function(Db, Email, attrs) {\rreturn function() {\rvar user = saveUser(Db, attrs);\rwelcomeUser(Email, user);\r};\r};\rvar saveUser = function(Db, attrs) {\r...\r};\rvar welcomeUser = function(Email, user) {\r...\r};\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:2","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"引用透明性 因为纯函数内部没有全局引用，所以在任何使用纯函数的地方中把纯函数替换成它的执行结果，都不会对程序的整体运行产生影响，不会产生隐性问题。 const greet = (name) =\u003e {\rreturn `hello, ${name}`;\r};\rconsole.log(greet('beijing'));\r// 可做如下等价替换\rconsole.log('hello, beijing');\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:3","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"可缓存 纯函数对相同输入总有相同输出，可以根据输入来做缓存，相同的输入可以不做重新计算。 // 下面的代码我们可以发现相同的输入，再第二次调用的时候都是直接取的缓存\rlet squareNumber = memoize((x) =\u003e { return x*x; });\rsquareNumber(4);\r//=\u003e 16\rsquareNumber(4); // 从缓存中读取输入值为 4 的结果\r//=\u003e 16\rsquareNumber(5);\r//=\u003e 25\rsquareNumber(5); // 从缓存中读取输入值为 5 的结果\r//=\u003e 25\r 这是怎么实现的呢? 请看下面的代码: const memoize = (f) =\u003e {\r// 由于使用了闭包，所以函数执行完后 cache 不会立刻被回收\r const cache = {};\rreturn () =\u003e {\rvar arg_str = JSON.stringify(arguments);\r// 利用 cache 做一个简单的缓存，当这个参数之前使用过时，我们立即返回结果就行\r cache[arg_str] = cache[arg_str] || f.apply(f, arguments);\rreturn cache[arg_str];\r};\r};\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:4","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"并行处理 纯函数不会访问共享的内存，因此不用担心线程的执行顺序，对任何纯表达式的求值都是线程安全的。 var x = f(a);\rvar y = g(b);\rvar z = h(c);\r// 线程安全\rvar result = x + y + z;\r 前三个表达式之间没有数据依赖关系，它们的执行顺序可以颠倒，或者并行执行也互不干扰。只要它们能在分配给 result 之前执行。 说了这么多优点，其实纯函数的优秀的原因是因为它不使用全局引用： 大神语录 Shared mutable state is the root of all evil(共享的可变状态是万恶之源) – Pete Hunt ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:5","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"应用和组合函数 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:0","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"高阶函数 在数学和计算机科学中，高阶函数 是至少执行以下一项的函数： 将一个或多个函数作为参数(即过程参数) 返回一个函数作为其结果 ES6 中常用的高阶函数包括：map，filter，reduce，find，some，every 等。 // 数组求和\rconst arr = [5, 7, 1, 8, 4];\r// 不使用高阶函数\rlet sum = 0;\rfor (let i = 0; i \u003c arr.length; i++) {\rsum = sum + arr[i];\r}\rconsole.log(sum); //25\r\r// 使用高阶函数\rconst sum = arr.reduce((accumulator, currentValue) =\u003e accumulator + currentValue,0);\rconsole.log(sum); //25\r\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:1","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"闭包 通常情况下我们说的 闭包 指的是函数内部的函数。闭包的形成条件： 存在内、外两层函数 内层函数对外层函数的局部变量进行了引用 闭包的用途：定义一些作用域局限的持久化变量，这些变量可用来做缓存或者计算的中间量等。 闭包的弊端：持久化变量不会被正常释放，持续占用内存造成内存浪费，所以需要额外的手动清理机制。 // 匿名函数创造了一个闭包，实现简单的缓存工具\rconst cache = (function() {\rconst store = {};\rreturn {\rget(key) {\rreturn store[key];\r},\rset(key, val) {\rstore[key] = val;\r}\r}\r}());\rconsole.log(cache) //{get: ƒ, set: ƒ}\rcache.set('a', 1);\rcache.get('a'); // 1\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:2","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"柯里化 柯里化 是一种将多参函数拆解为多个单参函数序列的技术。 function curryIt(fn) {\r// 参数fn函数的参数个数\r var n = fn.length;\rvar args = [];\rreturn function(arg) {\rargs.push(arg);\rif (args.length \u003c n) {\rreturn arguments.callee; // 返回这个函数的引用\r } else {\rreturn fn.apply(this, args);\r}\r};\r}\rfunction add(a, b, c) {\rreturn [a, b, c];\r}\r// c 是内部匿名函数\rvar c = curryIt(add); // 可以分步传参\rvar c1 = c(1); // 将 1 加入 args 中，返回 c 的引用\rvar c2 = c1(2); var c3 = c2(3); // [1, 2, 3]\r\r// 也可以直接调用\rvar c3 = c(1)(2)(3); // [1, 2, 3]\r 可以看出，柯里化是一种函数的“预加载”技术，可以通过闭包实现对参数的缓存。 类似的概念有将多参函数拆解为任意参数个数的部分函数应用： // Currying f(a)(b)(c)\rvar f = a =\u003e b =\u003e c =\u003e a + b + c;\r// Partial application f(a)(b,c) var f = a =\u003e (b, c) =\u003e a + b + c;\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:3","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"函数组合 柯里化是函数的拆解，函数组合就是多个函数组合为一个函数。compose 简单实现： var compose = (f, g) =\u003e x =\u003e f(g(x));\rvar g = x =\u003e x + 1;\rvar f = x =\u003e x * 5;\rvar fg = compose(f, g); fg(2); // 15\r 我们要合成的函数可能不止两个，更通用的 compose 实现： function compose(...args) {\rreturn function(x) {\rvar composeFun = args.reduceRight(function(first, second) {\r//从右边开始迭代，这里实际是把右边放入左边\r return second(first); }, x);\rreturn composeFun;\r}\r};\r// 简化为箭头函数\rvar compose = (...args)=\u003e(x)=\u003e args.reduceRight((f,s)=\u003es(f),x);\r 现在我们可以自由组合函数： function addHello(str){\rreturn 'hello ' + str;\r}\rfunction toUpperCase(str) {\rreturn str.toUpperCase();\r}\rfunction reverse(str){\rreturn str.split('').reverse().join('');\r}\rvar composeFn=compose(reverse,toUpperCase,addHello);\rcomposeFn('ttsy'); // YSTT OLLEH\r 最后，软件工程没有银弹。每种编程范式各有利弊，我们要根据实际需求选择合适的编程范式。 参考资料 维基百科 JavaScript函数式编程入门经典 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:4","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["coding"],"content":"如果你想了解 Javascript 的编译原理，那么你就得了解 AST(Abstract Syntax Tree)，目前前端常用的一些插件或者工具，比如 JS 转译、代码压缩、CSS 预处理器、ESLint、Prettier 等功能的实现，都是建立在 AST 的基础之上的。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:0:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"JS 编译流程 首先是 JS 引擎读取 JS 文件中的字符流，然后通过 词法分析 生成 tokens，之后再通过 语法分析 生成 AST，最终 JS 引擎将 AST 编译成字节码或机器码，然后再运行。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"词法分析 词法分析，也称为扫描(scanner)，简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的 Token。Token 是 JS 代码在语法含义上不可分割的最小单元。除此之外，还会过滤掉源程序中的注释和空白字符(换行符、空格、制表符等)。 最终，整个代码被分割进一个 tokens 的数组中。如下代码： const href = 'https://github.com/'\r 经过词法分析生成类似这样的 tokens： [\r{\r\"type\": \"Keyword\",\r\"value\": \"const\"\r},\r{\r\"type\": \"Identifier\",\r\"value\": \"href\"\r},\r{\r\"type\": \"Punctuator\",\r\"value\": \"=\"\r},\r{\r\"type\": \"String\",\r\"value\": \"'https://github.com/'\"\r}\r]\r ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:1","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"语法分析 语法分析会将词法分析出来的 tokens 转化成有语法含义的 AST 结构。同时，验证语法，如果语法有错，抛出语法错误。 {\r\"type\": \"Program\",\r\"body\": [\r{\r\"type\": \"VariableDeclaration\",\r\"declarations\": [\r{\r\"type\": \"VariableDeclarator\",\r\"id\": {\r\"type\": \"Identifier\",\r\"name\": \"href\"\r},\r\"init\": {\r\"type\": \"Literal\",\r\"value\": \"https://github.com/\",\r\"raw\": \"'https://github.com/'\"\r}\r}\r],\r\"kind\": \"const\"\r}\r],\r\"sourceType\": \"script\"\r}\r 这里 可以看到代码的转换。这里 有 tokens 和 AST 的简单 JS 实现。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:2","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"AST 节点规范 业界已经有很多成熟的解析库，常用的库都集成在 AST Explorer 中，可以实现代码与符合 The ESTree Spec 的 AST 之间的相互转换。下面对规范里的 ES5 的 API 做简要说明。 ESTree AST 中每个节点都要实现以下的 Node 接口，loc 字段表示相关代码的位置信息： interface Node {\rtype: string;\rloc?: SourceLocation;\r}\rinterface SourceLocation {\rsource: string | null;\rstart: Position;\rend: Position;\r}\rinterface Position {\rline: number; // \u003e= 1\r column: number; // \u003e= 0\r}\r ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"Programs 根节点 interface Program \u003c: Node {\rtype: \"Program\";\rbody: [ Statement ];\r}\r AST 的顶部， body 包含了多个 Statement(语句)节点。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:1","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"Patterns 模式 interface Pattern \u003c: Node { }\r 在 ES6 的解构赋值中有意义，如 let {name} = user，其中{name}部分为 ObjectPattern, 对于 ES5，唯一的子类是 Identifier ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:2","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"Expression 表达式 interface Expression \u003c: Node { }\r 表达式，子类很多，有二元表达式(n*n)、函数表达式(var fun = function(){})、数组表达式(var arr = [])、对象表达式(var obj = {})、赋值表达式( a=1)等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:3","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"Identifier 标识符 interface Identifier \u003c: Expression, Pattern {\rtype: \"Identifier\";\rname: string;\r}\r 写代码时自定义的名称，如变量名，函数名，属性名等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:4","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"Literal 字面量 interface Literal \u003c: Expression {\rtype: \"Literal\";\rvalue: string | boolean | null | number | RegExp;\r}\r 从 value 的类型可以看出，字面量就是值，他的类型有字符串，布尔，数值，null 和正则。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:5","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"Statement 语句 interface Statement \u003c: Node { }\r 语句，子类有很多， 块语句、 if/switch语句、 return语句、 for/while语句、 with语句等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:6","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"Declaration 声明 interface Declaration \u003c: Statement { }\r 声明，子类主要有变量申明、函数声明。 ES6，7，8，… 的更多类型补充可以看这一篇 文章。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:7","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"AST 的运用 将原代码转化为 AST，修改 AST，再重新转化为新代码就能完成代码转译。Babel 将最新语法的 JS 代码转化为 ES5 的原理就是这样的。 \rBabel 操作 AST 会用到以下工具包： @babel/parser 用于将代码转换为 AST @babel/traverse 用于对 AST 的遍历，包括节点增删改查、作用域等处理 @babel/generator 用于将 AST 转换成代码 @babel/types 用于 AST 节点操作的 Lodash 式工具库,各节点构造、验证等 更多api详见 Babel手册。 下面是用一个例子讲述具体操作步骤： var obj = {\rfn(){\rconsole.log(\"hello\")\r}\r}\r 我们需要把以上代码转换成下面这样： const obj = {\rfn(){\rconsole.log(\"hello\",\"world\")\r}\r}\r 将两份代码在 AST Explorer 中打开。选择 @babel/parser 为解析器，右边有选项隐藏不需要的属性。对比两颗 AST 发现差异是 kind 和 arguments，因此代码如下： const parser = require(\"@babel/parser\");\rconst traverse = require(\"@babel/traverse\").default;\rconst generate = require(\"@babel/generator\").default;\rconst t = require(\"@babel/types\");\rlet sourceCode = `\rvar obj = {\rfn(){\rconsole.log(\"hello\")\r}\r}\r`\rlet ast = parser.parse(sourceCode);\rtraverse(ast, {\rVariableDeclaration(path) {\rlet { kind } = path.node\rif (kind === \"var\") {\rkind = \"const\"\r}\r},\rCallExpression(path) {\rlet { callee, arguments } = path.node\rif (t.isMemberExpression(callee) \u0026\u0026 callee.object.name === \"console\" \u0026\u0026 callee.property.name === \"log\") {\rarguments.push(t.stringLiteral(\"world\"))\r}\r}\r})\rconsole.log(generate(ast).code);\r 这里 还有更多例子。 参考资料 JS之 执行过程 JS 语法树学习 Javascript抽象语法树 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:3:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["coding"],"content":"Webpack 是一个前端构建工具，前端构建工具的作用就是把开发环境的代码转化成运行环境代码。一般来说，开发环境的代码是为了更好的阅读，而运行环境的代码则是为了能够更快地执行。因此开发环境和运行环境的代码形式也不相同。比如，开发环境的代码，要通过混淆压缩后才能放在线上运行，这样代码体积更小，但对代码执行不会有任何影响。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:0:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"应用场景 一般的构建工具可以处理但不限于以下场景： 代码压缩 将 JS、CSS 代码混淆压缩，让代码体积更小，加载更快。 语法编译 编写CSS时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等，这些标准目前都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。 模块化处理 CSS 和 JS 的模块化语法，目前无法被浏览器兼容。因此开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如使用 Webpack、Rollup 等处理 JS 模块化。 使用 webpack，构建的前端项目是高度可配置的(替换 react，vue 默认 cli 工具)。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:1:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"核心概念 以下概念提取自 webpack 的官方文档，学习更多细节请参阅官方文档。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"Entry 入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。 进入入口起点后, webpack 会找出有哪些模块和库是入口起点(直接和间接)依赖的。 每个依赖项随即被处理,最后输出到称之为 bundles 的内存文件中。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:1","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"Output output 属性指定 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。 基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:2","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"Module 模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:3","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"Chunk 代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:4","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"Loader loader 让 webpack 能够去处理那些非 JS 文件(webpack 自身只理解 JS)。 loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。 本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图(和最终的 bundle)可以直接引用的模块。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:5","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"Plugin loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。 插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:6","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"构建流程 Webpack 在启动后，会从 Entry 开始，递归解析 Entry 依赖的所有 Module，每找到一个 Module，就会根据 Module.rules 里配置的 Loader 规则进行相应的转换处理，对 Module 进行转换后，再解析出当前 Module 依赖的Module，这些 Module 会以 Entry 为单位进行分组，即为一个 Chunk。因此一个 Chunk 就是一个 Entry 及其所有依赖的 Module 合并的结果。最后 Webpack 会将所有的 Chunk 转换成文件输出 Output。在整个构建流程中，Webpack 会在恰当的时机执行 Plugin 里定义的逻辑，从而完成 Plugin 插件的优化任务。 简单的解释就是这样，详细构建流程请看这篇文章。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:3:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"配置入门 下面以一个配置一个 react 开发环境为例，学习 webpack 的基本配置方法。 新建文件夹 webpack-demo，终端进入文件夹执行 npm init 初始化项目。 安装 react: yarn add react react-dom 安装 webpack: yarn add webpack webpack-cli webpack-dev-server -D webpack-cli 提供了一组用于运行和设置 webpack 的命令 Webpack-dev-server 提供 http 服务，实时重载(hot模式)，cors 配置，端口配置等 安装 babel: yarn add @babel/core @babel/preset-react @babel/preset-env babel-loader -D @babel/core 是核心依赖项 @babel/preset-react 添加对 JSX 支持 @babel/preset-env 添加对 ES6 的支持 babel-loader 使用 Babel 和 webpack 转换 react 代码为 JS 安装 CSS Loaders: yarn add css-loader style-loader -D css-loader 从收集 CSS 并将 CSS 转化为字符串 style-loader 将从 css-loader 中获得的字符串嵌入在 html 中的 style 标签中 安装插件: yarn add html-webpack-plugin -D html-webpack-plugin 用于将生成的 output 文件嵌入到指定 html 文件 准备文件: 在根文件夹下创建 src 和 dist 文件夹，在 src 文件夹下创建 main.js，app.js，index.css， 在 dist 文件夹下创建 index.html。 创建 webpack.config.js，这是默认的 webpack 配置文件： //webpack.config.js\rconst path = require('path');\rconst HtmlWebpackPlugin = require('html-webpack-plugin');\rmodule.exports = {\rentry: './src/main.js',\routput: {\rpath: path.join(__dirname, '/dist'),\rfilename: 'bundle.js'\r},\rdevServer: {\rport: 8080\r},\rmodule: {\rrules: [\r{\rtest: /\\.jsx?$/,\rexclude: /node_modules/,\rloader: 'babel-loader',\r},\r{\rtest: /\\.css$/,\ruse: ['style-loader', 'css-loader']\r}\r]\r},\rplugins: [\rnew HtmlWebpackPlugin({\rtemplate: './dist/index.html'\r})\r]\r}\r “entry”: 这是入口 js，webpack将从此处开始打包。 “output”: 打包的文件将位于 “/dist/bundle.js”。 “devServer”: 它定义了 weback-dev-server 的配置，开发服务器的默认端口是8080。 模块规则-这些是转译规则： “test”: 正则表达式，指定哪种文件需要通过 loader 转译。 “exclude”: 指定 loader 应忽略的文件。 “use”: 应用 loader 的数组，注意是从右往左加载 loader。 babel 转译的配置文件 .babelrc： {\r\"presets\":[\"@babel/preset-env\", \"@babel/preset-react\"]\r}\r 在 package.json 中添加脚本： \"start\": \"webpack-dev-server --mode development --open --hot\",\r\"build\": \"webpack --mode production\"\r 将创建的空文件补充完整： \u003c!-- dist/index.html --\u003e\r\u003c!DOCTYPE html\u003e\r\u003chtml lang=\"en\"\u003e\r\u003chead\u003e\r\u003cmeta charset=\"UTF-8\"\u003e\r\u003ctitle\u003eReact Web\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody\u003e\r\u003cdiv id=\"root\"\u003e\u003c/div\u003e\r\u003c!-- html-webpack-plugin 插件生成如下标签\r\u003cscript src='bundle.js'\u003e\u003c/script\u003e --\u003e\r\u003c/body\u003e\r\u003c/html\u003e\r // src/main.js\r\rimport React from 'react';\rimport ReactDOM from 'react-dom';\rimport App from './App.js';\rReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\r // src/app.js \rimport React, { Component } from 'react';\rimport './index.css';\rclass App extends Component {\rrender() {\rreturn (\r\u003cdiv\u003e\r\u003ch1\u003eHello!!\u003c/h1\u003e\r \u003ch2\u003eWelcome to your React App..!\u003c/h2\u003e\r \u003c/div\u003e\r );\r}\r}\rexport default App;\r /* src/index.css */\r* {\rmargin: 0;\rpadding: 0;\r}\r 运行代码: yarn start，打包文件: yarn run build，动手试试吧！ 参考资料 webpack 官方文档 webpack打包原理? 看完这篇你就懂了! 实现一个简单的Webpack ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:4:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["coding"],"content":"WebSocket 是一种服务端和客户端之间的双向通信协议，和 HTTP 一样是基于 TCP 协议的应用层协议，并且 WebSocket 在握手阶段依赖于 HTTP 连接。 WebSocket 广泛应用于多用户实时交流，服务端数据持续变化的场景。比如社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等需要高实时的场景。 学习 WebSocket，请看这篇教程。在 node.js 中，通常使用 socket.io 这个库。socket.io 封装了 WebSocket 服务端 JS 库，同时也提供客户端的 JS 库。Socket.IO 支持以事件为基础的实时双向通讯。它可以兼容各种浏览器或移动设备，从而让开发者可以聚焦到功能的实现而不是平台的兼容性。 ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:0:0","tags":["WebSocket"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["coding"],"content":"Socket.IO 常用 api 常用服务端 api： socket.on('eventName', msg =\u003e {}) /*服务器端监听客户端emit的事件，事件名称可以和客户端是重复的，但是并没有任何关联。\rsocket.io内置了一些事件比如connection，disconnect，exit事件*/\rsocket.emit('eventName', msg) //服务端各自的socket向各自的客户端发送数据\r\rsocket.broadcast('eventName', msg) //服务端向其他客户端发送消息，不包括自己的客户端\r\rsocket.join(channel) //创建一个频道（非常有用，尤其做分频道的时候，比如斗地主这种实时棋牌游戏）\r\rio.sockets.in(channel) //加入一个频道\r\rio.to(channel).emit('eventName', msg)\r//向一个频道发送消息，包括自己的客户端\r\rsocket.broadcast.to(channel).emit('eventName', msg) //向一个频道发送消息，不包括自己的客户端\r\rio.emit('eventName', msg)\r//向所有客户端发送数据\r\rio.sockets.adapter.rooms //获取所有的频道\r 常用客户端 api： //客户端\r io.connect(url) //客户端连接上服务器端，可简写为 io(url)，无跨域时为 io()\r\rsocket.on('eventName', msg =\u003e {}) //客户端监听服务器端事件\r\rsocket.emit('eventName', msg) //客户端向服务器端发送数据\r\rsocket.disconnect() //客户端断开链接\r 更多的 api 请参阅 Socket.IO 的官方文档。这里有一篇搭建实时聊天室的文章，注意文中的 index.html 和 client.js 中的线上服务器地址 realtime.plhwin.com:3000 已经没有了，改为本地地址 localhost:3000 就能运行代码了。index.html 里的 \u003cscript src=\"/socket.io/socket.io.js\"\u003e\u003c/script\u003e\r 指向的文件是其实是 \u003cscript src=\"../server/node_modules/socket.io-client/dist/socket.io.js\"\u003e\u003c/script\u003e\r 整体的开发思路就是服务端和客户端其中一端触发事件，另一端就监听事件。文中的示例程序只用到了事件触发 socket.emit 和事件监听 socket.on。下文的示例程序展示了 Socket.IO 中更多 api 的用法。用户进入聊天室时需要选择房间，进入相同房间的用户才能内部交流，不同房间之间的内部信息不能互通。 \r","date":"2020-08-11","objectID":"/2020-08-11-websocket/:1:0","tags":["WebSocket"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["coding"],"content":"服务端实现 WebSocket 依赖于 http，这里需要安装 socket.io 和 express // server.js\r\rconst path = require('path');\rconst http = require('http');\rconst express = require('express');\rconst socketio = require('socket.io');\rconst formatMessage = require('./utils/messages');\rconst {\ruserJoin,\rgetCurrentUser,\ruserLeave,\rgetRoomUsers\r} = require('./utils/users');\rconst app = express();\rconst server = http.createServer(app);\rconst io = socketio(server);\r// Set static folder\rapp.use(express.static(path.join(__dirname, 'public')));\rconst botName = 'ChatCord Bot';\r// Run when client connects\rio.on('connection', socket =\u003e {\rsocket.on('joinRoom', ({ username, room }) =\u003e {\rconst user = userJoin(socket.id, username, room);\rsocket.join(user.room);\r// Welcome current user\r socket.emit('message', formatMessage(botName, 'Welcome to ChatCord!'));\r// Broadcast when a user connects\r socket.broadcast\r.to(user.room)\r.emit(\r'message',\rformatMessage(botName, `${user.username}has joined the chat`)\r);\r// Send users and room info\r io.to(user.room).emit('roomUsers', {\rroom: user.room,\rusers: getRoomUsers(user.room)\r});\r});\r// Listen for chatMessage\r socket.on('chatMessage', msg =\u003e {\rconst user = getCurrentUser(socket.id);\rio.to(user.room).emit('message', formatMessage(user.username, msg));\r});\r// Runs when client disconnects\r socket.on('disconnect', () =\u003e {\rconst user = userLeave(socket.id);\rif (user) {\rio.to(user.room).emit(\r'message',\rformatMessage(botName, `${user.username}has left the chat`)\r);\r// Send users and room info\r io.to(user.room).emit('roomUsers', {\rroom: user.room,\rusers: getRoomUsers(user.room)\r});\r}\r});\r});\rconst PORT = process.env.PORT || 3000;\rserver.listen(PORT, () =\u003e console.log(`Server running on port ${PORT}`));\r ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:2:0","tags":["WebSocket"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["coding"],"content":"客户端实现 需要先在 html 中引入 socket.io-client，才能使用 io \u003c!-- public/chat.html --\u003e\r\u003cscript src=\"/socket.io/socket.io.js\"\u003e\u003c/script\u003e\r\u003cscript src=\"js/main.js\"\u003e\u003c/script\u003e\r 这里的静态资源文件是由 express 加载的，没有跨域，可省略 io 括号里的地址 // public/js/main.js\r\rconst chatForm = document.getElementById('chat-form');\rconst chatMessages = document.querySelector('.chat-messages');\rconst roomName = document.getElementById('room-name');\rconst userList = document.getElementById('users');\r// Get username and room from URL\rconst { username, room } = Qs.parse(location.search, {\rignoreQueryPrefix: true\r});\rconst socket = io();\r// Join chatroom\rsocket.emit('joinRoom', { username, room });\r// Get room and users\rsocket.on('roomUsers', ({ room, users }) =\u003e {\routputRoomName(room);\routputUsers(users);\r});\r// Message from server\rsocket.on('message', message =\u003e {\rconsole.log(message);\routputMessage(message);\r// Scroll down\r chatMessages.scrollTop = chatMessages.scrollHeight;\r});\r// Message submit\rchatForm.addEventListener('submit', e =\u003e {\re.preventDefault();\r// Get message text\r const msg = e.target.elements.msg.value;\r// Emit message to server\r socket.emit('chatMessage', msg);\r// Clear input\r e.target.elements.msg.value = '';\re.target.elements.msg.focus();\r});\r// Output message to DOM\rfunction outputMessage(message) {\rconst div = document.createElement('div');\rdiv.classList.add('message');\rdiv.innerHTML = `\u003cp class=\"meta\"\u003e${message.username}\u003cspan\u003e${message.time}\u003c/span\u003e\u003c/p\u003e\r\u003cp class=\"text\"\u003e\r${message.text}\u003c/p\u003e`;\rdocument.querySelector('.chat-messages').appendChild(div);\r}\r// Add room name to DOM\rfunction outputRoomName(room) {\rroomName.innerText = room;\r}\r// Add users to DOM\rfunction outputUsers(users) {\ruserList.innerHTML = `\r${users.map(user =\u003e `\u003cli\u003e${user.username}\u003c/li\u003e`).join('')}`;\r}\r 更多内容请看源码。 附：源码地址 参考资料 WebSocket 教程 Socket.IO 官方文档 ChatCord 源码 ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:3:0","tags":["WebSocket"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["coding"],"content":"最近，Facebook 官方开源了一个状态管理库 Recoil，我们来学习一下。Recoil 是基于 Immutable 的数据流管理方案，这是它值得学习的重要原因。Recoil非常易于学习，它的 API 简单强大，对于已经习惯使用 hooks 的人来说很自然。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:0:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["coding"],"content":"核心概念 Recoil 中的核心概念只有 Atom(原子状态) 和 Selector(派生状态)。 \r","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["coding"],"content":"Atom Atom 是状态的单位。它们可更新也可订阅。当 atom 被更新，每个被订阅的组件都将使用新值进行重渲染。如果多个组件使用相同的 atom，则这些组件共享 atom 的状态。可以使用 atom 替代组件内部的 state。atom 也可以在运行时创建。 Atom 是使用 atom 函数创建的： function atom\u003cT\u003e({\rkey: string,\rdefault: T | Promise\u003cT\u003e | RecoilValue\u003cT\u003e,\rdangerouslyAllowMutability?: boolean,\r}): RecoilState\u003cT\u003e\r key：标识 atom 的字符串，必须相对于其他 atom/selector 是唯一值 default：atom 的初始值，可以是静态值，Promise，或返回值类型相同的另一个 atom/seletor 最后一个参数是允许 Mutable，由于 Recoil 默认的 Immutable 特性带来的可预测性更利于调试和维护，一般不设置这个值 定义一个 atom，用来获取输入字符: const textState = atom({\rkey: 'textState', // unique ID (with respect to other atoms/selectors)\r default: '', // default value (aka initial value)\r});\r ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:1","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["coding"],"content":"Selector selector 是一个纯函数，入参为 atom 或其他 selector。selector 被用于计算基于 atom 的派生数据，这使得我们避免了冗余 state，将最小粒度的状态存储在 atom 中，而其它所有内容根据最小粒度的状态进行有效计算。当上游 atom/selector 更新时，将重新执行 selector 函数。组件可以像 atom 一样订阅 selector，当 selector 发生变化时，重新渲染相关组件。 Selector 是使用 selector 函数创建的： function selector\u003cT\u003e({\rkey: string,\rget: ({\rget: GetRecoilValue\r}) =\u003e T | Promise\u003cT\u003e | RecoilValue\u003cT\u003e,\rset?: (\r{\rget: GetRecoilValue,\rset: SetRecoilState,\rreset: ResetRecoilState,\r},\rnewValue: T | DefaultValue,\r) =\u003e void,\rdangerouslyAllowMutability?: boolean,\r}): RecoilValueReadOnly\u003cT\u003e | RecoilState\u003cT\u003e\r type ValueOrUpdater\u003cT\u003e = T | DefaultValue | ((prevValue: T) =\u003e T | DefaultValue);\rtype GetRecoilValue = \u003cT\u003e(RecoilValue\u003cT\u003e) =\u003e T;\rtype SetRecoilState = \u003cT\u003e(RecoilState\u003cT\u003e, ValueOrUpdater\u003cT\u003e) =\u003e void;\rtype ResetRecoilState = \u003cT\u003e(RecoilState\u003cT\u003e) =\u003e void;\r key：标识 selector 的字符串，必须相对于其他 atom/selector 是唯一值 get：get 参数中 get，可以从其他 atom/selector 取值，从而利用依赖关系计算 seletor，传递给此函数的 atom/selector 隐式添加到这个 seletor 的依赖项列表中 set?：设置了该属性，selector 才会返回可写的 state 定义一个 selector，依赖的 atom 是我们上面定义的 textState，用来获取输入字符长度 : const charCountState = selector({\rkey: 'charCountState', // unique ID (with respect to other atoms/selectors)\r get: ({get}) =\u003e {\rconst text = get(textState);\rreturn text.length;\r},\r});\r 测试 atom 和 selector 示例 demo 从组件的角度来看，selector 和 atom 具有相同的功能，因此可以交替使用。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:2","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["coding"],"content":"订阅或更新状态 前面讲述如何用 atom 和 selector 定义 state，下面是 state 的取值和更新函数： useRecoilState：返回 atom/selector 的值和 set 函数，类似 useState。 useRecoilValue：仅返回 atom/selector 的值。 useSetRecoilState：仅返回 atom/seletor 的 set 函数。 useResetRecoilState：重置 atom/selector 到默认值并读取。 在组件中使用这些 hooks 与使用其他 hooks 的方式基本相同： import React from 'react';\rimport { atom, useRecoilState, selector, useRecoilValue } from 'recoil';\rconst textState = atom({\rkey: 'textState', // unique ID (with respect to other atoms/selectors)\r default: '', // default value (aka initial value)\r});\rconst charCountState = selector({\rkey: 'charCountState', // unique ID (with respect to other atoms/selectors)\r get: ({ get }) =\u003e {\rconst text = get(textState);\rreturn text.length;\r},\r});\rexport const CharacterCounter = () =\u003e {\rconst [char, setChar] = useRecoilState(textState);\r// selector 没有定义 set，用 useRecoilValue 取值 const charCount = useRecoilValue(charCountState);\rreturn (\r\u003cdiv\u003e\r\u003cinput\rtype=\"text\"\rvalue={char}\ronChange={(e) =\u003e setChar(e.target.value)}\r/\u003e\r\u003cdiv\u003eEcho: {char}\u003c/div\u003e\r\u003cdiv\u003eCharacter Count: {charCount} \u003c/div\u003e\r\u003c/div\u003e\r);\r};\rexport default CharacterCounter;\r atom，selector 的 state 的取值和更新函数是相同的，selector 未定义 set 只能用 useRecoilValue 取值，定义 set 之后也能用 useRecoilState，因此 atom 应该是基于 selector 的一个特定封装，帮我们封装好了 set，get，而无须自定义。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:2:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["coding"],"content":"异步支持 在 selector 的数据流图中, Recoil 可以让你随意的混合使用同步和异步函数。只需从 selector get 回调中返回一个 Promise，接口完全一样。因为这些只是 selector，其他的 selector 也可以依赖它们来进一步变更数据。selector 是纯函数，是对只读数据库查询进行建模的好方法，其中重复查询可提供一致的数据。 import React from 'react';\rimport {selector, useRecoilValue} from 'recoil';\rconst myQuery = selector({\rkey: 'MyDBQuery',\rget: async () =\u003e {\rconst response = await fetch(getMyRequestUrl());\rreturn response.json();\r},\r});\rfunction QueryResults() {\rconst queryResults = useRecoilValue(myQuery);\rreturn (\r\u003cdiv\u003e\r{queryResults.foo}\r\u003c/div\u003e\r);\r}\rfunction ResultsSection() {\rreturn (\r\u003cReact.Suspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\r\u003cQueryResults /\u003e\r\u003c/React.Suspense\u003e\r );\r}\r atom 是基于 selector 封装，也支持 Promise 做默认 state。不过官方的建议是当其从其他状态或异步请求时派生的 state，应该使用 selector。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:3:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["coding"],"content":"参数查询 有时我们希望通过传递参数动态定义 state，你可以使用 atomFamily 或 selectorFamily 实现这类需求， atom 与 atomFamily，selector 与 selectorFamily 的区别仅仅是定义 state 的时候是否需要参数： const myDataQuery = selectorFamily({\rkey: 'MyDataQuery',\rget: (queryParameters) =\u003e async ({get}) =\u003e {\rconst response = await asyncDataRequest(queryParameters);\rif (response.error) {\rthrow response.error;\r}\rreturn response.data;\r},\r});\rfunction MyComponent() {\rconst data = useRecoilValue(myDataQuery({userID: 132}));\rreturn \u003cdiv\u003e...\u003c/div\u003e;\r}\r 目前 Recoil 还属于实验阶段，能确定的是 Recoil 将兼容 React 并发模式。 我们可以在 Recoil 中学到 React Hook 时代的状态管理的基本模式： state 的读与写分离，做到最优按需渲染。 原子存储的数据相互无关联，关联的数据使用派生值的方式推导。 派生的值必须严格缓存，并在命中缓存时引用保证严格相等。 参考资料 Recoil 官方文档 精读《recoil》 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:4:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["coding"],"content":"权限管理是所有后台系统的都会涉及的一个重要组成部分，主要目的是对不同的人访问资源进行权限的控制，避免因权限控制缺失或操作不当引发的风险问题，如操作错误，隐私数据泄露等问题。 迄今为止最为普及的权限设计模型是RBAC模型,基于角色的访问控制（Role-Based Access Control)，而 RBAC 模型又可以细分为 RBAC0，RBAC1，RBAC2，RBAC3。 本文介绍 RBAC0, 这是权限最基础也是最核心的模型，其他复杂模型也是建立在 RBAC0 之上的。关于 RBAC 还有很多重要理论，具体可参考知乎上的这篇 权限系统设计 和这篇 RBAC理念。本文将带领读者体会 RBAC0 的实践运用，实现 RBAC0 的关键在建立 用户-角色-权限 之间的多对多关系。 \r","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:0:0","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["coding"],"content":"实例 请注意，本文不涉及具体代码讲解。如需具体代码的讲解，请移步到 后端代码讲解 和 前端代码讲解，在这两篇文章末尾附有源码地址。作者的讲解逻辑严密，注重细节，非常优秀，无需我再赘述。本文只演示实例程序，带领读者理解 RBAC0 权限设计模型。 实例程序将网站用户分为三个角色: Admin(管理员), Moderator(版主), User(普通用户)。 所有页面路由：home, rigister, login, profile, user, mod, admin ","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:0","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["coding"],"content":"正常访问截图 对所有未登录用户开放的页面(访客页面): home, register, login \r对网站用户开放的页面： 对 User 开放的页面(用户页面)：访客页面, profile, user \r 对 Moderator 开放的页面：用户页面, mod(导航栏中增加 Moderator Board) 对 Admin 开放的页面：用户页面, admin(导航栏中增加 Admin Board) 正常访问其他页面的更多截图看 这里，或者自己运行前后端代码，修改用户角色需用 postman 向后端接口发送 http 请求或者直接修改数据表。 ","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:1","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["coding"],"content":"越权访问截图 未登录用户访问 user 页面： \rUser 访问 admin 页面： \rUser, Admin 访问 mod 页面, Moderator 访问 admin 页面的显示结果同理。 当一个用户同时具有 User, Moderator, Admin 角色时，就有了所有页面的访问权力。 \r根据用户角色来决定页面的数据，这样就实现了 RBAC0 的基本模型。 参考资料 可能是史上最全的权限系统设计 RBAC理念 实例程序讲解 --","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:2","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["coding"],"content":"这次使用 antd 和 TypeScript 实践一个简单 todolist, 为什么又是 todolist？这个问题好比问为什么写代码第一句是 hello world 一样。只是简单的练手，写什么不重要。这次的代码中暂时还没有实现数据持久化，状态管理等，只是把页面上能够看到的功能实现了。后续我将尝试其他的数据流管理方案。 页面长这样，响应 pc 端，移动端: \r页面上有一个搜索框，过滤列表项。点击添加按钮，弹出会话框，添加列表数据。下面是三个标签选项，点击不同的标签显示不同的列表内容。列表中每一项中的三个图标分别实现的是编辑数据，修改完成状态和删除这一项的功能。 这个 todolist 实例只实现了 Todo，ModalForm(对话框)，TodoList(标签选项下的列表) 组件。ModalForm，TodoList 是 Todo 的子组件。这三个组件就足够完成上述的功能了。 ","date":"2020-06-30","objectID":"/2020-06-30-antd/:0:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["coding"],"content":"定义数据模型 export interface ITodo {\rid: number;\rtext: string;\rdone: boolean;\r}\r ","date":"2020-06-30","objectID":"/2020-06-30-antd/:1:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["coding"],"content":"状态提升 由于没有引入 redux 状态管理库，为了方便组件间的数据传递，一个比较好的做法是将多个组件需要共享的状态提升到它们最近的父组件上(状态提升)。这里的父组件是 Todo 组件。 需要共享的状态有： 1.编辑 TodoList 组件中的 todo 时，需要让对话框显示(showModal) 2.编辑 TodoList 组件中的 todo 时，弹出的对话框需要获得 todo.id(todoId) 3.根据弹出对话框的位置，决定对话框的标题(modalTitle) 先在 Todo 组件中定义需要共享的数据字段： // Todo.ts\rconst [showModal, setShowModal] = useState(false);\rconst [todoId, setTodoId] = useState(1); const [modalTitle, setModalTitle] = useState('');\r 弹出的对话框可能是添加或编辑 todo： export enum ModalType {\rEdit = 'EDIT',\rAdd = 'ADD',\r}\r 根据弹出对话框的位置决定对话框标题: // Todo.ts\r\rconst onShowModal = (type: ModalType, id?: number) =\u003e {\rif (type === ModalType.Add) {\rsetModalTitle('添加任务');\r}\rif (type === ModalType.Edit) {\rsetModalTitle('编辑任务');\rsetTodoId(id!); //记录 TodoList 组件传递的 todoId\r }\rsetShowModal(true);\r};\r 如果是在 Todo 组件的添加按钮: //Todo.ts\r\r\u003cButton type=\"primary\"\rclassName={styles.newTodo}\ronClick={() =\u003e onShowModal(ModalType.Add)}\u003e\r添加\r\u003c/Button\u003e\r 在 Todo 组件点击添加按钮时，显示对话框组件，提交表单时用内部实现的 itemId 作为 todo.id： // ModalForm.ts\r\rconst ModalForm: FC\u003cIModalFormProps\u003e = (props) =\u003e {\rconst { visible, onClose, addTodo, modalTitle } = props;\rconst [itemId, setItemId] = useState(1);\rconst [form] = Form.useForm();\rconst onFinish = () =\u003e {\rconst text: string = form.getFieldValue('content').trim();\rif (modalTitle === '添加任务') {\raddTodo(itemId, text, false);\rsetItemId(itemId =\u003e itemId + 1);\r}\rform.setFieldsValue({ content: '' });\ronClose();\r};\r 在 ts 中需要用 interface 声明父组件传过来的 props 的类型。 // ModalForm.ts\r\rinterface IModalFormProps {\rvisible: boolean;\rmodalTitle: string;\ronClose: () =\u003e void;\raddTodo: (id: number, text: string, flag: boolean) =\u003e void;\r}\r 如果是在 TodoList 中的编辑按钮：Todo 组件将 onShowModal 方法传递给 TodoList 子组件，TodoList 就能让对话框组件显示并传递 todoId 给 Todo 组件： // TodoList.ts\r\r\u003cEditOutlined\rclassName={styles.icon}\ronClick={() =\u003e onShowModal(ModalType.Edit, todo.id)}\r/\u003e\r 在弹出编辑对话框之前，Todo 组件将已经获取到 todoId 传递给对话框组件: // Todo.ts\r\r\u003cModalForm\rmodalTitle={modalTitle}\rtodoId={todoId}\rvisible={showModal}\ronClose={onClose}\raddTodo={addTodo}\rupdateText={updateText}\r/\u003e\r 得到 todoId 就能在对话框提交时更新 todo 了，对话框组件中完善提交表单方法: // ModalForm.ts\r\rconst { visible, onClose, addTodo, modalTitle, todoId, updateText } = props;\rconst onFinish = () =\u003e {\rconst text: string = form.getFieldValue('content').trim();\rif (modalTitle === '添加任务') {\raddTodo(itemId, text, false);\rsetItemId(itemId =\u003e itemId + 1);\r}\rif (modalTitle === '编辑任务') {\rupdateText(todoId, text);\r}\rform.setFieldsValue({ content: '' });\ronClose();\r};\r ","date":"2020-06-30","objectID":"/2020-06-30-antd/:2:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["coding"],"content":"列表的增删改查 先在 Todo 组件中定义列表数据状态： //Todo.ts\r\rconst [lists, setlists] = useState\u003cITodo[]\u003e([]);\r 接下来实现列表的增删改查： // Todo.ts\r\rconst addTodo = (id: number, text: string, done: boolean) =\u003e {\rconst Item = { id, text, done };\rsetlists([Item, ...lists]);\rmessage.success('新增成功');\r};\rconst deleteTodo = (id: number) =\u003e {\rconst newlists = lists.filter(i =\u003e i.id !== id)\rsetlists([...newlists]);\rmessage.success('删除成功');\r};\rconst toggleDone = (id: number) =\u003e {\rconst newlists = lists.map(i =\u003e\ri.id === id\r? {\r...i,\rdone: !i.done\r}\r: i\r)\rsetlists([...newlists]);\r}\rconst updateText = (id: number, text: string) =\u003e {\rconst newlists = lists.map(i =\u003e\ri.id === id\r? {\r...i,\rtext\r}\r: i\r)\rsetlists([...newlists]);\rmessage.success('编辑成功');\r}\r 代办项，已完成，清单三个标签过滤列表： // Todo.ts\r\rconst todoList = lists.filter(item =\u003e !item.done);\rconst doneList = lists.filter(item =\u003e item.done);\r ","date":"2020-06-30","objectID":"/2020-06-30-antd/:3:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["coding"],"content":"实现搜索功能 先在 Todo 组件中定义搜索数据状态： //Todo.ts\r\rconst [searchText, setSearchText] = useState('');\r 实现按搜索字段过滤数据的方法： // Todo.ts \rconst getFilter = (lists: ITodo[], searchText: string) =\u003e {\rif (searchText.trim() !== '') {\rreturn lists.filter(todo =\u003e todo.text.toLowerCase().includes(searchText.toLowerCase()));\r}\rreturn lists;\r};\r Todo 组件将列表数据先用 getFilter 方法过滤再传递给 TodoList 子组件： //Todo.ts\r\r\u003cTabs defaultActiveKey=\"1\" size={\"large\"}\u003e\r\u003cTabPane tab={\u003cBadge status=\"warning\" text=\"待办项\" /\u003e} key=\"1\"\u003e\r\u003cTodoList\rlists={getFilter(todoList, searchText)}\rupdateText={updateText}\rtoggleDone={toggleDone}\rdeleteTodo={deleteTodo}\ronShowModal={onShowModal}/\u003e\r\u003c/TabPane\u003e\r \u003c/Tabs\u003e\r 上面是待办项列表的数据传递，如果是已完成或清单组件，只需将 getFilter 的第一个参数替换为 doneList 或 lists，所有功能就完成了。 续：发现了一个状态管理库 Easy Peasy, 个人感觉比 redux 简洁。这里有一个 todolist 例子。 附：源码地址 ","date":"2020-06-30","objectID":"/2020-06-30-antd/:4:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["coding"],"content":"数据分页获取 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["coding"],"content":"引入依赖，连接数据库 在 spring-boot 项目的根目录 pom.xml 添加依赖，相关依赖有 lombok, mybatis-plus, druid, swagger, mysql 驱动等。 \u003cdependency\u003e\r\u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e\r\u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e\r\u003cversion\u003e3.1.0\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e\r\u003cartifactId\u003elombok\u003c/artifactId\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e\r\u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e\r\u003cversion\u003e1.1.9\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003emysql\u003c/groupId\u003e\r\u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e\r\u003cscope\u003eruntime\u003c/scope\u003e\r\u003cversion\u003e8.0.12\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eio.springfox\u003c/groupId\u003e\r\u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e\r\u003cversion\u003e2.8.0\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eio.springfox\u003c/groupId\u003e\r\u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e\r\u003cversion\u003e2.8.0\u003c/version\u003e\r\u003c/dependency\u003e\r 然后在 src/main/resources 文件夹下添加 application.properties 或 application.yml 文件配置数据库连接。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:1","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["coding"],"content":"创建数据表 本地连接数据库，然后导入脚本，创建数据表。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:2","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["coding"],"content":"创建 entity 及 mapper 创建文章实体(entity) @Data\r@EqualsAndHashCode(callSuper = false)\r@Accessors(chain = true)\r@ApiModel(value = \"Article对象\", description = \"\")\rpublic class Article implements Serializable {\rprivate static final long serialVersionUID = 1L;\r@TableId(value = \"id\", type = IdType.AUTO)\rprivate Integer id;\r@ApiModelProperty(value = \"标题\")\rprivate String title;\r@ApiModelProperty(value = \"内容\")\rprivate String content;\r@ApiModelProperty(value = \"用户主键\")\rprivate Integer uId;\r@ApiModelProperty(value = \"热度\")\rprivate Integer score;\r@ApiModelProperty(value = \"版块主键/为0时表示未设置\")\rprivate Integer bId;\r@JsonFormat(pattern = \"yyyy-MM-dd\", timezone = \"GMT+8\")\rprivate Date createDate;\r@JsonFormat(pattern = \"yyyy-MM-dd\", timezone = \"GMT+8\")\rprivate Date updateDate;\r@TableField(exist = false)\rprivate User user;\r@TableField(exist = false)\rprivate Block block;\r}\r lombok 的注解： @Data 相当于 @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode 这5个注解的合集。 存在继承,编译时有警提示，加上@EqualsAndHashCode(callSuper=false), 只比较当前的类字段。 @Accessors(chain = true)链式调用为真, setter方法返回当前对象 序列化对象，便于存储，便于传输。 mybatis-plus 的注解： @TableId 主键的映射,主键的生成策略,自动生成。 @TableField(exist = false) 不映射数据表字段。 swagger 的注解： @Api 开头的是 swagger 的注解。 对应的 Mapper 只需继承 BaseMapper，基本的 crud 方法 mybatis-plus 已经封装好了。 @Mapper\r@Component\rpublic interface ArticleMapper extends BaseMapper\u003cArticle\u003e {\r}\r @Component 注解代表需要被 Spring IoC 容器管理，才能实现依赖注入。 然后在启动类中加入 @MapperScan(\"\") 就可以完成 spring-boot 到数据表的映射。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:3","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["coding"],"content":"创建 service 创建 service，我们想要分页获取数据，先配置 mybatis-plus 分页插件： @Configuration\r@MapperScan(\"com.forum.buge_server.mapper*\")\rpublic class MybatisPlusConfig {\r/**\r* 加载分页插件\r* * @return\r*/\r@Bean\rpublic PaginationInterceptor paginationInterceptor() {\rreturn new PaginationInterceptor();\r}\r}\r 定义 service 接口 public interface ArticleService extends IService\u003cArticle\u003e {\rIPage\u003cArticle\u003e getArticlePageing(IPage\u003cArticle\u003e iPage, LambdaQueryWrapper\u003cArticle\u003e wrapper);\r}\r service 实现类 在实现类里注入 mapper, 完成分页获取数据。selectPage 方法接收两个参数，第一个是 IPage 对象，第二个参数是条件构造器 QueryWrapper。我们需要在 controller 中传递这两个参数。 @Service\rpublic class ArticleServiceImpl extends ServiceImpl\u003cArticleMapper, Article\u003e implements ArticleService {\r@Autowired\rArticleMapper articleMapper;\r@Override\rpublic IPage\u003cArticle\u003e getArticlePageing(IPage\u003cArticle\u003e iPage, LambdaQueryWrapper\u003cArticle\u003e wrapper) {\rIPage\u003cArticle\u003e articleIPage = articleMapper.selectPage(iPage, wrapper);\rreturn articleIPage;\r}\r}\r ","date":"2020-06-18","objectID":"/2020-06-18-forum/:2:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["coding"],"content":"创建 controller 我们需要传递 IPage 对象，QueryWrapper 对象给 service，然后从返回的 IPage 对象中取得查询到的数据。 @RestController\r@RequestMapping(\"/open\")\rpublic class OpenController {\r@Autowired\rArticleService articleService;\r@ApiOperation(\"分页查询文章，时间排序\")\r@PostMapping(\"/article/new\")\rpublic Object getArticleNew(Integer current, Integer size) {\r// 分页条件\r IPage\u003cArticle\u003e page = new Page\u003c\u003e(current, size);\r// 查询条件\r LambdaQueryWrapper\u003cArticle\u003e wrapper = new LambdaQueryWrapper\u003c\u003e();\r// 根据时间顺序查询\r wrapper.orderByDesc(Article::getCreateDate);\rIPage\u003cArticle\u003e articlePageing = articleService.getArticlePageing(page, wrapper);\r// 当前页数\r long atCurrent = articlePageing.getCurrent();\r// 当前页的数据\r List\u003cArticle\u003e records = articlePageing.getRecords();\rfor (Article article : records) {\rarticle.setContent(\"\");\rarticle.setUser(userService.getById(article.getUId()));\rarticle.setBlock(blockService.getById(article.getBId()));\r}\r// 组装Dto\r PageResult pageResult = new PageResult();\rpageResult.setCurrent(atCurrent);\rpageResult.setList(records);\rreturn new JsonResult(200, \"查询成功\", pageResult);\r}\r}\r 这样就实现了数据时间排序的分页获取。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:3:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["coding"],"content":"JWT 登录验证 添加依赖 \u003cdependency\u003e\r\u003cgroupId\u003eio.jsonwebtoken\u003c/groupId\u003e\r\u003cartifactId\u003ejjwt\u003c/artifactId\u003e\r\u003cversion\u003e0.7.0\u003c/version\u003e\r\u003c/dependency\u003e\r 写一个 jwt 工具类 @Component\r@Data\rpublic class JwtConfig {\rprivate String secret = \"abcdefg1234567\";\rprivate long expire = 3600 * 60 * 60;\rprivate String header = \"token\";\r/**\r* 生成token\r* * @param subject\r* @return\r*/\rpublic String createToken(String subject) {\rDate nowDate = new Date();\rDate expireDate = new Date(nowDate.getTime() + expire * 1000);// 过期时间\r\rreturn Jwts.builder().setHeaderParam(\"typ\", \"JWT\").setSubject(subject).setIssuedAt(nowDate)\r.setExpiration(expireDate).signWith(SignatureAlgorithm.HS512, secret).compact();\r}\r/**\r* 获取token中注册信息\r* * @param token\r* @return\r*/\rpublic Claims getTokenClaim(String token) {\rtry {\rreturn Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();\r} catch (Exception e) {\r// e.printStackTrace();\r return null;\r}\r}\r/**\r* 验证token是否过期失效\r* * @param expirationTime\r* @return\r*/\rpublic boolean isTokenExpired(Date expirationTime) {\rreturn expirationTime.before(new Date());\r}\r}\r 里面写了 token 的生成和解密的方法。 添加 jwt 拦截器, 除了注册，登录和 get 请求的 uri 地址，都需要验证 token。 @Component\rpublic class TokenInterceptor extends HandlerInterceptorAdapter {\rJwtConfig jwtConfig = new JwtConfig();\r@Override\rpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\rthrows Exception {\rif (request.getMethod().equals(\"OPTIONS\")) {\rreturn true;\r}\r/** 地址过滤 */\rString uri = request.getRequestURI();\rif (uri.contains(\"/api/login\") || uri.contains(\"/api/reg\") || uri.contains(\"/sys/login\")\r|| uri.contains(\"/api/get\")) {\rreturn true;\r}\r/** Token 验证是否存在 */\rString token = request.getHeader(jwtConfig.getHeader());\rif (StringUtils.isEmpty(token)) {\rtoken = request.getParameter(jwtConfig.getHeader());\r}\rif (StringUtils.isEmpty(token)) {\rthrow new SignatureException(jwtConfig.getHeader() + \"不能为空\");\r}\rClaims claims = null;\r// 判断是否有效\r try {\rclaims = jwtConfig.getTokenClaim(token);\rif (claims == null || jwtConfig.isTokenExpired(claims.getExpiration())) {\rthrow new SignatureException(jwtConfig.getHeader() + \"失效，请重新登录。\");\r}\r} catch (Exception e) {\rthrow new SignatureException(jwtConfig.getHeader() + \"失效，请重新登录。\");\r}\r/** 设置 identityId 用户身份ID */\rrequest.setAttribute(\"identityId\", claims.getSubject());\rreturn true;\r}\r}\r ","date":"2020-06-18","objectID":"/2020-06-18-forum/:4:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["coding"],"content":"点赞关注收藏评论 点赞，关注，收藏，评论功能都可以用单表实现。点赞，收藏，评论功能就是在分别在likes, collection, comment 表中记录 uid(用户),aid(文章) 实现关联，而关注则是在 follow 表中记录两个 uid 实现关联，下面给出点赞功能的逻辑实现，关注，收藏，评论功能的逻辑同点赞功能。 @PostMapping(\"/add/like\")\rpublic Object setLike(Integer aid, HttpServletRequest request) {\rClaims token = jwtConfig.getTokenClaim(request.getHeader(\"token\"));\rString subject = token.getSubject();\rLambdaQueryWrapper\u003cLikes\u003e queryWrapper = new LambdaQueryWrapper\u003c\u003e();\rqueryWrapper.eq(Likes::getUid, Integer.valueOf(subject));\rqueryWrapper.eq(Likes::getAId, aid);\rLikes one = likeService.getOne(queryWrapper);\rif (one == null) {\rboolean save = likeService.save(new Likes().setAId(aid).setUid(Integer.valueOf(subject)));\rreturn new JsonResult(200, \"点赞成功!\");\r} else {\rboolean b = likeService.removeById(one.getId());\rreturn new JsonResult(200, \"已取消点赞!\");\r}\r}\r ","date":"2020-06-18","objectID":"/2020-06-18-forum/:5:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["coding"],"content":"搜索和浏览记录 搜索使用 mysql 的模糊查询实现。 @PostMapping(\"/search/article\")\rpublic Object searchArticle(String title) {\rLambdaQueryWrapper\u003cArticle\u003e articleWrapper = new LambdaQueryWrapper\u003c\u003e();\rarticleWrapper.like(Article::getTitle, title);\rList\u003cArticle\u003e list = articleService.list(articleWrapper);\rfor (Article article : list) {\rarticle.setContent(\"\");\rarticle.setUser(userService.getById(article.getUId()));\rarticle.setBlock(blockService.getById(article.getBId()));\r}\rreturn new JsonResult(200, \"\", list);\r}\r 浏览记录，进入文章详情页面后，如果用户是登录状态，就加入 History 表。 History 表有三个字段，uid(用户), aid(文章), time(访问时间)。如果已经在 History 表中存在记录，则更新时间。 @GetMapping(\"/article/{id}\")\rpublic Object getArticleById(@PathVariable(\"id\") Integer id, HttpServletRequest request) {\rClaims token = jwtConfig.getTokenClaim(request.getHeader(\"token\"));\r// 在登陆状态下保存到历史表中\r if (token != null) {\rString subject = token.getSubject();\rLambdaQueryWrapper\u003cHistory\u003e queryWrapper = new LambdaQueryWrapper\u003c\u003e();\rqueryWrapper.eq(History::getAid, id);\rqueryWrapper.eq(History::getUid, Integer.valueOf(subject));\rHistory one = historyService.getOne(queryWrapper);\r// 如果已存在记录，则更新时间\r History history = new History().setAid(id).setTime(new Date()).setUid(Integer.valueOf(subject));\rif (one == null) {\rhistoryService.save(history);\r} else {\rone.setTime(new Date());\rhistoryService.updateById(one);\r}\r}\rArticle byId = articleService.getById(id);\rbyId.setUser(userService.getById(byId.getUId()));\rbyId.setBlock(blockService.getById(byId.getBId()));\r// 每次访问热度加1\r articleService.updateById(new Article().setId(id).setScore(byId.getScore() + 1));\rreturn new JsonResult(200, \"查询成功\", byId);\r}\r 每次访问文章详情页，文章热度发生变化，首页热度排序的内容将重新排序。 项目启动主类 @SpringBootApplication\rpublic class BugeServerApplication {\rpublic static void main(String[] args) {\rSpringApplication.run(BugeServerApplication.class, args);\r}\r}\r spring boot提供了一个统一的注解@SpringBootApplication。 代表了@Configuration, @EnableAutoConfiguration, @ComponentScan。 @Configuration 和 @Bean。使用这两个注解就可以创建一个简单的spring配置类，可以用来替代相应的xml配置文件。@Configuration的注解类标识这个类可以使用Spring IoC容器作为bean定义的来源。@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。 @EnableAutoConfiguration：能够自动配置spring的上下文，试图猜测和配置你想要的bean类，通常会自动根据你的类路径和你的bean定义自动配置。 @ComponentScan：会自动扫描指定包下的全部标有@Component的类，并注册成bean，当然包括@Component下的子注解@Service, @Repository, @Controller。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:6:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["coding"],"content":"本文记录 react-beautiful-dnd 这个拖拽库的使用，我们将完成一个类似 trello 的看板应用。最终实现的效果如下：List 是一个可横向拖放的列表，Card 可在不同的 List 列表之间拖放。左上方的搜索框能够搜索筛选卡片，右上方的按钮能够实现撤销重做功能。 \r","date":"2020-05-18","objectID":"/2020-05-18-trello/:0:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["coding"],"content":"拖拽库的使用 react-beautiful-dnd 这个库使用 render-props 完成组件逻辑复用。react-beautiful-dnd 有 3 个主要组件：DragDropContext，Droppable和Draggable。这三者的关系如下： \rDragDropContext 表示一个全局拖拽上下文。Droppable 表示可以被拖入的容器，Draggable 是可被拖放的组件。 DragDropContext 提供了以下三个钩子： onDragStart 拖动开始时执行。 onDragUpdate 拖动过程中的执行。 onDragEnd 拖拽结束时执行，且 onDragEnd 必须设定。 我们需要在 Board 组件内建立可拖动范围，则需要这样写： // components/Board.js\r\rconst Board = () =\u003e {\r// onDragEnd 需实现\r const onDragEnd = result =\u003e {};\rreturn (\r\u003cDragDropContext onDragEnd={onDragEnd}\u003e\r...\r\u003c/DragDropContext\u003e\r);\r}\r Droppable： Droppable 必须设定 droppableId Droppable 使用 render-props 意味着内部须使用一个函数，该函数接收参数 provided 对象, 然后将参数 provided 的属性传递给封装后的可拖放的容器组件 将 Board 组件建立成可拖放的容器组件，像这样写： // components/Board.js\r\r// 需嵌套在 DragDropContext 内\r// 包裹 List 的容器，List 在 Board 容器内横向拖动\r\u003cDroppable droppableId='all-lists' direction='horizontal' type='list'\u003e\r{ provided =\u003e (\r// 封装后的可拖放的容器组件\r \u003cListContainer ref={provided.innerRef}\r{...provided.droppableProps}\u003e\r// 遍历所有的列表，将列表数据传递给每个列表\r {Object.keys(lists).map((key, index) =\u003e {\rconst list = lists[key];\rconst listCards = list.cards.length \u003e 0 ? list.cards : [];\rreturn (\r\u003cList\rkey={list.id}\rid={list.id}\rtitle={list.title}\rcards={listCards}\rindex={index}\r/\u003e\r);\r})}\r{provided.placeholder}\r\u003c/ListContainer\u003e\r)}\r\u003c/Droppable\u003e\r Draggable： Draggable 必须设定 draggableId，index(由父组件传入) Draggable 与 Droppable 一样是 render-props，接收 provided 对象，返回值是封装后的可拖放组件 将 List 组件建立成可拖放组件，像这样写： // components/List.js\r\r// 设置每个 List 都是可拖动的\rconst List = ({ id, title, cards = [], index }) =\u003e {\r...\rreturn (\r\u003cDraggable draggableId={id} index={index}\u003e\r{ provided =\u003e (\r// 封装后的可拖放组件\r \u003cListContainer ref={provided.innerRef}\r{...provided.draggableProps}\r// dragHandleProps 绑定的组件 ListContainer 可拖动\r{...provided.dragHandleProps}\u003e ...\r\u003c/ListContainer\u003e\r)}\r\u003c/Draggable\u003e\r);\r}\r 同理设置 Card 组件可在 List 组件内部拖动，先要将 List 内部封装成可拖放的容器，像这样写: // components/List.js\r\r// 需嵌套在 List 组件返回的 ListContainer 内\r// 包裹 Card 的容器，Card 在 List 容器内可拖放\r\u003cDroppable droppableId={id} type=\"card\"\u003e\r{provided =\u003e (\r\u003cCardContainer ref={provided.innerRef}\r{...provided.droppableProps}\u003e\r// 遍历每个 List 中所有的卡片，将卡片数据传给每张卡片\r {cards.map((card, index) =\u003e (\r\u003cCard\rkey={card.id}\rid={card.id}\rtext={card.text}\rlistId={id}\rindex={index}\r/\u003e\r))}\r{provided.placeholder}\r\u003c/CardContainer\u003e\r)}\r\u003c/Droppable\u003e\r 将 Card 组件封装成可拖放组件，像这样写: // components/Card.js\r\rconst Card = ({ id, text, index, listId }) =\u003e {\r...\rreturn (\r\u003cDraggable draggableId={id} index={index}\u003e\r{provided =\u003e (\r\u003cCardContainer\rclassName='card'\rref={provided.innerRef}\r{...provided.draggableProps}\r// dragHandleProps 绑定的组件 CardContainer 可拖动\r{...provided.dragHandleProps}\u003e\r\u003c/CardContainer\u003e\r)}\r\u003c/Draggable\u003e\r);\r}\r ","date":"2020-05-18","objectID":"/2020-05-18-trello/:1:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["coding"],"content":"状态管理 初始化列表数据: // morkData.js\r\rimport { uuid } from 'uuidv4';\rconst getCard = text =\u003e ({\rid: uuid(),\rtext\r});\rexport const ListState = [\r{\rid: uuid(),\rtitle: 'To Do',\rcards: [\rgetCard('To do task'),\rgetCard('TO FILTER: To do task'),\r]\r},\r{\rid: uuid(),\rtitle: 'Doing',\rcards: [\rgetCard('Doing task'),\rgetCard('TO FILTER: Doing task'),\r]\r},\r{\rid: uuid(),\rtitle: 'Done',\rcards: [\rgetCard('Done task'),\rgetCard('TO FILTER: Done task'),\r]\r},\r];\r 记录状态变更用 DragDropContext 上的钩子函数 onDragEnd，onDragEnd 接收一个 result 对象，result 记录了拖拽过程中的状态变化，result 结构如下： const result = {\rdraggableId: 1, // 移动的组件 id\r type: 'list',\rsource: {\rdroppableId: 1, // 移动前所在的容器 id\r index: 2, // 组件在移动前的容器内的位置\r },\rdestination: {\rdroppableId: 3, // 移动后所在的容器 id\r index: 1, // 组件在移动后的容器内的位置\r }\r}\r 我们需要写拖放组件后的状态变化逻辑，因为我们的列表数据中的 cards 数组发生了变化，但我们还没有把新的状态渲染到 list 组件中，拖放组件后需要重新排序，现在去实现在 Board 组件中定义的 onDragEnd 钩子函数： // components/Board.js\r\rconst onDragEnd = ({ draggableId, type, source, destination }) =\u003e {\rif (destination) {\rdispatch(\rsort(\rsource.droppableId, destination.droppableId,\rsource.index,\rdestination.index,\rdraggableId,\rtype\r)\r);\r}\r};\r action 用 payload 传递接收到的数据： // actions/listActions.js\r\rimport { CONSTANTS } from '.';\r...\rexport const sort = (\rdroppableIdStart, droppableIdEnd, droppableIndexStart, droppableIndexEnd, draggableId,\rtype\r) =\u003e {\rreturn {\rtype: CONSTANTS.DRAGGED, // 动作是拖放，可能是列表，也可能是卡片\r payload: {\rdroppableIdStart, //开始时所在的 container id\r droppableIdEnd, //结束时所在的 container id\r droppableIndexStart, //开始所在 container 里的索引\r droppableIndexEnd, //结束时所在的 container 里的索引\r draggableId, // 移动的组件 id\r type\r}\r};\r};\r reducer 实现状态变化逻辑并返回新状态，始终用新状态替换原来的状态，不要直接在原来的对象上操作，因为我们将会对每个状态做记录，这有利于我们实现撤销重做功能。 // reducers/listReducer.js\r\rcase CONSTANTS.DRAGGED: { // 当完成拖放动作时\r const {\rdroppableIdStart,\rdroppableIdEnd, droppableIndexStart,\rdroppableIndexEnd,\rtype\r} = action.payload;\rconst newState = [...state]; //深拷贝不改变原列表\r if (type === 'list') {\rconst moveList = newState.splice(droppableIndexStart, 1);\rnewState.splice(droppableIndexEnd, 0, ...moveList);\rconsole.log('Drag list', newState);\rreturn newState;\r}\rconst sourceListIndex = newState.findIndex(list =\u003e droppableIdStart === list.id);\rconst sourceList = newState[sourceListIndex];\rconst sourceCards = [...sourceList.cards]; //深拷贝不改变原数组\r const moveCard = sourceCards.splice(droppableIndexStart, 1);\rif (droppableIdStart !== droppableIdEnd) { //不同列之间移动卡片\r const destinationListIndex = newState.findIndex(list =\u003e droppableIdEnd === list.id);\rconst destinationList = newState[destinationListIndex];\rconst destinationCards = [...destinationList.cards];\rdestinationCards.splice(droppableIndexEnd, 0, ...moveCard);\rnewState[destinationListIndex] = {\r...newState[destinationListIndex],\rcards: destinationCards\r};\r} else { //同列中改变卡片次序\r sourceCards.splice(droppableIndexEnd, 0, ...moveCard);\r}\rnewState[sourceListIndex] = {\r...newState[sourceListIndex],\rcards: sourceCards\r};\rconsole.log('Drag card', newState);\rreturn newState;\r}\r 这样就实现了移动列表和移动卡片的状态变化逻辑，剩下的列表和卡片的增删改查的状态变化逻辑的实现就比较容易了。 ","date":"2020-05-18","objectID":"/2020-05-18-trello/:2:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["coding"],"content":"搜索卡片 在界面上实现卡片的搜索功能，实际上就是实现筛选卡片功能。我们已经在每个 List 组件中遍历其中的 Card，筛选功能就是每个 List 组件根据搜索框的输入内容选择性的遍历 Card，修改 List 组件如下： // components/List.js\r\r...\r\u003cDroppable droppableId={String(id)} type=\"card\"\u003e\r{(provided, snapshot) =\u003e (\r\u003cCardListContainer ref={provided.innerRef}\risDraggingOver={snapshot.isDraggingOver}\r{...provided.droppableProps}\u003e\r// 筛选出每个 List 中符合搜索条件的 cards\r {getFilteredCards(cards, searchText).map((card, index) =\u003e (\r\u003cCard\rkey={card.id}\rid={card.id}\rtext={card.text}\rlistId={id}\rindex={index}\r/\u003e\r))}\r{provided.placeholder}\r\u003c/CardListContainer\u003e\r)}\r\u003c/Droppable\u003e\r 实现其中的 getFilteredCards 方法： const getFilteredCards = (cards, searchText) =\u003e {\rif (searchText) {\rconsole.log(searchText);\rreturn cards.filter(card =\u003e card.text.toLowerCase().includes(searchText.toLowerCase()));\r}\rreturn cards;\r};\r ","date":"2020-05-18","objectID":"/2020-05-18-trello/:3:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["coding"],"content":"撤销重做功能 实现撤销重做功能可用 redux-undo 这个库，自己实现也不复杂，下面就自己实现: 实现方法是自定义一个接收 reducer 为参数，返回新 reducer 的函数(reducer enhancer)，监听 listReducer 的变化并做记录。实现思路来自 redux 官方文档。原本创建 store 时需要导出的 reducer 如下： // reducers/index.js\r\rconst rootReducer = combineReducers({\rlists: listReducer,\r...\r});\rexport default rootReducer;\r combineReducers 接收值为 reducer 的函数作为参数，我们只要实现一个返回值为 reducer 的函数(reducer enhancer)就行： const rootReducer = combineReducers({\rboard: stateEnhancer(listReducer),\r...\r});\rexport default rootReducer;\r board 对应的值是将 listReducer 封装后的新 reducer，这样每次调用 listReducer 时也会调用 stateEnhancer，因为函数的参数发生了变化，函数就会重新执行。 // reducers/stateEnhancer.js\r\rimport { CONSTANTS } from '../actions';\rconst stateEnhancer = reducer =\u003e {\rconst initialState = {\rpreviousStates: [],\rcurrentState: reducer(undefined, {}), // currentState 取 reducer 的返回值\r futureStates: []\r};\r// 调用 reducer 时就会调用 stateEnhancer, 并返回封装后的 reducer\r return (state = initialState, action) =\u003e {\r// console.log(state.currentState);\r const { previousStates, currentState, futureStates } = state;\rswitch (action.type) {\rcase CONSTANTS.UNDO_ACTION:\rconst previous = previousStates[previousStates.length - 1];\rconst newPreviousStates = previousStates.slice(0, previousStates.length - 1);\rreturn {\rpreviousStates: newPreviousStates,\rcurrentState: previous,\rfutureStates: [currentState, ...futureStates]\r};\rcase CONSTANTS.REDO_ACTION:\rconst next = futureStates[0];\rconst newFutureStates = futureStates.slice(1);\rreturn {\rpreviousStates: [...previousStates, currentState],\rcurrentState: next,\rfutureStates: newFutureStates\r};\rdefault:\rconst newCurrentState = reducer(currentState, action);\rif (currentState === newCurrentState) { //初始化列表\r console.log('init');\rreturn state;\r}\rconsole.log('list change'); // 列表变化时\r return {\rpreviousStates: [...(previousStates || []), currentState],\rcurrentState: newCurrentState,\rfutureStates: []\r};\r}\r};\r};\rexport default stateEnhancer;\r 我们用了三个数组记录 listReducer 的变化，按下撤销或者重做功能按钮时，就能在不同的 listReducer 之间切换。并且我们可以根据 previousStates， futureStates 是否为空来判断撤销，重做按钮是否可用： \u003cDoBtn onClick={undo} disabled={previousStates.length === 0} className='btn'\u003e\r\u003ci className=\"fas fa-undo\"\u003e\u003c/i\u003e\r\u003c/DoBtn\u003e\r\u003cDoBtn onClick={redo} disabled={futureStates.length === 0} className='btn' \u003e\r\u003ci className=\"fas fa-redo\"\u003e\u003c/i\u003e\r\u003c/DoBtn\u003e\r 附：源码地址 参考资料 React Beautiful Dnd 快速使用筆記 redux 文档 - 实现撤销历史 ","date":"2020-05-18","objectID":"/2020-05-18-trello/:4:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["coding"],"content":"React 组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。 React 组件分为两类，class 组件和函数组件。hooks 的出现让函数组件拥有了状态(state), 因此让自定义 hook 成为了继 render-props 和高阶组件(HOC)之后的第三种状态共享方案。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hook/:0:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hook/"},{"categories":["coding"],"content":"class 组件的状态共享 ","date":"2020-05-07","objectID":"/2020-05-07-react-hook/:1:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hook/"},{"categories":["coding"],"content":"render-props 具有 render prop 的组件接受一个函数，该函数返回一个 React 元素并调用它(回调函数)而不是实现自己的渲染逻辑。 react官网示例： class Cat extends React.Component {\rrender() {\rconst mouse = this.props.mouse;\rreturn (\r\u003cimg src=\"/cat.jpg\" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /\u003e\r);\r}\r}\rclass Mouse extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.handleMouseMove = this.handleMouseMove.bind(this);\rthis.state = { x: 0, y: 0 };\r}\rhandleMouseMove(event) {\rthis.setState({\rx: event.clientX,\ry: event.clientY\r});\r}\rrender() {\rreturn (\r\u003cdiv style={{ height: '100vh' }} onMouseMove={this.handleMouseMove}\u003e\r{/*使用`render`属性来动态确定要渲染的内容。*/}\r{this.props.render(this.state)}\r\u003c/div\u003e\r);\r}\r}\rclass MouseTracker extends React.Component {\rrender() {\rreturn (\r\u003cdiv\u003e\r\u003ch1\u003e移动鼠标!\u003c/h1\u003e\r{/*将 Mouse 组件中的 state 传递给 Cat 组件*/}\r\u003cMouse render={mouse =\u003e (\r\u003cCat mouse={mouse} /\u003e\r)}/\u003e\r\u003c/div\u003e\r);\r}\r}\r 注意 Mouse 组件中的 this.props.render 是绑定在标签模板上的render(外部传入)。这样就实现了鼠标位置状态的共享, Cat 组件能够根据鼠标位置动态移动 cat 图片。这个示例实现了 react 组件的理想状态：有状态的组件无渲染，有渲染的组件无状态。 因为 Cat 组件只是一个渲染模板，它也可以替换成如下的函数组件: const Cat = (props) =\u003e {\rconst mouse = this.props.mouse;\rreturn (\r\u003cimg src=\"/cat.jpg\" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /\u003e\r);\r}\r}\r UI与状态分离，便于逻辑的复用。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hook/:1:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hook/"},{"categories":["coding"],"content":"高阶组件(HOC) 高阶组件是参数为组件，返回值为新组件的函数，高阶组件是函数。 const EnhancedComponent = higherOrderComponent(WrappedComponent);\r 示例： function high(WrappedComponent){\rreturn class extends React.Component{\rconstructor(){\rthis.state={\ropen:false\r}\r}\rcomponentDidMount(){\rconsole.log('haha')\r}\rchange=()=\u003e{\rthis.setState((state)=\u003e{//用到state需要使用回调函数修改state的值\r return {open:!state.open}\r})\r}\rrender(){\r//使用新数据渲染被包装的组件\r return \u003cWrappedComponent open={this.state.open} change={this.change} /\u003e\r}\r}\r}\rclass ToggleButton extends Component{//不带有自身的状态能够实现组件的复用\r constructor(props){\rsuper(props)\r}\rrender(){\rlet {open,change}=this.props; // 来自 high 的数据\r return \u003cFragment\u003e\r\u003cbutton type=\"primary\" onClick={change}\u003e\rtoggle Modal\r\u003c/button\u003e\r\u003cdiv\u003e{open}\u003c/div\u003e //拿到open值\r \u003c/Fragment\u003e\r}\r}\r// high 是一个高阶组件，传入组件作为参数，组件就能接收 high 的数据\rexport default high(ToggleButton)；\r 每个经过高阶组件处理过的组件都会复用高阶组件里边的所有逻辑，原则上高阶组件是一个纯函数，不会修改传入的组件，只是返回包装好的新组件。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hook/:1:2","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hook/"},{"categories":["coding"],"content":"函数组件的状态共享 Hooks 可以让你在函数组件中使用状态(state)以及其他的 React 特性。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hook/:2:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hook/"},{"categories":["coding"],"content":"自定义 hook Hook 是 React 中的一类特殊的 JavaScript 函数。自定义名为 useFriendStatus 的 hook，它通过调用 useState 和 useEffect 来订阅一个好友的在线状态。 import React, { useState, useEffect } from 'react';\rfunction useFriendStatus(friendID) {\rconst [isOnline, setIsOnline] = useState(null);\rfunction handleStatusChange(status) {\rsetIsOnline(status.isOnline);\r}\ruseEffect(() =\u003e {\rChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\rreturn () =\u003e {\rChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\r};\r});\rreturn isOnline;\r}\r 自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。 现在我们可以在下面两个组件中使用它： function FriendStatus(props) {\rconst isOnline = useFriendStatus(props.friend.id);\rif (isOnline === null) {\rreturn 'Loading...';\r}\rreturn isOnline ? 'Online' : 'Offline';\r}\r function FriendListItem(props) {\rconst isOnline = useFriendStatus(props.friend.id);\rreturn (\r\u003cli style={{ color: isOnline ? 'green' : 'black' }}\u003e\r{props.friend.name}\r\u003c/li\u003e\r);\r}\r 这两个组件的 state 是完全独立的，Hook 是一种复用状态逻辑的方式，它不复用 state 本身。传入不同的 props，得到的 state 也不同。同样是实现了 UI 与状态分离，便于逻辑的复用。 但是使用 Hook 会有几个额外的规则： 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用 不要在普通 Javascript 函数中调用 在 React 的函数组件调用 Hook 在自定义的 Hook 中调用 Hook 自定义的 hook 必须以 “use” 开头 ","date":"2020-05-07","objectID":"/2020-05-07-react-hook/:2:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hook/"},{"categories":["coding"],"content":"状态管理 实现状态管理的前提是能够状态共享，这就是为什么前面会先说状态共享。不同类型的组件实现状态共享的方法不同，状态管理的方案也不同。下面是一个计数器的状态管理的不同实现方案。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hook/:3:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hook/"},{"categories":["coding"],"content":"class 组件的状态管理 class 组件的状态管理，通常方案是使用第三方库 Redux，结合 React-Redux 使用： $ npm i redux react-redux -S\r Redux 流程图 \r当 UI 的 state 变化时，组件 dispatch 发送 action 信号, reducer 接收来自 action 的信号更新 state, 然后 store 将新的 state 传递给组件，重新渲染 UI。 先创建 store，接收 reducer 为参数: import { createStore } from 'redux'\rimport reducer from './reducer'\r//创建store\rconst store = createStore(reducer)\rexport default store;\r 再写 action，写 action 之前先了解一下 connect 函数 // React Redux 的 `connect` 函数\rconst connect(mapStateToProps, mapDispatchToProps)(Component);\r 可能看起来有些怪, 这样写你就明白了： //先传递两个参数将 connect 封装成高阶函数\rconst higherOrderComponent = connect(mapStateToProps, mapDispatchToProps);\r//再得到新包装的组件 EnhancedComponent\rconst EnhancedComponent = higherOrderComponent(Component);\r action 就是 dispatch 中的参数。 // connect.js\rimport { connect } from 'react-redux'\rconst mapStateToProps = (state) =\u003e {\rreturn { count: state.count, message: state.message }\r}\rconst mapDispatchToProps = (dispatch) =\u003e {\rreturn {\rincrement: (data) =\u003e { dispatch({ type: \"INCREMENT\", num: data, message: \"Incremented\" }) },\rdecrement: (data) =\u003e { dispatch({ type: \"DECREMENT\", num: data, message: \"Decremented\" }) },\rreset: () =\u003e { dispatch({ type: \"RESET\", message: \"Reset\" }) }\r}\r}\r//封装了一个高阶组件，注意高阶组件是函数\rexport default connect(mapStateToProps, mapDispatchToProps)\r 最后写 reducer，接收 action 更新 state: const initialState = { count: 0, message: \"\" }\rconst reducer = (state = initialState, action) =\u003e {\rswitch (action.type) {\rcase \"INCREMENT\":\rreturn {\rcount: state.count + action.num,\rmessage: action.message\r}\rcase \"DECREMENT\":\rreturn {\rcount: state.count - action.num,\rmessage: action.message\r}\rcase \"RESET\":\rreturn {\rcount: 0,\rmessage: action.message\r}\rdefault:\rreturn state;\r}\r}\rexport default reducer;\r 创建一个组件测试计数器: import React, { Component } from 'react'\rimport connect from './connect'\rclass Count extends Component {\rrender() {\rlet { count, message, increment, decrement, reset } = this.props; //来自 connect\r\rreturn (\r\u003cdiv\u003e\r{count}\r\u003cbutton onClick={() =\u003e increment(1)}\u003e+1\u003c/button\u003e\r\u003cbutton onClick={() =\u003e decrement(3)}\u003e-3\u003c/button\u003e\r\u003cbutton onClick={() =\u003e reset()}\u003ereset\u003c/button\u003e\r{message}\r\u003c/div\u003e\r)\r}\r}\r// 导入的 './connect' 是高阶组件，传入 Count 组件, Count就能接收 store 中的数据\rexport default connect(Count)\r 根组件注册 store，并导入 count 组件： import React from 'react'\rimport ReactDOM from 'react-dom';\rimport { Provider } from 'react-redux'\rimport store from './store'\rimport Count from './count'\rfunction App() {\rreturn (\r\u003cProvider store={store}\u003e\r\u003cCount /\u003e\r\u003c/Provider\u003e\r);\r}\rconst rootElement = document.getElementById(\"root\");\rReactDOM.render(\u003cApp /\u003e, rootElement)\r 此时启动项目你发现已经能够计数了，但是我们并没有直接操作 store 啊，其实是 connect 帮我们做了这件事，可以看一下精简版的 connect 源码： import React, { Component } from 'react';\rimport PropTypes from 'prop-types';\rconst connect = (mapStateToProps, mapDispatchToProps) =\u003e (WrappedComponent) =\u003e {\rclass Connect extends Component {\rstatic contextTypes = {\rstore: PropTypes.object,\r};\rconstructor() {\rsuper();\rthis.state = { allProps: {} }\r}\rcomponentWillMount() {\rconst { store } = this.context;\rthis._updateProps();\rstore.subscribe(this._updateProps);\r}\r_updateProps = () =\u003e {\rconst { store } = this.context;\rlet stateProps = mapStateToProps(store.getState());\rlet dispatchProps = mapDispatchToProps(store.dispatch);\rthis.setState({\rallProps: {\r...stateProps,\r...dispatchProps,\r...this.props,\r}\r});\r};\rrender () {\rreturn \u003cWrappedComponent {...this.state.allProps} /\u003e\r}\r}\rreturn Connect;\r};\rexport default connect;\r 你会发现 store 实际上是通过 Context 创建的，Context 是 React 中的 API 方法: Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。 有了状态共享方法(高阶组件)和数据传递的方法(Context), 就能让在整个组件树中的各个组件都很方便的读取状态修改状态, 就实现了 React-Redux，下面我会用 hooks 实现类似的全局状态管理。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hook/:3:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hook/"},{"categories":["coding"],"content":"函数组件的状态管理 实际上 React 已经为我们实现了相应的 hooks, 我们需要做的只是将这些 hooks 灵活的组合在一起。就能够实现状态管理了，还是以实现计数器的为例。 实现一个 React-redux 中的 store 只需以下代码： //store.js\rimport React, { createContext, useContext, useReducer } from 'react';\rimport reducer from './reducer';\rconst StoreContext = createContext();\rconst initialState = { count: 0, message: \"\" };\rexport const StoreProvider = ({ children }) =\u003e {\rconst [state, dispatch] = useReducer(reducer, initialState);\rreturn (\r\u003cStoreContext.Provider value={{ state, dispatch }}\u003e\r{children}\r\u003c/StoreContext.Provider\u003e\r )\r}\rexport const useStore = () =\u003e useContext(StoreContext);\r useReducer 是 useState 的替代方案。它接收一个形如 (state, action) =\u003e newState 的 reducer，以及初始状态 initialState，返回值是当前的 state 以及与其配套的 dispatch 方法。 useContext 的参数必须是 context 对象，让你能够读取 context 的值以及订阅 context 的变化。调用了 useContext 的组件会在 context 值变化时重新渲染。你仍然需要在上层组件树中使用 \u003cMyContext.Provider\u003e 来为下层组件提供 context。 OK, 我们的简版 React-redux 就做好了。 写 action, 我们的状态数据从 useCounter 里获取: //storeApi.js\rimport { useStore } from \"./store\";\rexport const useCounter = () =\u003e {\rconst { state, dispatch } = useStore();\rreturn {\rcount: state.count,\rmessage: state.message,\rincrement: (data) =\u003e dispatch({ type: \"INCREMENT\", num: data, message: \"Incremented\" }),\rdecrement: (data) =\u003e dispatch({ type: \"DECREMENT\", num: data, message: \"Decremented\" }),\rreset: () =\u003e dispatch({ type: \"RESET\", message: \"Reset\" })\r}\r}\r 写reducer, 去掉 initialState, 我们已经写在了 useReducer 里, 原因是： 注意 React 不使用 state = initialState 这一由 Redux 推广开来的参数约定。有时候初始值依赖于 props，因此需要在调用 Hook 时指定。 // reducer.js\rconst reducer = (state, action) =\u003e {\rswitch (action.type) {\rcase \"INCREMENT\":\rreturn {\rcount: state.count + action.num,\rmessage: action.message\r}\rcase \"DECREMENT\":\rreturn {\rcount: state.count - action.num,\rmessage: action.message\r}\rcase \"RESET\":\rreturn {\rcount: 0,\rmessage: action.message\r}\rdefault:\rreturn state;\r}\r}\rexport default reducer;\r 写个组件，测试一下: //Count.js\rimport React from \"react\";\rimport { useCounter } from \"./storeApi\";\rexport const Count = () =\u003e {\rconst { count, message, increment, decrement, reset } = useCounter();\rreturn (\r\u003cdiv\u003e\r{count}\r\u003cbutton onClick={() =\u003e increment(1)}\u003e+1\u003c/button\u003e\r\u003cbutton onClick={() =\u003e decrement(3)}\u003e-3\u003c/button\u003e\r\u003cbutton onClick={() =\u003e reset()}\u003e Reset\u003c/button\u003e\r{message}\r\u003c/div\u003e\r)\r}\r 修改根组件如下： import React from \"react\";\rimport ReactDOM from \"react-dom\";\rimport { StoreProvider } from \"./store\";\rimport { Count } from \"./Count\";\rfunction App() {\rreturn (\r\u003cStoreProvider\u003e\r\u003cCount /\u003e\r\u003c/StoreProvider\u003e\r);\r}\rconst rootElement = document.getElementById(\"root\");\rReactDOM.render(\u003cApp /\u003e, rootElement);\r 启动服务，发现能够计数成功，我们的状态管理方案成功了。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hook/:3:2","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hook/"},{"categories":["coding"],"content":"本次实践我将使用 Angular 和 Nest.js 写一个带有状态管理，登录验证的全栈 todolist 应用。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:0:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["coding"],"content":"后端开发 后端开发使用 Nest.js 框架，本次实践是重前端的，因此后端会做得简单一些。后端是在上一次鉴权认证的代码做部分修改。如果有不懂的代码，可以参考之前的文章。此部分的讲解略过。这是后端部分生成的 swagger 接口文档: \r","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:1:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["coding"],"content":"前端开发 前端使用 Angular 框架。为什么使用 Angular? 以下几点是我选择它的原因： 1.它是前端真正意义上的框架。 2.它的一些理念是相当超前。 3.Nest.js 和 Angular 非常像。 4.前后端开发同构语言。 不过它的缺点也很显著，或者说是我的缺点： 1.学习到会用有较长的时间周期。 2.HMR(hot module replacement) 体验太差。 3.报错信息简直了。 尽管在国内太冷门，不过我仍然看好 Angular 的发展。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["coding"],"content":"组件开发 导入 UI 组件库 在样式开发方面，我们使用 angular 官方提供的 Material UI。用一个 MaterialModule，导出我们需要用到的所有样式组件。 @NgModule({\rexports: [\rMatButtonModule,\rMatCardModule,\rMatDialogModule,\rMatIconModule,\rMatInputModule,\rMatListModule,\rMatToolbarModule,\rMatMenuModule,\r],\r})\rexport class MaterialModule { }\r 这样在我们需要用到样式组件时，直接导入 MaterialModule 就好。 顶部导航 在 AppModule 中导入 MaterialModule， 然后在 app.component.html 中写入顶部 header 导航组件。 \u003cheader\u003e\r\u003cmat-toolbar color=\"primary\" class=\"expanded-toolbar\"\u003e\r\u003cdiv\u003e\r\u003cspan\u003e{{title}}\u003c/span\u003e\r\u003cbutton mat-button routerLink=\"/todos\"\u003e\r\u003cmat-icon\u003eview_lists\u003c/mat-icon\u003e\rTodo\r\u003c/button\u003e\r\u003c/div\u003e\r\u003cdiv\u003e\r\u003cbutton mat-button routerLink=\"/login\" *ngIf=\"authService.token.length == 0\"\u003e\r\u003cmat-icon\u003eaccount_box\u003c/mat-icon\u003e\rLogin\r\u003c/button\u003e\r\u003cbutton mat-button routerLink=\"/login\" *ngIf=\"authService.token.length \u003e 0\" (click)=\"logout()\"\u003e\r\u003cmat-icon\u003eexit_to_app\u003c/mat-icon\u003e\rLogout\r\u003c/button\u003e\r\u003c/div\u003e\r\u003c/mat-toolbar\u003e\r\u003c/header\u003e\r\u003cmain\u003e\r\u003crouter-outlet\u003e\u003c/router-outlet\u003e\r\u003c/main\u003e\r\u003c!-- \u003cfooter\u003e\u003c/footer\u003e --\u003e\r 顶部导航写在 header 标签中，router-outlet 是路由插座，当路由跳转时，我们导入的组件会替换掉 router-outlet 标签。登录成功后显示 Logout button，未登录或登出用户后显示 Login button。在 css 中做些样式调整，接下来是路由注册模块。新建一个 app-routing.module.ts 组件： import { NgModule } from '@angular/core';\rimport { Routes, RouterModule } from '@angular/router';\rconst routes: Routes = [\r{\rpath: 'login',\rloadChildren: () =\u003e import('./features/auth/auth.module').then((m) =\u003e m.AuthModule),\r},\r{\rpath: 'todos',\rloadChildren: () =\u003e import('./features/todo/todo.module').then((m) =\u003e m.TodoModule),\r},\r];\r@NgModule({\rimports: [RouterModule.forRoot(routes)],\rexports: [RouterModule],\r})\rexport class AppRoutingModule { }\r 我们注册了路由，因为我们会在导入的模块中进行状态管理，因此这里会用 Angular 中的 Lazy-loading 方式导入模块。这样，当路由匹配 login 时 auth.module.ts 中的 component 成为 main，当路由匹配 todos 时 todo.module.ts 中的 component 成为 main。 登录表单 在 auth.module.ts 只用一个登录组件，导入一些我们需要用到的表单模块。 @NgModule({\rimports: [\rCommonModule,\rFormsModule,\rReactiveFormsModule,\rMaterialModule,\rAuthRoutingModule,\r],\rdeclarations: [\rLoginComponent\r],\r})\rexport class AuthModule { }\r 先创建出 login 组件，可以用 cli 的方式生成：$ nest g component login，也可以手动新建文件：login.component.html，“error$ | async” 是因为我们传递的是 obeservable 对象，我们先不说 login.component.ts, 这一部分在后面的状态管理中再说。 \u003cmat-card\u003e\r\u003cmat-card-content\u003e\r\u003cform [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\"\u003e\r\u003ch2\u003eLogin\u003c/h2\u003e\r\u003cmat-error *ngIf=\"error$ | async\"\u003e\rThe username and password were not recognised\r\u003c/mat-error\u003e\r\u003cmat-form-field class=\"full-width-input\"\u003e\r\u003cinput matInput placeholder=\"Username\" formControlName=\"username\" required\u003e\r\u003cmat-error\u003e\rPlease provide a valid email address\r\u003c/mat-error\u003e\r\u003c/mat-form-field\u003e\r\u003cmat-form-field class=\"full-width-input\"\u003e\r\u003cinput matInput type=\"password\" placeholder=\"Password\" formControlName=\"password\" required\u003e\r\u003cmat-error\u003e\rPlease provide a valid password\r\u003c/mat-error\u003e\r\u003c/mat-form-field\u003e\r\u003cbutton mat-raised-button color=\"primary\"\u003eLogin\u003c/button\u003e\r\u003c/form\u003e\r\u003c/mat-card-content\u003e\r\u003c/mat-card\u003e\r 然后注册路由 auth-routing.module.ts： import { NgModule } from '@angular/core';\rimport { Routes, RouterModule } from '@angular/router';\rimport { LoginComponent } from './login/login.component';\rconst routes: Routes = [\r{\rpath: '',\rcomponent: LoginComponent,\r},\r];\r@NgModule({\rimports: [RouterModule.forChild(routes)],\rexports: [RouterModule],\r})\rexport class AuthRoutingModule { }\r todolist列表 创建 todo.component.html, 捕获 todolist 对应的增删改查事件： \u003cmat-card\u003e\r\u003cng-container *ngIf=\"vm$ | async as vm\"\u003e\r\u003ch2\u003eTodo Lists\u003c/h2\u003e\r\u003cmat-action-list role=\"list\"\u003e\r\u003capp-todo-list-item *ngFor=\"let todo of vm.todos\" [todo]=\"todo\" [loading]=\"vm.loading\"\r(update)=\"showEditDialog($event)\" (remove)=\"showRemoveDialog($event)\"\u003e\u003c/app-todo-list-item\u003e\r\u003c/mat-action-list\u003e\r\u003c/ng-container\u003e\r\u003c/mat-card\u003e\r\u003cdiv class=\"fab-bottom-right\"\u003e\r\u003cbutton mat-fab color=\"accent\" aria-label=\"Add\" (click)=\"showCreateDialog()\"\u003e\r\u003cmat-icon\u003eadd\u003c/mat-icon\u003e\r\u003c/button\u003e\r\u003c/div\u003e\r todo 单项 todolist 模板中的 remove, update 不是 js 原生事件, 我们需要注册对应的 EventEmitter，它是自定义事件触发与事件监听器功能的封装。todolist 列表是父组件，todo 单项是子组件。父子组件通讯需要用到 @Input() 和 @Output() 装饰器， @Input() 是父传子，@Output() 是子传父。todo-list-item.ts: @Component({\rselector: 'ap","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:1","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["coding"],"content":"登录验证 新建一个 services 文件夹，在其中新建 auth.service.ts 文件： @Injectable({\rprovidedIn: 'root'\r})\rexport class AuthService {\rprivate api: string = environment.apiUrl + '/auth';\rconstructor(private http: HttpClient, private router: Router, private store: Store) { }\rlogin(user: Partial\u003cUser\u003e) {\rreturn this.http.post\u003cUser\u003e(`${this.api}/signIn`, user).pipe(\rmergeMap((user: User) =\u003e {\rthis.token = user.access_token || '';\rthis.router.navigate(['todos']);\rreturn of(user);\r})\r);\r}\rget token() {\rreturn localStorage.getItem('access_token') || '';\r}\rset token(val: string) {\rif (val.length \u003e 0) {\rlocalStorage.setItem('access_token', val);\r}\r}\rlogout() {\rthis.store.dispatch(UserActions.logout());\rlocalStorage.clear();\r}\r}\r 为 token 创建一个setter, getter 方法，登录成功后，为 token 赋值，登出后，将 token 置空。providedIn: ‘root’ 表示我们的 service 是根级作用域。客服端判断用户是否登录成功的方法就是判断我们的 token 是否为空。而服务端将 token 作为验证用户的凭据。用户登录成功后，每次需要用户验证的请求都要求验证 token。我们可以使用拦截器(Interceptor) 对网络请求重新封装。 @Injectable()\rexport class AuthInterceptor implements HttpInterceptor {\rconstructor(public authService: AuthService) { }\rintercept(req: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e {\rconst authToken = this.authService.token;\rconst authReq = req.clone({\rheaders: req.headers.set(\"Authorization\", \"Bearer \" + authToken),\r});\rreturn next.handle(authReq);\r}\r}\r 当我们设置拦截器后，我们需要注册在根模块 app.module.ts 中。 providers: [\r{\rprovide: HTTP_INTERCEPTORS,\ruseClass: AuthInterceptor,\rmulti: true\r}\r],\r 添加了全局拦截器后我们就不必在每个请求接口都手动添加 header 的 bear 参数了。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:2","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["coding"],"content":"状态管理 状态管理是为了组件之间的数据共享。组件数据发生变化后，不通过不同组件传值这样的方式，而通过一个叫 store 的东西统一管理状态数据，监听状态数据变化。 打印日志 新建一个store文件夹，里面新建 app.state.ts 文件，将路由变化 router 加入到 AppState 中。 import { RouterReducerState } from '@ngrx/router-store';\rexport interface AppState {\rrouter: RouterReducerState;\r}\r 创建一个 reducers 文件夹, 里面新建 logger.reducer.ts: import { ActionReducer } from '@ngrx/store';\rimport { AppState } from '../app.state';\rexport function logger(reducer: ActionReducer\u003cAppState\u003e): ActionReducer\u003cAppState\u003e {\rreturn (state, action) =\u003e {\rconst result = reducer(state, action);\rconsole.groupCollapsed(action.type);\rconsole.log('prev state', state);\rconsole.log('action', action);\rconsole.log('next state', result);\rconsole.groupEnd();\rreturn result;\r};\r}\r 这是参考了 NgRx 在 github 上的官方示例 的做法，实现一个控制台的日志打印，当然我们也可以在浏览器安装 redux 扩展程序。新建 index.ts，开发环境下就有日志打印: import { ActionReducerMap, MetaReducer } from '@ngrx/store';\rimport * as fromRouter from '@ngrx/router-store';\rimport { environment } from '../../../environments/environment';\rimport { logger } from './logger.reducer';\rimport { AppState } from '../app.state';\rexport const reducers: ActionReducerMap\u003cAppState\u003e = {\rrouter: fromRouter.routerReducer,\r};\rexport const metaReducers: MetaReducer\u003cAppState\u003e[] = !environment.production ? [logger] : [];\r 理解状态管理 写本篇文章的目的之一是将状态管理实践验证。之前我有说前端的状态管理相当于后端的数据库。接下来我将一步一步的验证这个说法。下面以用户状态来讲解。 定义初始状态类似于数据库的创建，action 是 store 数据的来源入口，从NgRx官网示意图中我们可以看到它可以来自用户操作(component)，也可以来自网络请求(effects)，reducer 类似于数据表，那 adapter, selector, effects 又分别是什么呢？ \r按照 Redux 的约定，reducer 必须是纯函数，只接收旧状态，只返回新状态。我们操作数据表时，实际上是对数据表中的列做操作，而 adapter 就是 reducer 中的列，对数据的增删改查就是对 adapter 的增删改查。selector 类似于 sql 中的 select 语句。而 effects 负责传递数据，和一些 DOM 操作，使用 NgRx 这套流程时，在 component 中需要做的唯一事情就是 dispatch action, 额外的事情就交给 effects 来做。 下面给出代码实例，可以结合代码来理解这段话。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:3","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["coding"],"content":"代码实例 初始化 reducer 表 初始状态(initialState)是定义在 reducer 中的，user.state.ts: import { EntityState, createEntityAdapter } from '@ngrx/entity';\rimport { User } from 'src/app/models/user.model';\rexport const featureName = 'user';\rexport interface State extends EntityState\u003cUser\u003e {\rneedAuth: boolean;\rselectedId?: string;\rerror?: any;\r}\rexport const adapter = createEntityAdapter\u003cUser\u003e();\rexport const initialState: State = adapter.getInitialState({\rneedAuth: false,\r});\r 注册 reducer 表 featureName 是我们的 reducer 表名，根模块注册时，StoreModule.forRoot(featureName, reducer)。 其他模块注册时，StoreModule.forFeature(featureName, reducer), 当在其他模块注册时，仍然需要在根模块配置 StoreModule.forRoot({})。在局部注册是一种减轻服务器压力的方式。 action 数据来源 定义 Action 作为 store 数据来源，props 接收数据参数。 import { createAction, props } from '@ngrx/store';\rimport { User } from 'src/app/models/user.model';\rexport const login = createAction(\r'[Auth Page] User Login',\rprops\u003c{ user: Partial\u003cUser\u003e }\u003e()\r);\rexport const loginSuccess = createAction(\r'[Auth Page] Login Success',\rprops\u003c{ user: User }\u003e()\r);\rexport const loginFailure = createAction(\r'[Auth Page] Login Failure',\rprops\u003c{ error: any }\u003e()\r);\rexport const logout = createAction('[Auth Page] User Logut');\r effects 钩子函数 effects 钩取相应 action(login) 后，发送网络请求，并触发新的 action(loginSuccess 或者 loginFailure)。effects 与 action 数据交互方式是双向的。 @Injectable()\rexport class UserEffects {\rconstructor(\rprivate actions$: Actions,\rprivate authService: AuthService\r) { }\rlogin$ = createEffect(() =\u003e\rthis.actions$.pipe(\rofType(UserActions.login),\rconcatMap(({ user }) =\u003e\rthis.authService.login(user).pipe(\rmap((result) =\u003e UserActions.loginSuccess({ user: result })),\rcatchError((error) =\u003e of(UserActions.loginFailure({ error })))\r)\r)\r),\r);\r}\r adapter 数据表列 action 传递数据给 reducer 表, reducer 表在 loginSuccess 时就新增一列数据。 export const reducer = createReducer(\rinitialState,\ron(UserActions.login, (state) =\u003e {\rreturn { ...state, needAuth: true };\r}),\ron(UserActions.loginSuccess, (state, { user }) =\u003e {\rreturn adapter.addOne(user, { ...state, needAuth: false });\r}),\ron(UserActions.loginFailure, (state, { error }) =\u003e {\rreturn { ...state, needAuth: true, error };\r}),\ron(UserActions.logout, (state) =\u003e {\rreturn { ...state, needAuth: true };\r}),\r);\r selector 状态切片 我们要将新的状态作用到 component 上，这个时候就需要 selector 在 reducer 中查询，创建 user.selector.ts: const getUserState = createFeatureSelector\u003cState\u003e(featureName);\rconst { selectEntities } = adapter.getSelectors();\rexport const getLogin = createSelector(\rgetUserState,\r(state) =\u003e state.needAuth\r);\rexport const getError = createSelector(getUserState, (state) =\u003e state.error);\rexport const getSelectedId = createSelector(\rgetUserState,\r(state) =\u003e state.selectedId\r);\rexport const getUserEntities = createSelector(getUserState, selectEntities);\rexport const getUser = createSelector(\rgetSelectedId,\rgetUserEntities,\r(id, entities) =\u003e (id ? entities[id] : undefined)\r);\r 在 login.component.ts 中得到新的状态： error$ = this.store.pipe(select(UserSelectors.getError));\rneedAuth$ = this.store.pipe(select(UserSelectors.getLogin));\r 变量中的 $ 表示得到的数据是 Observable 对象。我们可以直接将 Observable 渲染在html 中： \u003cmat-error *ngIf=\"error$ | async\"\u003e\rThe username and password were not recognised\r\u003c/mat-error\u003e\r 也可以取订阅后的布尔值 error$.subscribe(data =\u003e data)。 在 component 中填写完登录表单后, 只需 dispatch action: this.store.dispatch(UserActions.login({ user }));\r 状态数据就在 component, store 之间来回传递。最后的程序如图： \r","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:4","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["coding"],"content":"思考 看到这里，你会发现，我们绕了一圈做了一件简单的事。但你可以想象，前端框架的组件化开发方式，组件之间的通信基本都是单向数据流，要是没有状态管理，父子组件还好，相隔很远的组件，只能通过一级一级向上传，再一级一级向下传，会更加麻烦。 对于 angular, 简单的数据状态，我们可以直接定义在 service 中，通过 DI(依赖注入) 的方式能够很方便地作用到不同的 component 中。这是 angular 比其他前端框架优秀的地方之一。 附：源码地址 参考资料 NgRx 官方文档 Angular 真的需要状态管理么？ ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:5","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["coding"],"content":"本文主要讲述如何用 typeorm 建表，建立一对一，一对多，多对多的关系，建立表的外连接。 以及在 typeorm 做查询操作的两种常用方式：Find 选项 和 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:0:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["coding"],"content":"建表 typeorm 建表时，将 @Entity() 装饰的 class 映射为数据表，entity 中 @PrimaryColumn() 装饰的属性作为表的主键, @PrimaryGeneratedColumn() 表示自动生成主键, @Column() 装饰属性作为表的属性。 @Entity()\rexport class Photo {\r@PrimaryGeneratedColumn()\rid: number;\r@Column({length: 100})\rname: string;\r@Column(\"text\")\rdescription: string;\r@Column()\rviews: number;\r@Column()\risPublished: boolean;\r}\r 数据库中的列类型是根据你使用的属性类型推断的，例如: number 将被转换为 integer，string 将转换为 varchar，boolean 转换为 bool 等。下面我们从实际的例子出发探索如何用 typeorm 建一对一、一对多、多对多的关系。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:1:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["coding"],"content":"一对一 用户 user 和用户档案 profile 是一对一关系，一个用户只有一份档案。 @Entity('users')\rexport class UserEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rusername: string;\r@OneToOne(type =\u003e ProfileEntity, profile =\u003e profile.user)\r@JoinColumn()\rprofile: ProfileEntity;\r}\r 注意 profile 是 ProfileEntity 类型的，在数据库中存储的类型却是 profile.id 的类型。 @OneToOne 中需要指明对方 entity 的类型，指明对方 entity 的外键。@JoinColumn 必须在且只在关系的一侧的外键上。 @Entity('profiles')\rexport class ProfileEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rgender: string;\r@Column()\rphoto: string;\r@OneToOne(type =\u003e UserEntity, user =\u003e user.profile)\ruser: UserEntity;\r}\r 这将生成以下数据表： +-------------+--------------+----------------------------+\r| users |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| username | varchar(255) | |\r| profileId | int(11) | FOREIGN KEY |\r+-------------+--------------+----------------------------+\r+-------------+--------------+----------------------------+\r| profiles |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| gender | varchar(255) | |\r| photo | varchar(255) | |\r+-------------+--------------+----------------------------+\r ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:2:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["coding"],"content":"一对多 用户 user 与用户发布的文章 article 是一对多关系，一个用户可发布多篇文章。 @Entity('users')\rexport class UserEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rusername: string;\r@OneToMany(type =\u003e ArticleEntity, article =\u003e article.author)\rarticles: ArticleEntity[];\r}\r @OneToMany，@ManyToOne 中需要指明对方的 entity 类型，指明对方 entity 的外键。 @Entity('articles')\rexport class ArticleEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rtitle: string;\r@ManyToOne(type =\u003e UserEntity, user =\u003e user.articles)\rauthor: UserEntity;\r}\r typeorm 在处理 “一对多”关系时将“一”的主键作为“多”的外键 (即 @ManyToOne 装饰的属性)，建表时有最少的数据表操作代价，避免数据冗余，提高效率。这会生成以下表： +-------------+--------------+----------------------------+\r| articles |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| title | varchar(255) | |\r| authorId | int(11) | |\r+-------------+--------------+----------------------------+\r+-------------+--------------+----------------------------+\r| users |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| username | varchar(255) | |\r+-------------+--------------+----------------------------+\r ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:3:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["coding"],"content":"多对多 用户 user 对文章 article 的喜欢 favorite 是多对多关系。一个用户可对多篇文章标记喜欢，一篇文章可被多个用户标记喜欢。 @Entity('users')\rexport class UserEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rusername: string;\r@ManyToMany(type =\u003e ArticleEntity, article =\u003e article.favoritedBy)\rfavorites: ArticleEntity[];\r}\r @OneToMany 中需要指明对方的 entity 类型，指明对方 entity 的外键。@JoinTable 必须在且只在关系的一侧的外键上。 @Entity('articles')\rexport class ArticleEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rtitle: string;\r@ManyToMany(type =\u003e UserEntity, user =\u003e user.favorites)\r@JoinTable()\rfavoritedBy: UserEntity[];\r}\r typeorm 的处理方式是将多对多关系转化为两个一对多关系: 用户 user 与 喜欢 favorites 一对多。 文章 article 与被喜欢 favoritedBy 一对多。 多对多关系需要采用中间表的方式处理，这是为了避免笛卡尔积的出现。这会生成以下表： +-------------+--------------+----------------------------+\r| users |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| username | varchar(255) | |\r+-------------+--------------+----------------------------+\r+-------------+--------------+----------------------------+\r| articles |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| title | varchar(255) | |\r+-------------+--------------+----------------------------+\r+-------------+--------------+----------------------------+\r| articles_favorited_by_users |\r+-------------+--------------+----------------------------+\r| articlesId | int(11) | PRIMARY KEY FOREIGN KEY |\r| usersId | int(11) | PRIMARY KEY FOREIGN KEY |\r+-------------+--------------+----------------------------+\r ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:4:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["coding"],"content":"增删改查 创建好一对一，一对多，多对多的实体 entity 后，我们如何做增删改查呢？单个实体的 crud 可参考我的这一篇文章。而关联后的实体对象会作为该实体对象的一个属性, 直接对属性进行操作即可。如下是文章被用户喜欢的实现: async favoriteArticle(slug: string, user: UserEntity) {\rconst article = await this.articleRepo.findOne({ where: { slug }});\rarticle.favoritedBy.push(user);\rawait article.save();\rreturn article;\r}\r crud 操作中查询操作是我们最常遇到的，下面讲如何查询，typeorm 支持两种查询方式：Find 选项 和 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["coding"],"content":"Find 选项 在 Nest.JS 中，对具体实体的管理（insert, update, delete, load 等)我们使用的是 Repository。对应的查找方法是：Repository.find(FindOptions)。 使用 find 查询只能获得一种类型的结果：entities。 find 选项的完整例子如下： userRepository.find({\rselect: [\"username\"],\rrelations: [\"profile\", \"article\"，\"article.favoritedBy\"],\rwhere: {\rusername: \"Timber\",\r},\rorder: {\rid: \"DESC\"\r},\rskip: 5,\rtake: 10,\rcache: true\r});\r 直接使用 find 是不会查出关联的对象的，要查询的关联对象需要添加到 relations 数组中。 除了 relations 以外，其他选项等同于原生 sql 操作, order 等同于 order by, skip 等同于 offset, take 等同于 limit, cache 是查询缓存。细节请参考 Find 选项。 这种查询有个局限就是只能查询到关联对象的整个实体或主键。而不能 select 关联实体的其他属性。因此更复杂的查询我们需要使用 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:1","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["coding"],"content":"QueryBuilder 使用QueryBuilder 查询可以获得两种类型的结果：entities 或原始数据。 要获取entities，请使用getOne和getMany。 要获取原始数据，请使用getRawOne和getRawMany。 它能够很方便的帮我们构造出 sql 语句，addSelect() 可以获取关联对象上的其他属性。 if (query.author) {\rconst article = await getRepository(ArticleEntity)\r.createQueryBuilder('article')\r.select(\"article.id\", 'id')\r.addSelect('favoritedBy.username', 'name')\r.leftJoin('article.favoritedBy', 'favoritedBy')\r.where(\"favoritedBy.username = :name\", { name: query.author })\r.getRawMany();\r}\r 获取生成的 sql 语句可以在 getRawMany() 前获取 getSql() 或打印 printSql() 生成的sql语句。细节请参考 Query Builder。 参考资料 Typeorm 官方文档 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:2","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["coding"],"content":"鉴权(authentication)是指验证用户是否拥有访问系统的权利。传统的鉴权是通过密码来验证的。这种方式的前提是，每个获得密码的用户都已经被授权。 ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:0:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["coding"],"content":"建立用户表，密码散列 要实现鉴权认证，首先需要一张 user 表。上一次我们用 NestJS 和 Typeorm 做了最基本的 crud 操作, 这次我们用 NestJS 和 node 中最流行的身份验证库 Passport 来完成鉴权认证。为了方便，我们直接沿用上次的代码库。 创建 user module: $ nest g mo user 然后在 user 文件夹新建 user.entity.ts, 其中我们做了密码散列: import { BeforeInsert, Column, Entity, PrimaryGeneratedColumn } from 'typeorm'\rimport * as bcrypt from 'bcryptjs';\r@Entity('user')\rexport class UserEntity {\r@PrimaryGeneratedColumn()\rid: number\r@Column({ length: 20 })\rusername: string\r@Column({ length: 255 })\rpassword: string\r@BeforeInsert()\rasync hashPassword() {\rthis.password = await bcrypt.hash(this.password, 10);\r}\r}\r 在 user.module.ts 中注册 user 表：TypeOrmModule.forFeature([UserEntity]) 上一次我们直接在 module 中写了数据库连接配置，其实更常见的做法是写一个数据库配置文件。可以用环境变量设置数据库连接，这是 typeorm 数据库连接配置的参考地址。在文件夹建立一个 .env 文件： # App\rJWT_SECRET = 'ThisIsASecretKey'\r# Database\rTYPEORM_CONNECTION = mysql\rTYPEORM_HOST = localhost\rTYPEORM_USERNAME = root\rTYPEORM_PASSWORD = 123456\rTYPEORM_DATABASE = test\rTYPEORM_PORT = 3306\rTYPEORM_SYNCHRONIZE = true\rTYPEORM_LOGGING = true\rTYPEORM_ENTITIES = dist/**/*.entity.js\r 其中写了数据库配置和自定义的 jwt 密匙，关于如何生成 jwt 格式的字符串, 可以看这篇文章, 本文只讲如何使用它来做用户登录验证。 在 app.module.ts 的imports数组中修改数据库为注册：TypeOrmModule.forRoot()，然后写入 UserModule。测试一下我们的数据库连接情况：$ npm run start, 控制台打印了 sql 语句，说明我们的连接配置是对的。查看数据库会发现新增加了 user 表。 在 user 文件夹新建 user.dto.ts： import { IsString } from 'class-validator'\rimport { ApiProperty } from '@nestjs/swagger';\rexport class UserDto {\r@ApiProperty()\r@IsString()\rreadonly username: string;\r@ApiProperty()\r@IsString()\rreadonly password: string;\r}\r 然后创建 user service：$ nest g s user，注意在 createUser 方法中一定要先 实例化 user, 再返回创建的对象。否则 user.entity.ts 中的 @BeforeInsert() 装饰的方法不会执行，密码就不会取散列后的值。 import { Injectable } from '@nestjs/common'\rimport { InjectRepository } from '@nestjs/typeorm'\rimport { UserEntity } from './user.entity'\rimport { Repository } from 'typeorm'\rimport { UserDto } from './user.dto'\r@Injectable()\rexport class UserService {\rconstructor(\r@InjectRepository(UserEntity)\rprivate readonly userRepository: Repository\u003cUserEntity\u003e,\r) { }\rasync createUser(userDto: UserDto) {\r// const user = Object.assign(new UserEntity(), userDto)\r const user = this.userRepository.create(userDto);\rreturn await this.userRepository.save(user);\r}\rasync findUsername(username: string) {\rreturn this.userRepository.findOne({ where: { username } })\r}\rasync findAll(): Promise\u003cUserEntity[]\u003e {\rreturn await this.userRepository.find();\r}\r}\r ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:1:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["coding"],"content":"实现本地认证策略 实现本地认证策略需要先安装以下依赖： yarn add @nestjs/passport passport passport-local\ryarn add -D @types/passport-local\r 说明一下，这一步不是必须的。其实本地认证就是做用户名和密码的核对，我们自己去实现也不算麻烦。但是为了和 NestJS 官网教程保持一致，我们也这样做。 创建 auth module: $ nest g mo auth，在 auth 目录下创建一个 local.strategy.ts 文件： import { Injectable, UnauthorizedException } from '@nestjs/common'\rimport { PassportStrategy } from '@nestjs/passport'\rimport { Strategy } from 'passport-local'\rimport { AuthService } from './auth.service'\r@Injectable()\rexport class LocalStrategy extends PassportStrategy(Strategy) {\rconstructor(private readonly authService: AuthService) {\rsuper()\r}\rasync validate(username: string, password: string) {\rconst user = await this.authService.validateUser(username, password)\rif (!user) {\rthrow new UnauthorizedException()\r}\rreturn user\r}\r}\r 使用 @nestjs/passport ，你需要继承 PassportStrategy 类来配置 passport 策略。通过调用子类中的 super() 方法传递策略选项，通过在子类中实现 validate() 方法，可以提供verify回调。Passport 定义的 所有策略 都是将validate() 方法执行的结果作为 user 属性存储在当前 HTTP Request 对象 上,你也可以自定义此属性的名称。上面文件中的 validateUser 方法需要在 auth.service.ts 自己实现，因为框架不清楚你定义的密码散列方式。 //auth.service.ts\r\r...\rasync validateUser(username: string, pass: string): Promise\u003cany\u003e {\rconst user = await this.userService.findUsername(username);\rconsole.log('-----------Login-----------')\rif (user \u0026\u0026 bcrypt.compareSync(pass, user.password)) {\rreturn user;\r}\rreturn null;\r}\r ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:2:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["coding"],"content":"实现注册登录功能 创建 auth controller: $ nest g co auth，路由功能： import { UserDto } from './../user/user.dto';\rimport { Body, Controller, Get, Post, UseGuards, Res, Request } from '@nestjs/common'\rimport { AuthGuard } from '@nestjs/passport'\rimport { ApiTags, ApiBearerAuth } from '@nestjs/swagger'\rimport { AuthService } from 'src/auth/auth.service'\r@ApiBearerAuth()\r@ApiTags('Auth')\r@Controller('auth')\rexport class AuthController {\rconstructor(\rprivate readonly authService: AuthService,\r) { }\r@UseGuards(AuthGuard('jwt'))\r@Get('users')\rasync findAll(@Request() req): Promise\u003cany[]\u003e {\rconsole.log('--------------Auth--Success---------------')\rconsole.log(req.user);\rreturn await this.authService.findAll();\r}\r@Post('signUp')\rasync register(@Body() req: UserDto, @Res() res) {\rconst result = await this.authService.register(req);\rres.status(result.statusCode).send(result);\r}\r@UseGuards(AuthGuard('local'))\r@Post('signIn')\rasync login(@Body() @Request() req: UserDto, @Res() res) {\rconsole.log('----------Login--Success-----------')\rconsole.log(req);\rconst result = await this.authService.login(req);\rres.status(result.statusCode).send(result);\r}\r}\r 注意其中的 @UseGuards(AuthGuard(‘local’)) 装饰器，因为我们写了 local.strategy.ts文件，其中继承了 PassportStrategy 类，并实现了 validate 方法。@nestjs/passport 就会为我们实现一个 AuthGuard，我们直接在需要验证的路由前使用就好。@UseGuards(AuthGuard(‘jwt’)) 是我们接下来要讲的 JWT 认证策略。 再补充完整 auth.service.ts 文件： // auth.service.ts\r\rimport { BadRequestException, Injectable, Body, Request } from '@nestjs/common'\rimport { UserService } from '../user/user.service'\rimport { JwtService } from '@nestjs/jwt'\rimport * as bcrypt from 'bcryptjs';\r@Injectable()\rexport class AuthService {\rconstructor(\rprivate readonly userService: UserService,\rprivate readonly jwtService: JwtService,\r) { }\rasync findAll(): Promise\u003cany[]\u003e {\rreturn await this.userService.findAll();\r}\rasync validateUser(username: string, pass: string): Promise\u003cany\u003e {\rconst user = await this.userService.findUsername(username);\rconsole.log('-----------Login-----------')\rif (user \u0026\u0026 bcrypt.compareSync(pass, user.password)) {\rreturn user;\r}\rreturn null;\r}\rasync register(user: any) {\rlet userData: any;\ruserData = await this.userService.findUsername(user.username);\rif (userData) {\rreturn { statusCode: 400, message: 'This username aleady exists' };\r}\rawait this.userService.createUser(user);\ruserData = await this.userService.findUsername(user.username);\rreturn {\rusername: userData.username,\rstatusCode: 201\r};\r}\rasync login(user: any) {\rreturn this.userService.findUsername(user.username).then((userData) =\u003e {\rconst Token = this.createToken(userData);\rreturn {\rusername: userData.username,\raccess_token: Token,\rstatusCode: 200\r}\r});\r}\rcreateToken(user: any) {\rconst payload = { username: user.username, sub: user.id };\rreturn this.jwtService.sign(payload);\r}\r}\r ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:3:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["coding"],"content":"实现 JWT 认证策略 实现了用户注册登录后，我们需要保护 API，限制有的路由地址需要用户登录后才能访问，有的路由地址需要管理员登录后才能访问。我们这里只实现需要普通用户登录后才能访问的路由。 什么是Token？ 前后端分离模式下，Token 是我们验证用户登录的常用方式。Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器会生成一个Token并将此Token，返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。 为什么要使用Token？ 在很多项目案例中，需要实现账户的功能，客户端所有的功能都基于用户已登陆的前提下才可以使用。这就要求每次客户端向服务器请求数据时都要验证账户是否正确，如果正确则按正常方式返回数据，如果错误则进行拦截并返回错误信息。但是当客户端频繁向服务器请求数据的话，每次服务器都要频繁地查询数据库。而Token正是为了 减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。并取代传统使用session的方法来进行验证。 在 Nest.js 中使用 jwt(json web token), 我们需要安装以下依赖： yarn add @nestjs/jwt passport-jwt\ryarn add -D @types/passport-jwt\r 我们在 auth.service.ts 中已经实现了生成 jwt 字符串的方法，在用户登录路由中就会调用，并返回 jwt 字符串： createToken(user: any) {\rconst payload = { username: user.username, sub: user.id };\rreturn this.jwtService.sign(payload);\r}\r 注意 上面 sign 的参数 payload 是可逆加密的，拿到 token 后是可以解密成明文内容的，所以这部分不要放敏感信息。 我们已经创建了 jwt 字符串作为请求令牌，那么服务端如何根据 jwt 字符串的内容，找到用户信息？ 我们就需要实现 jwt 认证策略，在 auth 文件夹下新建 jwt.strategy.ts 文件： import { Injectable } from '@nestjs/common'\rimport { PassportStrategy } from '@nestjs/passport'\rimport { ExtractJwt, Strategy } from 'passport-jwt'\rimport { JWT_SECRET } from 'config'\r@Injectable()\rexport class JwtStrategy extends PassportStrategy(Strategy) {\rconstructor() {\rsuper({\rjwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\rignoreExpiration: false,\rsecretOrKey: JWT_SECRET,\r})\r}\rasync validate(payload: any) {\rreturn { userId: payload.sub, username: payload.username };\r}\r}\r 解释一下，对于 JWT 策略，Passport 首先验证 JWT 的签名并解码为 JSON 格式内容。仅在 @nestjs/passport 模块验证令牌有效后，才调用 validate() 方法。该方法将解码后的 JSON 作为其单个参数继续传递。否则。将阻止请求，抛出 401 Unauthorized 的异常。 现在来看我们的auth.controller.ts，可以将 validate() 返回值输出到控制台： // auth.controller.ts\r\r@UseGuards(AuthGuard('jwt'))\r@Get('users')\rasync findAll(@Request() req): Promise\u003cany[]\u003e {\rconsole.log('--------------Auth--Success---------------')\rconsole.log(req.user);\rreturn await this.authService.findAll();\r}\r 最后这是我们的 auth.module.ts，其中注册了 jwt 字符串过期时间，我们在 auth.service.ts 中注入了 UserService，记得导入 UserModule。 // auth.module.ts\r @Module({\rimports: [\rPassportModule,\rJwtModule.register({\rsecret: JWT_SECRET,\rsignOptions: { expiresIn: '3600s' },\r}),\rUserModule,\r],\rcontrollers: [AuthController],\rproviders: [AuthService, LocalStrategy, JwtStrategy],\rexports: [AuthService],\r})\rexport class AuthModule { }\r 启动项目：$ npm run start:dev，打开 http://localhost:3000/docs 在 swagger 文档模型中测试我们的 api。先 signUp, 然后 signIn, 登录成功返回 access_token，点击那个锁符号，将 access_token 的值粘贴过去，就能通过认证了。 附：源码地址 参考资料 Nest.JS 官方文档 Typeorm 官方文档 Node.js JWT 范例 ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:4:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["coding"],"content":"本篇文章将介绍如何用 Spring boot 与 Vue.js 创建一个具有基本 crud 功能的全栈 web 应用，我们将使用 bootstrap 作为项目的 UI 库，适合 web 开发初学者阅读。 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:0:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["coding"],"content":"后端接口 到 https://start.spring.io/ 去生成和下载 spring 应用，Group 填写 com.jpa，Artifact 填写 spring-jpa-demo， 其他默认选择就好，点击 Generate 就会生成并下载名压缩包，将压缩包解压，并在编辑器中打开。 我们使用 jpa 作为我们的 orm, 连接 mysql 数据库，因此在 pom.xml 中加入以下依赖。 \u003c!-- jpa driver --\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\r\u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e\r\u003c/dependency\u003e\r\u003c!-- spring web driver --\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\r\u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e\r\u003c/dependency\u003e\r\u003c!-- MySQL database driver --\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003emysql\u003c/groupId\u003e\r\u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e\r\u003c/dependency\u003e\r\u003c!-- Skip test plugin --\u003e\r\u003cplugin\u003e\r\u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e\r\u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e\r\u003cversion\u003e2.22.2\u003c/version\u003e\r\u003cconfiguration\u003e\r\u003cskipTests\u003etrue\u003c/skipTests\u003e\r\u003c/configuration\u003e\r\u003c/plugin\u003e\r ","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["coding"],"content":"I. 数据库连接 编写数据库连接文件 application.properties，它在 resources 文件夹中。 ## use create when running the app for the first time\r## then change to \"update\" which just updates the schema when necessary\rspring.datasource.url=jdbc:mysql://localhost:3306/notesapi?createDatabaseIfNotExist=true\u0026useSSL=false\u0026serverTimezone=UTC\rspring.datasource.username=root\rspring.datasource.password=root\rspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r## this shows the sql actions in the terminal logs\rspring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect\rspring.jpa.hibernate.ddl-auto=update\rspring.jpa.show-sql=true\rspring.jpa.properties.hibernate.format_sql=true\r##optional, but just in case another application is listening on your default port (8080)\rserver.port = 8034\r 这是我们的 src 文件夹结构，接下来的文件都会在 src 中编写。 \r在 entity文件夹中新建文件 Notes.java，这是我们的数据表映射。 package com.jpa.springjpademo.entity;\rimport javax.persistence.*;\rimport org.hibernate.annotations.CreationTimestamp;\rimport org.hibernate.annotations.GenericGenerator;\rimport org.hibernate.annotations.UpdateTimestamp;\rimport java.util.Date;\r@Entity\r@Table(name = \"notes_table\")\r@GenericGenerator(name = \"jpa-uuid\", strategy = \"uuid\") // 这个是hibernate的注解/生成32位UUID\rpublic class Notes {\r@Id\r@GeneratedValue(generator = \"jpa-uuid\")\r@Column(name = \"notes_id\", nullable = false, length = 32)\rprivate String notes_id;\r// 默认创建时间\r @Column(name = \"create_time\")\r@Temporal(TemporalType.TIMESTAMP)\r@CreationTimestamp\rprivate Date time;\r// 默认更新时间\r @Column(name = \"update_time\")\r@Temporal(TemporalType.TIMESTAMP)\r@UpdateTimestamp\rprivate Date update_time;\r@Column(name = \"title\", nullable = true, length = 100)\rprivate String title;\r@Column(name = \"description\", nullable = true, length = 255)\rprivate String description;\r@Column(name = \"content\", nullable = true)\r@Lob\r@Basic(fetch = FetchType.LAZY)\rprivate String content;\r@Column(name = \"author\", nullable = true, length = 50)\rprivate String author;\rpublic String getId() {\rreturn notes_id;\r}\rpublic void setId(String notes_id) {\rthis.notes_id = notes_id;\r}\rpublic String getTitle() {\rreturn title;\r}\rpublic void setTitle(String title) {\rthis.title = title;\r}\rpublic String getDescription() {\rreturn description;\r}\rpublic void setDescription(String description) {\rthis.description = description;\r}\rpublic String getContent() {\rreturn content;\r}\rpublic void setContent(String content) {\rthis.content = content;\r}\rpublic String getAuthor() {\rreturn author;\r}\rpublic void setAuthor(String author) {\rthis.author = author;\r}\rpublic void setUpdateTime(Date update_time) {\rthis.update_time = update_time;\r}\rpublic Date getUpdateTime() {\rreturn update_time;\r}\r}\r 在 dao 文件夹中新建文件 NotesDao.java, 只需实现 JpaRepository 接口，我们就能够连接到数据库。 package com.jpa.springjpademo.dao;\rimport com.jpa.springjpademo.entity.Notes;\rimport org.springframework.data.jpa.repository.JpaRepository;\rimport org.springframework.stereotype.Repository;\r@Repository\rpublic interface NotesDao extends JpaRepository\u003cNotes, String\u003e {\r}\r 接下来终端执行 $ mvn clean package 下载依赖，编译代码。然后 $ mvn spring-boot:run 运行项目。项目运行起来后刷新数据库，可以看到新生成名为 notesapi 的数据库，其中有一个名为 notes_table 的数据表。表示我们的数据库连接成功。 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:1","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["coding"],"content":"II. 增删改查 五步实现完整的数据增删改查和接口测试： 1.实现 Conctroller 路由处理 2.实现 Service 数据库操作 3.实现 Exception 异常捕获 4.实现 Cors 跨域配置 5.实现 Swagger 文档配置 下面是详细步骤和代码示例： 实现 Conctroller 路由处理： package com.jpa.springjpademo.controller;\rimport com.jpa.springjpademo.entity.Notes;\rimport com.jpa.springjpademo.service.NotesService;\rimport org.springframework.http.ResponseEntity;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.http.MediaType;\rimport org.springframework.web.bind.annotation.*;\rimport java.util.List;\r@RestController\r@RequestMapping(\"/api/notes\")\rpublic class NotesController {\r@Autowired\rNotesService notesService;\r@RequestMapping(value = \"/all\", method = RequestMethod.GET)\rpublic List\u003cNotes\u003e getAllNotes() {\rreturn notesService.getAllNotes();\r}\r@RequestMapping(value = \"/create\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)\rpublic Notes addNotes(@RequestBody Notes notes) {\rreturn notesService.addNotes(notes);\r}\r@RequestMapping(value = \"/update\", method = RequestMethod.PUT, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)\rpublic Notes updateNotes(@RequestParam(\"notes_id\") String id, @RequestBody Notes notes) {\rreturn notesService.updateNotes(id, notes);\r}\r@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\rpublic Notes getNotes(@PathVariable(\"id\") String id) {\rreturn notesService.getNotesById(id);\r}\r@RequestMapping(value = \"/delete/all\", method = RequestMethod.DELETE)\rpublic void deleteAllNotes() {\rnotesService.deleteAllNotes();\r}\r@RequestMapping(value = \"/delete\", method = RequestMethod.DELETE)\rpublic ResponseEntity\u003c?\u003e deleteNotes(@RequestParam(\"notes_id\") String id) {\rreturn notesService.deleteNotesById(id);\r}\r}\r 实现 Service 数据库操作： package com.jpa.springjpademo.service;\rimport com.jpa.springjpademo.dao.NotesDao;\rimport com.jpa.springjpademo.entity.Notes;\rimport com.jpa.springjpademo.exception.ResourceNotFoundException;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.http.ResponseEntity;\rimport org.springframework.stereotype.Service;\rimport java.util.List;\r@Service\rpublic class NotesService {\r@Autowired\rNotesDao notesDao;\rpublic List\u003cNotes\u003e getAllNotes() {\rreturn notesDao.findAll();\r}\rpublic Notes addNotes(Notes notes) {\rreturn notesDao.save(notes);\r}\rpublic Notes getNotesById(String id) {\rreturn notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id));\r}\rpublic Notes updateNotes(String id, Notes notes) {\rNotes tnotes = notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id));\rtnotes.setTitle(notes.getTitle());\rtnotes.setDescription(notes.getDescription());\rtnotes.setContent(notes.getContent());\rtnotes.setAuthor(notes.getAuthor());\rreturn notesDao.save(tnotes);\r}\rpublic ResponseEntity\u003c?\u003e deleteNotesById(String id) {\rNotes notes = notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id));\rnotesDao.delete(notes);\rreturn ResponseEntity.ok().build();\r}\rpublic void deleteAllNotes() {\rnotesDao.deleteAll();\r}\r}\r 实现 Exception 异常捕获： package com.jpa.springjpademo.exception;\rimport org.springframework.http.HttpStatus;\rimport org.springframework.web.bind.annotation.ResponseStatus;\r@ResponseStatus(value = HttpStatus.NOT_FOUND)\rpublic class ResourceNotFoundException extends RuntimeException {\rprivate static final long serialVersionUID = 1L;\rprivate String resourceName;\rprivate String fieldName;\rprivate Object fieldValue;\rpublic ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {\rsuper(String.format(\"%s not found with %s : '%s'\", resourceName, fieldName, fieldValue));\rthis.resourceName = resourceName;\rthis.fieldName = fieldName;\rthis.fieldValue = fieldValue;\r}\rpublic String getResourceName() {\rreturn resourceName;\r}\rpublic String getFieldName() {\rreturn fieldName;\r}\rpublic Object getFieldValue() {\rreturn fieldValue;\r}\r}\r 实现 Cors 跨域配置： pac","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:2","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["coding"],"content":"前端界面 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["coding"],"content":"I. 初始化配置 先安装好 Vue/cli 工具: $ npm install -g @vue/cli 安装完成后生成 Vue 项目: $ vue create blog-frontend 输入此命令后，我们将看到一个简短的提示。选择 manually select features 选项（手动选择特性）。然后按空格表示选择，我们选择Babel、Router 和 Linter/Formatter。后面选项一路回车就好。 我们使用 bootstrap 库定义基本的 css 样式。在 public 文件夹的 index.html 中加入以下代码： \u003clink rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css\"\u003e\r\u003cscript src=\"https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js\"\u003e\u003c/script\u003e\r\u003cscript src=\"https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js\"\u003e\u003c/script\u003e\r\u003cscript src=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js\"\u003e\u003c/script\u003e\r 安装 axios 处理 http 请求，这是一种基于 Promise 的浏览器 HTTP 客户端： $ yarn add axios 在 src 目录中新建文件夹 utils, 新建文件 helper.js, 对接后端接口: export const server = {\rbaseURL: 'http://localhost:8034/api/notes'\r}\r ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:1","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["coding"],"content":"II. 创建页面组件 在 component 中新建文件夹 post, 新建三个文件：Create.vue, Edit.vue, Post.vue 新增帖子组件 Create.vue \u003ctemplate\u003e\r\u003cdiv\u003e\r\u003cdiv class=\"col-md-12 form-wrapper\"\u003e\r\u003ch2\u003eCreate Post\u003c/h2\u003e\r\u003cform id=\"create-post-form\" @submit.prevent=\"createPost\"\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"title\"\u003eTitle\u003c/label\u003e\r\u003cinput type=\"text\" id=\"title\" v-model=\"title\" name=\"title\" class=\"form-control\"\rplaceholder=\"Enter title\"/\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"description\"\u003eDescription\u003c/label\u003e\r\u003cinput type=\"text\" id=\"description\" v-model=\"description\" name=\"description\" class=\"form-control\" placeholder=\"Enter Description\"/\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"content\"\u003eWrite Content\u003c/label\u003e\r\u003ctextarea id=\"content\" cols=\"30\" rows=\"5\" v-model=\"content\" class=\"form-control\"\u003e\u003c/textarea\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"author\"\u003eAuthor\u003c/label\u003e\r\u003cinput type=\"text\" id=\"author\" v-model=\"author\" name=\"author\" class=\"form-control\" /\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003cbutton class=\"btn btn-success\" type=\"submit\"\u003eCreate Post\u003c/button\u003e\r\u003c/div\u003e\r\u003c/form\u003e\r\u003c/div\u003e\r\u003c/div\u003e\r\u003c/template\u003e\r 这是 Create.vue 组件 script 标签中的内容 import axios from \"axios\";\rimport { server } from \"../../utils/helper\";\rimport router from \"../../router\";\rexport default {\rdata() {\rreturn {\rtitle: \"\",\rdescription: \"\",\rcontent: \"\",\rauthor: \"111hunter\"\r};\r},\rmethods: {\rcreatePost() {\rlet postData = {\rtitle: this.title,\rdescription: this.description,\rcontent: this.content,\rauthor: this.author\r};\rthis.__submitToServer(postData);\r},\r__submitToServer(data) {\raxios.post(`${server.baseURL}/create`, data).then(data =\u003e {\rrouter.push({ name: \"home\" });\r});\r}\r}\r};\r 修改帖子组件 Edit.vue \u003ctemplate\u003e\r\u003cdiv\u003e\r\u003ch4 class=\"text-center mt-20\"\u003e\r\u003csmall\u003e\r\u003cbutton class=\"btn btn-info\" v-on:click=\"navigate()\"\u003eView All Posts\u003c/button\u003e\r\u003c/small\u003e\r\u003c/h4\u003e\r\u003cdiv class=\"col-md-12 form-wrapper\"\u003e\r\u003ch2\u003eEdit Post\u003c/h2\u003e\r\u003cform id=\"edit-post-form\" @submit.prevent=\"editPost\"\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"title\"\u003eTitle\u003c/label\u003e\r\u003cinput type=\"text\" id=\"title\" v-model=\"post.title\" name=\"title\" class=\"form-control\" placeholder=\"Enter title\"/\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"description\"\u003eDescription\u003c/label\u003e\r\u003cinput type=\"text\" id=\"description\" v-model=\"post.description\" name=\"description\" class=\"form-control\"placeholder=\"Enter Description\"/\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"content\"\u003eWrite Content\u003c/label\u003e\r\u003ctextarea id=\"content\" cols=\"30\" rows=\"5\" v-model=\"post.content\" class=\"form-control\"\u003e\u003c/textarea\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"author\"\u003eAuthor\u003c/label\u003e\r\u003cinput type=\"text\" id=\"author\" v-model=\"post.author\" name=\"author\" class=\"form-control\" /\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003cbutton class=\"btn btn-warning\" type=\"submit\"\u003eEdit Post\u003c/button\u003e\r\u003c/div\u003e\r\u003c/form\u003e\r\u003c/div\u003e\r\u003c/div\u003e\r\u003c/template\u003e\r 这是 Edit.vue 组件 script 标签中的内容 import { server } from \"../../utils/helper\";\rimport axios from \"axios\";\rimport router from \"../../router\";\rexport default {\rdata() {\rreturn {\rid: 0,\rpost: {}\r};\r},\rcreated() {\rthis.id = this.$route.params.id;\rthis.getPost();\r},\rmethods: {\reditPost() {\rlet postData = {\rtitle: this.post.title,\rdescription: this.post.description,\rcontent: this.post.content,\rauthor: this.post.author\r};\raxios\r.put(`${server.baseURL}/update/?notes_id=${this.id}`, postData)\r.then(data =\u003e {\rrouter.push({ name: \"home\" });\r});\r},\rgetPost() {\raxios\r.get(`${server.baseURL}/${this.id}`)\r.then(data =\u003e (this.post = data.data));\r},\rnavigate() {\rrouter.go(-1);\r}\r}\r};\r 帖子详情组件 Post.vue \u003ctemplate\u003e\r\u003cdiv class=\"text-center\"\u003e\r\u003cdiv class=\"col-sm-12\"\u003e\r\u003ch4 style=\"margin-top: 30px;\"\u003e\r\u003csmall\u003e\r\u003cbutton class=\"btn btn-info\" v-on:click=\"navigate()\"\u003eView All Posts\u003c/button\u003e\r\u003c/small\u003e\r\u003c/h4\u003e\r\u003chr /\u003e\r\u003ch2\u003e{{ post.title }}\u003c/h2\u003e\r\u003ch5\u003e\r\u003cspan class=\"glyphicon glyphicon-time\"\u003e\u003c/span\u003e\rPost by {{post.author}}, {{new Date(post.updateTime).toLocaleDateString()}}.\r\u003c/h5\u003e\r\u003cp\u003e{{ post.content }}\u003c/p\u003e\r\u003c/div\u003e\r\u003c/div\u003e\r\u003c/template\u003e\r 这是 Post.vue 组件 script 标签中的内容 import { server } from \"../../utils/h","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:2","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["coding"],"content":"III. 搭建路由 在根组件 App.vue 中修改链接: \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e\r 将 about 改为 create, 链接到 Create 组件: \u003crouter-link to=\"/Create\"\u003eCreate\u003c/router-link\u003e\r 最后将 router/index.js 改为以下代码： import Vue from 'vue'\rimport Router from 'vue-router'\rimport HomeComponent from '@/views/Home';\rimport EditComponent from '@/components/post/Edit';\rimport CreateComponent from '@/components/post/Create';\rimport PostComponent from '@/components/post/Post';\rVue.use(Router)\rexport default new Router({\rmode: 'history',\rbase: process.env.BASE_URL,\rroutes: [\r{ path: '/', redirect: { name: 'home' } },\r{ path: '/home', name: 'home', component: HomeComponent },\r{ path: '/create', name: 'Create', component: CreateComponent },\r{ path: '/edit/:id', name: 'Edit', component: EditComponent },\r{ path: '/post/:id', name: 'Post', component: PostComponent }\r]\r});\r 编写完前端代码，启动服务： $ npm run serve 浏览器打开 http://localhost:8080 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:3","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["coding"],"content":"成果展示 pc端展示： \r移动端展示：\r\r附：源码地址 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:3:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["coding"],"content":" ReactiveX 结合了 观察者模式、迭代器模式 和 使用集合的函数式编程，以满足以一种理想方式来管理事件序列所需要的一切。 在 RxJS 中用来解决异步事件管理的的基本概念是： Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。 Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。 Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。 Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。 Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。 Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。 以上文字来自 RxJS 中文文档，是 RxJS 的核心概念。 下面来学习创建 Observable 对象以加深对一些概念的理解。 本文将生成 observable 的操作符分为以下四类： 转换操作符：from，fromEvent，fromPromise，of 创建操作符：create, range 时间操作符：interval, timer 特殊操作符：empty, never, throw ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:0:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"项目初始化 我们使用 webpack 作为项目构建工具。使用 Babel 编译我们的代码。这是我们的项目依赖： \"devDependencies\": {\r\"@babel/core\": \"^7.8.7\",\r\"@babel/preset-env\": \"^7.8.7\",\r\"babel-loader\": \"^8.0.6\",\r\"webpack\": \"^4.42.0\"\r},\r\"dependencies\": {\r\"jquery\": \"^3.1.0\",\r\"rxjs\": \"^5.0.0-beta.12\"\r}\r webpack 配置文件 webpack.config.js: module.exports = {\rentry: './src/app.js',\routput: {\rpath: __dirname + '/dist',\rfilename: 'app.bundle.js'\r},\rmodule: {\rrules: [\r{\rtest: /\\.m?js$/,\rexclude: /(node_modules|bower_components)/,\ruse: {\rloader: 'babel-loader',\roptions: {\rpresets: ['@babel/preset-env']\r}\r}\r}\r]\r}\r}\r 新建文件夹src, 在里面新建文件 app.js, 我们在 app.js 中引入 jquery 和 RxJS。 import $ from 'jquery';\rimport Rx from 'rxjs/Rx';\rconsole.log('Code Running...');\r 在 html 文件中引入编译后的 js 文件。 \u003cbody\u003e\r\u003cinput type=\"text\" id=\"input\"\u003e\r\u003cdiv id=\"output\"\u003e\u003c/div\u003e\r\u003cul\u003e\r\u003cli id=\"name\"\u003e\u003c/li\u003e\r\u003cli id=\"artist\"\u003e\u003c/li\u003e\r\u003c/ul\u003e\r\u003cscript src=\"./dist/app.bundle.js\"\u003e\u003c/script\u003e\r\u003c/body\u003e\r 执行 webpack --watch --mode development，实时监视文件变化，并重新编译代码。 打开浏览器控制台没有任何报错，并输出 “Code Running…” 说明我们的项目构建成功。 高版本的 chrome 可能出现 DevTools failed to parse SourceMap，在控制台的setting中取消 Enable JavaScript source maps 这一项即可。 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:1:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"转换操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"Observable.from() Observable.from() 将 可迭代对象 转化为 observables 序列, 传入数据集合。 // from array\rconst numbers = [1, 2, 3, 4, 5];\rconst numbers$ = Rx.Observable.from(numbers);\rnumbers$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\r() =\u003e console.log('complete')\r);\r// from string\rconst str = 'hello world'\rconst str$ = Rx.Observable.from(str);\rstr$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\r() =\u003e console.log('complete')\r);\r// from array of objects\rconst posts = [\r{ title: 'post 1', body: 'body 1' },\r{ title: 'post 2', body: 'body 2' },\r{ title: 'post 3', body: 'body 3' }\r];\rconst posts$ = Rx.Observable.from(posts);\rposts$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\r() =\u003e console.log('complete')\r);\r// from set\rconst set = new Set(['hello', 123, { title: 'my title' }])\rconst set$ = Rx.Observable.from(set);\rset$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\r() =\u003e console.log('complete')\r);\r// from map\rconst map = new Map([[1, 2], [3, 4], [5, 6]])\rconst map$ = Rx.Observable.from(map);\rmap$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\r() =\u003e console.log('complete')\r);\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"Observable.fromEvent() Observable.fromEvent() 将 事件 转化为 observables 序列, 传入两个参数：页面元素 和 事件名称。从事件中创建的 observable 对象是持续不断产生的，不会输出 “completed”。 转化键盘事件: const input = $('#input');\rconst output = $('#output');\rconst inputStream$ = Rx.Observable.fromEvent(input, 'keyup');\rinputStream$.subscribe(\re =\u003e {\rconsole.log(e.target.value);\routput.text(e.target.value);\r},\rerr =\u003e console.log(err),\r() =\u003e console.log('completed')\r);\r 转化鼠标事件: const moveStream$ = Rx.Observable.fromEvent(document, 'mousemove');\rmoveStream$.subscribe(\re =\u003e {\rconsole.log(e.type);\routput.html('\u003ch1\u003eX: ' + e.clientX + ' Y: ' + e.clientY + '\u003c/h1\u003e');\r},\rerr =\u003e console.log('err'),\r() =\u003e console.log('completed')\r);\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:2","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"Observable.fromPromise() Observable.fromPromise() 将 promise 转化为 observables 序列, 传入 promise。 const myPromise = new Promise((resolve, reject) =\u003e {\rconsole.log('creating promise');\rsetTimeout(() =\u003e {\rresolve('hello from promise');\r}, 500);\r});\rconst myPromiseSource$ = Rx.Observable.fromPromise(myPromise);\rmyPromiseSource$.subscribe(x =\u003e console.log(x));\r 结合之前定义的 inputStream$ 嵌套使用： function getSong(username) {\rreturn $.ajax({\rtype: 'GET',\rurl: `https://autumnfish.cn/search?keywords=` + username,\r}).promise();\r}\rconst song = $('#input')\rconst inputStream$ = Rx.Observable.fromEvent(song, 'keyup')\rinputStream$.subscribe(e =\u003e {\rRx.Observable.fromPromise(getSong(e.target.value))\r.subscribe(x =\u003e {\r$('#name').text('Song: ' + x.result.songs[0].name)\rconsole.log(x.result.songs[0].name)\r$('#artist').text('Artist: ' + x.result.songs[0].artists[0].name)\r});\r}\r);\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:3","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"Observable.of() of 操作符接收1个或多个参数。转换为 Observable 对象。 const stream$ = Rx.Observable.of(1, 2, 3, 'hello');\rstream$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r);\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:4","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"创建操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"Observable.create() Rx.Observable.create 是 Observable 构造函数 的别名，它接收一个以 observer 作为参数的回调函数。这个回调函数会定义 observable 将会如何发送值给 observer。observer是什么？observer就是我们之前传入 subscribe() 的参数，是一个有三个回调函数的对象。 const source$ = new Rx.Observable.create(\robserver =\u003e {\robserver.next('hello')\robserver.next('another hello')\rsetTimeout(() =\u003e {\robserver.next('next hello')\robserver.complete();\r}, 2000);\r}\r);\rconst observer1 = {\rnext: v =\u003e console.log(v + '1'),\rerror: err =\u003e console.log(err),\rcomplete: () =\u003e console.log('complete')\r}\rsource$.subscribe(observer1);\r observable 是数据流的生产者，决定数据怎么给。observer 是数据流的消费者，决定数据怎么用。observable 是老板，observer 是顾客。 observable.subscribe()会实例化一个Subscription对象。Subscription表示Observable 的执行，可以被清理。这个对象最常用的方法是unsubscribe方法。 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"Observable.range() 接收两个数字参数产生有序序列，一个是开始序列数字。一个是序列个数。 const rangeSource$ = Rx.Observable.range(6, 5)\rrangeSource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r)\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:2","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"时间操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:4:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"Observable.interval 和 Observable.timer 从零开始产生数字，interval的参数是数字产生的间隔时间，timer 多了个开始延迟时间作为第一个参数。 const intervalSource$ = Rx.Observable.interval(1000).take(5)\rintervalSource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r)\rconst timerSource$ = Rx.Observable.timer(2000, 1000).take(5)\rtimerSource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r)\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:4:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"特殊操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:5:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"Observable.empty(), Observable.never() 和 Observable.throw() Observable.empty 创建的 Observable 开始就结束，Observable.never 创建的 Observable 不会结束，Observable.throw 抛出异常不会结束。 const emptySource$ = Rx.Observable.empty()\remptySource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r)\rconst neverSource$ = Rx.Observable.never()\rneverSource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r)\rconst errorSource$ = Rx.Observable.throw('err')\rerrorSource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log('Throw Error: ' + err),\rcomplete =\u003e console.log('complete')\r)\r 附：源码地址 参考资料 RxJS Ultimate 中文版 30 天精通 RxJS RxJS 中文文档 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:5:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["coding"],"content":"前端中的状态指什么？前端中的状态指的是影响 UI 变化的数据。例如用户登入退出，用户的某种操作带来的 UI 视觉变化，UI 主题的切换，甚至路由的切换也是状态变化。 为什么要进行状态管理？通常来说前端中的状态是状态碎片，存在余各个组件中。这种碎片化的状态给开发团队带来的维护上的麻烦。为了规范开发流程，我们需要对状态进行集中统一管理。什么是ngrx？ngrx = rxjs + rudux。rudux是前端开发中主流状态管理库，不依赖平台。ngrx 相当于 rudux 在 angular 中的使用扩充。 注意 状态管理不是前端应用必须使用的，它让简单程序变复杂，让复杂程序变简单。 angular 有无 ngrx 的架构对比： \r没有状态管理前，构建 angular 程序我们仅需要 component, service, 以及后端数据 api 接口。而添加了状态管理后，我们的程序多出不少新的概念，状态管理将我们的应用复杂化了吗？对于复杂应用来说，是简化了。在软件开发中，一切看似的复杂往往是为了简单。其实状态管理这个概念类似于后端的数据库。 下面，我们对 ngrx 的各种新概念进行介绍，以下内容仅是个人理解。redux 中核心概念只有三个: Store, Action, Reducer，其他是 ngrx 的扩展。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:0:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["coding"],"content":"Store 简单的理解就是前端状态的数据库，它有一个基本原则: 是\"唯一的、状态不可修改\"的树。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:1:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["coding"],"content":"Action 可以理解为状态变化的信号，当状态发生变化时，通过 Action 显性定义状态变化，传递状态发生变化的数据。可配合 store-devtools 使用。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:2:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["coding"],"content":"Reducer 它是前端数据状态映射成的 Store 数据库中的表，接收旧状态，返回新状态。它是一个纯函数, 需要通过 Action 告知能够进行的状态变化。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:3:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["coding"],"content":"Effects 我们在进行一些 Action 时需要发送 http 请求，DOM 操作, 读写文件等。redux 状态管理只关心视图层的状态变化, 不会解决这些的需求。因此 ngrx 扩展了 Effects, 其实它是一个钩子函数。这大概就是示意图中虚线的含义。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:4:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["coding"],"content":"Selector 性能优化，官方解释：因为选择器是纯函数，所以当参数匹配时可以返回最后的结果，而无需重新调用选择器函数。Store 通过 Selector 得到 component 状态。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:5:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["coding"],"content":"Entity 性能优化，Reducer 实现 EntityState 接口，就能够注册数据集合 id 和 entity, 通过 id 来找到数据。配合 store-devtools 工具使用。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:6:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["coding"],"content":"Router-store 侦听路由状态的变化。配合 store-devtools 工具使用。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:7:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["coding"],"content":"整体流程 当我们 component 中的 state 需要改变时，发出 Action 信号, Reducer 根据 Action 的信号选择更新 state, Store 收到 state 的变化，通过 selector 得到状态切片选择性地更新 compont 中的 state。 有些过程无法在这个流程中实现，例如从后端 api 获取数据，于是我们在发出 Action 时，套上 Effects 钩子函数，在钩子函数中调用 service 取得后端数据。 下面是使用各个 api 的例子, 关于如何注册各个模块，官网有详细说明，不在赘述。 现在我们需要管理 customer 的状态, customer 定义如下： //customer.model.ts\r\rexport interface Customer {\rid?: number;\rname: string;\rphone: string;\raddress: string;\rmembership: string;\r}\r 用 json.server 做服务器，创建 db.json 写入两个 customer： {\r\"customers\": [\r{\r\"name\": \"John Doe\",\r\"phone\": \"910928392098\",\r\"address\": \"123 Sun Street\",\r\"membership\": \"Platinum\",\r\"id\": 1\r},\r{\r\"name\": \"Mary Johnson\",\r\"phone\": \"808937482734\",\r\"address\": \"893 Main Voulevard\",\r\"membership\": \"Pro\",\r\"id\": 2\r}\r]\r}\r 我们要做的是管理监视页面加载 customer 的过程。coustom 有三种加载状态：加载中，加载成功，加载失败。 先定义 customer 的状态, loading, loaded, error, 实现 EntityState 接口性能优化，方便管理： //customer.entity.ts\r\rimport { EntityState, EntityAdapter, createEntityAdapter } from \"@ngrx/entity\";\rimport * as fromRoot from \"../../state/app-state\";\rimport { Customer } from \"../customer.model\";\rexport interface CustomerState extends EntityState\u003cCustomer\u003e {\rselectedCustomerId: number | null;\rloading: boolean;\rloaded: boolean;\rerror: string;\r}\rexport interface AppState extends fromRoot.AppState {\rcustomers: CustomerState;\r}\rexport const customerAdapter: EntityAdapter\u003cCustomer\u003e = createEntityAdapter\u003c\rCustomer\r\u003e();\r 接着实现 Action, Action 要实现两个属性 payload? 和 type，发出 Action 的方法是 store.dispatch()。 //customer.action.ts\r\rimport { Action } from \"@ngrx/store\";\rimport { Customer } from \"../customer.model\";\rexport enum CustomerActionTypes {\rLOAD_CUSTOMERS = \"[Customer] Load Customers\",\rLOAD_CUSTOMERS_SUCCESS = \"[Customer] Load Customers Success\",\rLOAD_CUSTOMERS_FAIL = \"[Customer] Load Customers Fail\"\r}\rexport class LoadCustomers implements Action {\rreadonly type = CustomerActionTypes.LOAD_CUSTOMERS;\r}\rexport class LoadCustomersSuccess implements Action {\rreadonly type = CustomerActionTypes.LOAD_CUSTOMERS_SUCCESS;\rconstructor(public payload: Customer[]) {}\r}\rexport class LoadCustomersFail implements Action {\rreadonly type = CustomerActionTypes.LOAD_CUSTOMERS_FAIL;\rconstructor(public payload: string) {}\r}\rexport type Action = LoadCustomers | LoadCustomersSuccess | LoadCustomersFail;\r 要从 json-server 中获取数据，我们必须实现 Effects, 调用 service: //customer.effects.ts\r\rimport { Injectable } from \"@angular/core\";\rimport { Actions, Effect, ofType } from \"@ngrx/effects\";\rimport { Action } from \"@ngrx/store\";\rimport { Observable, of } from \"rxjs\";\rimport { map, mergeMap, catchError } from \"rxjs/operators\";\rimport { CustomerService } from \"../customer.service\";\rimport * as customerActions from \"./customer.action\";\rimport { Customer } from \"../customer.model\";\r@Injectable()\rexport class CustomerEffect {\rconstructor(\rprivate actions$: Actions,\rprivate customerService: CustomerService\r) { }\r@Effect()\rloadCustomers$: Observable\u003cAction\u003e = this.actions$.pipe(\rofType\u003ccustomerActions.LoadCustomers\u003e(\rcustomerActions.CustomerActionTypes.LOAD_CUSTOMERS\r),\rmergeMap((actions: customerActions.LoadCustomers) =\u003e\rthis.customerService.getCustomers().pipe(\rmap(\r(customers: Customer[]) =\u003e\rnew customerActions.LoadCustomersSuccess(customers)\r),\rcatchError(err =\u003e of(new customerActions.LoadCustomersFail(err)))\r)\r)\r);\r}\r 接着实现 Reducer，其中的 state 显示在 store-devtools 工具中： //customer.reducer.ts\r\rimport * as customerActions from \"./customer.action\";\rimport { CustomerState, customerAdapter } from \".\";\rexport const defaultCustomer: CustomerState = {\rids: [],\rentities: {},\rselectedCustomerId: null,\rloading: false,\rloaded: false,\rerror: \"\"\r};\rexport const initialState = customerAdapter.getInitialState(defaultCustomer);\rexport function customerReducer(\rstate = initialState,\raction: customerActions.Action\r): CustomerState {\rswitch (action.type) {\rcase customerActions.CustomerActionTypes.LOAD_CUSTOMERS: {\rreturn {\r...state,\rloading: true\r};\r}\rcase customerActions.CustomerActionTypes.LOAD_CUSTOMERS_SUCCESS: {\rreturn customerAdapter.addAll(action.pa","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:8:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["coding"],"content":"随着代码量的增长传统的 MVC 模式中 Modal 和 Controller 会变得含糊不清，导致难于维护。 传统 MVC 与 NestJS 架构对比： \rNest(Nest.js) 的分层借鉴自 Spring，更细化。我们应该要了解整个 Nest 框架的三层结构，Nest 和传统的 MVC 框架的区别在于它更注重于后端部分（控制器、服务与数据）的架构，视图层相对比较独立，完全可以由用户自定义配置。 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:0:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["coding"],"content":"创建 Nest 项目 $ npm install -g @nest/cli 全局安装 nest 脚手架 $ nest new nest-crud 新建 nest.js 项目, 选择 yarn 作为开发工具 $ nest g mo photo 建立 PhotoModule $ nest g co photo 建立 PhotoController $ nest g s photo 建立 PhotoService $ yarn add @nestjs/typeorm typeorm mysql 需要使用 typeorm, mysql 需要安装这些库 在 TypeORM 中数据库的表对应的就是一个类，通过定义一个类来创建实体。实体（Entity）是一个映射到数据库表的类 (类似于 mongoose 中的 Schema 映射到 MongoDB 的 collection)，通过@Entity()来标记。在photo文件夹中新建 photo.entity.ts: // photo.entity.ts\r\rimport { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';\r@Entity('photo')\rexport class PhotoEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column({ length: 500 })\rname: string;\r@Column('text')\rdescription: string;\r@Column()\rfilename: string;\r@Column('int')\rviews: number;\r@Column()\risPublished: boolean;\r}\r 在 app.module.ts 中的 import 数组中配置数据库连接，可以配置多个数据库连接。 TypeOrmModule.forRoot({\rtype: 'mysql',\rhost: 'localhost',\rport: 3306,\rusername: 'root',\rpassword: '123456',\rdatabase: 'test',\rentities: [PhotoEntity],\rsynchronize: true,\r})\r 然后在 photo.mudule.ts 中 import 数组中注册要本模块使用的数据库。这样，我们就可以使用 @InjectRepository() 装饰器将 PhotoRepository 注入到 PhotoService 中 imports: [TypeOrmModule.forFeature([PhotoEntity])]\r 数据传输对象简称 DTO(Data Transfer Object)，是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。class-validator 可以很方便地验证前端传过来的参数。 // photo.dto.ts\r\rimport { IsString, IsInt, IsBoolean } from 'class-validator';\rexport class PhotoDto {\r@IsInt()\rreadonly id: number;\r@IsString()\rreadonly name: string;\r@IsString()\rreadonly description: string;\r@IsString()\rreadonly filename: string;\r@IsInt()\rreadonly views: number;\r@IsBoolean()\rreadonly isPublished: boolean;\r}\r ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:1:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["coding"],"content":"三层结构 将 PhotoRepository 注入到 PhotoService 中, 写数据库操作的 crud 代码: @Injectable()\rexport class PhotoService {\rconstructor(\r@InjectRepository(PhotoEntity)\rprivate readonly photoRepository: Repository\u003cPhotoEntity\u003e,\r) { }\rasync findAll(): Promise\u003cPhotoEntity[]\u003e {\rreturn this.photoRepository.find();\r}\rasync create(photoDto: PhotoDto): Promise\u003cPhotoEntity\u003e {\rreturn await this.photoRepository.save(photoDto)\r}\rasync delete(id: number) {\rreturn await this.photoRepository.delete(id)\r}\rasync update(photoDto: PhotoDto) {\rreturn await this.photoRepository.update(photoDto.id, photoDto)\r}\rasync findOne(id: number): Promise\u003cPhotoEntity\u003e {\rreturn await this.photoRepository.findOne(id)\r}\r}\r 将 PhotoService 注入到 PhotoController 中, 写 api 路由: @Controller('photo')\rexport class PhotoController {\rconstructor(private readonly photoService: PhotoService) { }\r@Get()\rfindAll(): Promise\u003cPhotoEntity[]\u003e {\rreturn this.photoService.findAll();\r}\r@Post('create')\rcreate(@Body() PhotoDto: PhotoDto): Promise\u003cPhotoEntity\u003e {\rreturn this.photoService.create(PhotoDto)\r}\r@Delete('delete/:id')\rdelete(@Param('id') id: number) {\rreturn this.photoService.delete(id)\r}\r@Put('update/:id')\rupdate(@Param('id') id: number, @Body() PhotoDto: PhotoDto) {\rreturn this.photoService.update(PhotoDto)\r}\r@Get(':id')\rfindOne(@Param('id') id: number): Promise\u003cPhotoEntity\u003e {\rreturn this.photoService.findOne(id)\r}\r}\r 接下来在 main.ts 中配置 swagger, 方便我们测试 api const app = await NestFactory.create(AppModule);\rconst options = new DocumentBuilder()\r.setTitle('photo example')\r.setDescription('The photo API description')\r.setVersion('0.0.1')\r.build();\rconst document = SwaggerModule.createDocument(app, options);\rSwaggerModule.setup('docs', app, document);\rawait app.listen(3000);\r $ npm run start 启动 nest 项目, 访问 http://localhost:3000/docs ，到这里基本的 crud 操作已经实现，此时，NestJS框架的三层结构已有体现。接下来再完善项目。 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:2:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["coding"],"content":"AOP 的思想 我们在 PhotoController 的路由请求参数中传入了 DTO, 做了直接的参数校验。传入类型不符合要求时，会直接报错。DTO 中的class-validator 还需要配合 pipe 才能完成校验功能。新建一个 pipe 捕获异常。$ nest g pi section/validation @Injectable()\rexport class ValidationPipe implements PipeTransform\u003cany\u003e {\rasync transform(value, metadata: ArgumentMetadata) {\rconst { metatype } = metadata\rif (!metatype || !this.toValidate(metatype)) {\rreturn value\r}\rconst object = plainToClass(metatype, value)\rconst errors = await validate(object)\rif (errors.length \u003e 0) {\rconst errorMessage = _.values(errors[0].constraints)[0]\rthrow new BadRequestException(errorMessage)\r}\rreturn value\r}\rprivate toValidate(metatype): boolean {\rconst types = [String, Boolean, Number, Array, Object]\rreturn !types.find(type =\u003e metatype === type)\r}\r}\r 有了这一层 pipe 帮助我们校验参数，有效地降低了类的复杂度，提高了可读性和可维护性。我们还可以对正确的请求，异常的请求进行包装，假设返回的格式是这样的： # 请求失败\r{\rstatus: 1,\rmessage: string,\r}\r# 请求成功\r{\rstatus: 0,\rmessage: '请求成功',\rdata: any\r}\r 可以利用 AOP 的思想去做这件事。全局捕获错误的切片层去处理所有的 exception，如果是一个成功的请求，需要把这个返回结果通过一个切片层包装一下。 在 NestJs 中，Exception Filter 是最后捕获 exception的机会。我们把它作为处理全局错误的切片层。$ nest g f section/errors @Catch()\rexport class ExceptionsFilter implements ExceptionFilter {\rasync catch(exception, host: ArgumentsHost) {\rconst ctx = host.switchToHttp()\rconst response = ctx.getResponse()\rconst request = ctx.getRequest()\rlet message = exception.message\rlet isDeepestMessage = false\rwhile (!isDeepestMessage) {\risDeepestMessage = !message.message\rmessage = isDeepestMessage ? message : message.message\r}\rconst errorResponse = {\rmessage: message || '请求失败',\rstatus: 1,\r}\rconst status = exception instanceof HttpException ?\rexception.getStatus() :\rHttpStatus.INTERNAL_SERVER_ERROR\rresponse.status(status)\rresponse.header('Content-Type', 'application/json; charset=utf-8')\rresponse.send(errorResponse)\r}\r}\r 而 Interceptor 则负责对成功请求结果进行包装：$ new g in section/transform interface Response\u003cT\u003e {\rdata: T\r}\r@Injectable()\rexport class TransformInterceptor\u003cT\u003e\rimplements NestInterceptor\u003cT, Response\u003cT\u003e\u003e {\rintercept(\rcontext: ExecutionContext,\rnext: CallHandler,\r): Observable\u003cResponse\u003cT\u003e\u003e {\rreturn next.handle().pipe(\rmap(rawData =\u003e {\rreturn {\rdata: rawData,\rstatus: 0,\rmessage: '请求成功',\r}\r}\r)\r)\r}\r}\r 将 Interceptor, Exception Filter 和 Pipe 定义在全局范围内: app.useGlobalFilters(new ExceptionsFilter());\rapp.useGlobalInterceptors(new TransformInterceptor());\rapp.useGlobalPipes(new ValidationPipe());\r $ npm run start 打开 http://localhost:3000/docs, 测试 api 结果正如我们预期的那样。 附：源码地址 参考资料 DI(依赖注入) NestJS 官方文档 TypeORM 官方文档 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:3:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["coding"],"content":"本文实践较多，建议跟着文章的步骤敲一遍代码以加深理解。 \r","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:0:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"1. 使用帮助 $ git help 可以查看 git 常用命令 $ git help -a 可以查看 git 所有命令，F 或者 空格 向下查看命令，B 向上查看命令，Q 退出 git-cli $ git help add help后接一个指令可以查看该指令的详细用法 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:1:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"2. git 配置范围 git 配置分为三个范围 system, global 和 项目范围 一般选择global进行配置 $ git config --global user.name '111hunter' $ git config --list 查看当前配置信息 $ git config --unset --global user.name 取消 user.name 配置 配置文件是当前用户主目录 $ cat ~/.gitconfig ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:2:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"3. git 项目文件 $ mkdir movietalk \u0026\u0026 cd movietalk 新建文件夹 $ git init 初始化项目 $ cd .git \u0026\u0026 ls -a config 目录就是项目级别的配置 $ cd .. \u0026\u0026 touch index.html 新建文件 $ vim index.html 编辑文件后保存 $ git add . 提交所有文件到暂存区 $ git commit -m \"first commit\" 暂存区文件提交仓库区 $ git log 查看提交日志信息 $ vim index.html 将index.html中 charset=\"UTF-8” 改为 charset=\"GBK” $ git status 查看文件状态 $ git diff index.html 查看暂存区文件与本地工作区的对比 $ git diff --staged 查看仓库区与暂存区对比，此时一致 $ git add . 然后 $ git diff index.html 此时没有区别了，因为已将文件提交暂存区 $ vim index.html 再次修改，在文件中新增适应移动端的 meta 标签 $ git diff --staged 查看仓库区与暂存区对比 $ git commit -m \"修改了charset属性\" 暂存区提交仓库 $ git diff --staged 此时暂存区与仓库一致 $ git log 查看提交日志信息, 此时有两条提交信息 $ git status 查看文件状态 $ git add . \u0026\u0026 git commit -m \"新增meta标签\" 工作区文件提交到仓库 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"重命名 git 已跟踪文件 $ touch style.css \u0026\u0026 vim style.css 新建css文件 $ mv style.css theme.css 修改文件名 $ git status 查看文件状态 $ git rm style.css \u0026\u0026 git add theme.css 就能修改文件名字 $ git commit -m \"mv style.css theme.css\" 上传仓库区 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:1","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"git 移动文件 $ git mv theme.css aha.css 移动文件，重命名 $ mkdir css \u0026\u0026 git status git 不会跟踪空文件 $ git mv aha.css /css 移动文件 $ git commit -m \"move aha.css\" 上传仓库区 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:2","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"git 删除文件与恢复 $ git rm index.html 从工作区与暂存区中删除index.html $ git checkout HEAD -- index.html HEAD 指针指向最近一次提交， – 表示当前分支，将index.html恢复到当前 commit 的状态 $ git rm index.html \u0026\u0026 git commit -m \"删除了index.html\" 从工作区与暂存区中删除index.html, 并提交仓库 $ git checkout \"HEAD^\" -- index.html 恢复到上一次提交，windows cmd 中 ^ 会被当做换行处理，需要加上引号 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:3","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"git 恢复某个操作状态 在 css 文件夹引入 bootstrap vim index.html 在 index.html 中引入 bootstrap git commit -am \"增加了bootstrap\" 提交仓库 新建 js 文件夹并引入 jquery vim index.html 在 index.html 中引入 jquery git commit -am \"增加了jquery\" 提交仓库 git log --oneline 查看提交日志 id, 添加 bootstrap 的 id 为 981eb52 git revert 981eb52 撤销对 bootstrap 的提交，查看工作区文件夹发现 index.html 对 bootstrap 的引入消失了 每次 git commit 后 HEAD 都会指向最后一次提交，用 git reset 可以帮助回到某次提交时的状态，有 3 个可选配置参数: –mixed, –soft, –hard –soft 软重置，不会修改任何文件状态。该参数用于git commit后，又要恢复还没commit的场景，重新审查代码，然后再推上去覆盖之后的提交。 $ git log --oneline 查看添加 jquery 的 id 为 e9ae8b5，Revert “添加了bootstrap\"的 id 为 3e3da01 $ git reset --soft e9ae8b5 回到提交 jquey 的 commit，但是不会对文件做任何操作 $ git status 会提示 撤销 bootstrap 时的消息 默认是 –mixed, 只影响暂存区文件状态 $ git reset --mixed e9ae8b5 \u0026\u0026 git status 发现 bootstrap 已经不在暂存区了 –hard 会直接重置暂存区和工作区文件到指定 id 状态，用 git reset –hard 可直接在不同提交状态切换。 $ git reset --hard e9ae8b5 \u0026\u0026 git log --oneline 查看工作区文件发现 bootstrap又回来了 $ git reset --hard 3e3da01 \u0026\u0026 git log --oneline 文件又到了最后一次提交时的状态 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:4","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"4. git 项目分支 $ git branch testing \u0026\u0026 git checkout testing 新建并切换分支，此时对文件的修改只影响 branch 分支 $ vim index.html 在 index.html 中引入 link 标签 $ git commit -am \"添加link标签\" 提交仓库区 $ git checkout master 切换回 master 分支，查看工作区文件发现对文件的修改没有了 $ git diff master..testing index.html 查看分支间的文件对比 $ git merge testing 分支合并 $ git diff master..testing 没有不同，已经合并了分支 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"解决分支合并冲突 $ vim index.html 修改 document 为 Movietalk $ git commit -am \"修改标题为Movietalk\" 提交仓库区 $ git checkout testing \u0026\u0026 vim index.html 切换分支，修改 document 为 Movie-talk $ git commit -am \"修改标题为Movie-talk\" 提交仓库区 $ git merge master 产生冲突。git 发现冲突，查看文件会有提示，编辑保留其中一个 document 修改 $ git commit -am \"解决冲突\" 提交 $ git log --oneline --all -10 --graph 查看所有分支提交信息 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:1","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"保存当前工作状态 git stash 指令能够保存当前工作状态到 git 栈 $ touch human.txt \u0026\u0026 git commit -am \"add human.txt\" 新建空文件 $ vim human.txt 加入任意内容 $ git status 查看修改，不提交 $ git stash save \"修改了human.txt\" 保存工作进度，查看文件 human.txt 又变成了空文件 $ git stash list 查看工作进度 $ git stash show -p stash@{0} 以补丁的方式查看工作进度与工作目录的区别 $ git stash apply stash@{0} 切换到之前的工作进度，发现对 human.txt 的修改又生效了 $ git stash pop 切换栈顶工作状态 $ git stash drop stash@{0} 删除工作状态 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:2","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"5. git 远程仓库 新建远程仓库后请清空仓库，不要保留任何文件 $ git remote add origin https://gitee.com/hunter_111/movietalk.git 关联远程仓库 $ git remote -v 查看是否关联, fetch 远程用来提取，push 远程用来推送 $ git push -u origin master 推送到远程分支，并跟踪远程分支变化 $ git push origin testing 推送远程分支，不跟踪变化 参考资料 廖雪峰的 git 教程 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:5:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["coding"],"content":"本次实践将不使用框架，尝试直接使用 Node.js 处理 http 请求，连接数据库，创建 api 接口。以及介绍一些 web 开发相关的常识。 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:0:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"搭建开发环境 使用 nodemon 监测文件变化，自动重启 node 使用 cross-env 设置环境变量，兼容Mac Linux 和 Windows 配置完后使用 $ npm run dev 命令启动项目 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:1:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"Node.js 处理 get，post 请求 const http = require('http')\rconst querystring = require('querystring')\rconst server = http.createServer((req, res) =\u003e {\rconst method = req.method\rconst url = req.url\rconst path = url.split('?')[0] //重点：split('?'[0])语法弄清楚\r const query = querystring.parse(url.split('?')[1])\r//设置返回值格式为 JSON\r res.setHeader('Content-type', 'application/json') //返回的数据\r const resData = {\rmethod,\rurl,\rpath,\rquery\r}\r//返回\r if (method === 'GET') {\rres.end(\rJSON.stringify(req.query)\r)\r} if (req.method === 'POST'){\rlet postData = ''\r//res.on('data')指每次发送的数据\r //chunk 逐步接收数据 req绑定一个data方法 chunk是变量\r req.on('data', chunk =\u003e {\rpostData += chunk.toString()\r})\r//req.on(end)数据发送完成；\r req.on('end', () =\u003e {\rconsole.log('postData:', postData)\rconsole.log('resData:', resData)\rresData.postData = postData\r//返回\r res.end(\rJSON.stringify(resData)\r)\r})\r}\r})\rserver.listen(8000)\rconsole.log('OK')\r https://github.com/username/xxx 每个斜线后面的唯一标识就是路由 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:2:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"接口设计方案 描述 接口 方法 url参数 备注 获取博客列表 /api/blog/list get author，keyword 参数为空则不进行查询过滤 获取一篇博客 /api/blog/detail get id 新增一篇博客 /api/blog/new post postData 有新增信息 更新一篇博客 /api/blog/update post id postData 有更新信息 删除一篇博客 /api/blog/del post id 登录 /api/user/login post postData 有用户名和密码 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:3:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"开发路由 业务分层 拆分业务 createServer 业务单独放在 ./bin/www.js 系统基本设置、基本信息 app.js 放在根目录 路由功能 ./src/router/xxx.js 数据管理 ./src/contoller/xxx.js 使用 promise 读取文件，避免 callback-hell ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:4:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"使用MySQL数据库 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:5:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"根据需求设计表 users： id username password realname 1 zhangsan admin 张三 2 lisi 123 李四 blogs： id title content createtime author 1 标题A 内容A 1573989043149 zhangsan 2 标题B 内容B 1573989111301 lisi ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:5:1","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"用 Node.js 操作 MySQL 示例：文件 mysql-test/index.js 演示 Node.js 操作 MySQL 封装：将其封装为系统可用的工具, 封装 exec 函数 使用：路由 api/user/xxx，api/blog/xxx 对接 MySQL ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:6:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"用户登录 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:7:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"Cookie 什么是 Cookie 存储在浏览器的字符串（最大5KB） 跨域不共享 格式如 K1=V1;K2=V3;K3=V3; 因此可以存储结构化数据 每次发送 Http 请求，会将请求域的 Cookie 一起发送给 Server Server 可以修改 Cookie 并返回给浏览器 浏览器也可以通过 JavaScript 修改 Cookie （有限制） Server 端操作 Cookie，实现登录验证 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:7:1","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"Session Cookie 存放用户信息非常危险 如何解决：cookie 中存储 userId， server 端对应 username 解决方案：session ，即 server 端储存用户信息 直接在代码中使用 session 的问题 session 是 JS 变量，放在 Node.js 进程内存中 进程内存有限，访问量过大，内存暴增 正式上线是多进程，进程之间内存无法共享 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:7:2","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"在 Redis 中存储 Session Web Server 最常用的缓存数据库，数据储存在内存中 相比于 MySQL，访问速度极快，成本更高，储存空间小 将 Web Server 和 Redis 拆分为两个单独服务，双方独立，可扩展 示例：文件 redis-test/index.js 演示 Node.js 操作 Redis 封装：将其封装为系统可用的工具, 封装 set, get 函数 使用：路由 api/user/xxx 对接 Redis ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:8:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"Nginx 反向代理前后端联调 登录依赖 Cookie，必须用浏览器 Cookie 跨域不共享，前端和 server 端必须同域 需要用到 Nginx 做代理，让前后端共域，实现前后端联调 开发前端界面：文件夹 html-test 包含用户登录，博客管理界面 启动服务： $ cd html-test $ npm i http-server -g $ http-server -p 8001 修改 nginx 配置: ..\\nginx-1.12.2\\conf\\nginx.conf worker_processes auto;\rlisten 8080;\r# location / {\r# root html;\r# index index.html index.htm;\r# }\rlocation / {\rproxy_pass http://localhost:8001;\r}\rlocation /api/ {\rproxy_pass http://localhost:8000;\rproxy_set_header Host $host;\r}\r 启动 nginx: $ start nginx ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:9:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"Web 安全 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:10:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"常见安全问题 SQL 注入：窃取数据库内容 XSS攻击：窃取前端的 Cookie 内容 密码加密：保障用户信息安全（重要） Server 端攻击方式很多，预防手段也很多 有些攻击需要硬件和服务来支持（需要 OP 支持），如 DDOS ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:10:1","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"SQL 注入 最原始、最简单的攻击，从有了 Web2.0 就有了 SQL 注入攻击 攻击方式：输入一个 SQL 片段，最终拼接成一段攻击代码 解决方案：使用 MySQL　的 escape 函数处理输入数据内容 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:10:2","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"XSS 攻击 前端同学熟知的攻击方式，但 Server 端更应该掌握 攻击方式：在页面展示内容中参杂 JS 代码，以获取网页信息 解决方案：在文件夹 blog-1 中安装 xss 库： npm i xss ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:10:3","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"密码加密 万一数据库被攻破，避免泄露用户信息 攻击方式：获取用户名和密码，再去尝试登录其它系统 解决方案：密码加密，密文储存，MD5加密 附：源码地址 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:10:4","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["coding"],"content":"扫雷是一款大众类的益智小游戏,于1992年发行。游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子,同时避免踩雷,踩到一个雷即全盘皆输。 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:0:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["coding"],"content":"游戏规则 \r在写扫雷之前，我们先了解下它的游戏规则： 扫雷是一个矩阵，地雷随机分布在其中的方格里。 方格上的数字代表着这个方格所在的九宫格内有多少个地雷。 游戏玩家用鼠标左键打开方格，用鼠标右键标记地雷。 踩到地雷，游戏失败。打开所有非雷方格，游戏胜利。 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:1:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["coding"],"content":"功能实现 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["coding"],"content":"矩阵的生成 用 html 中的表格 table，span 生成矩阵方格。把矩阵方格放入二维数组中，然后对单个方格添加鼠标事件。 //初始化矩阵 (row-行数 col-列数)\rfunction init_grid() {\r//生成矩阵html \u003ctr\u003e--行标签 \u003ctd\u003e--列标签\r let gridHtml = '';\rfor (let i = 0; i \u003c row; i++) {\rgridHtml += '\u003ctr\u003e'\rfor (let j = 0; j \u003c col; j++) {\rgridHtml += '\u003ctd\u003e\u003cspan class=\"blocks\" onmousedown=\"block_click(' + i + ',' + j + ',event)\"\u003e\u003c/span\u003e\u003c/td\u003e';\r}\rgridHtml += '\u003ctr\u003e'\r}\r//写入html\r document.getElementById('grid').innerHTML = gridHtml;\r//返回矩阵二维数组\r let blocks = document.getElementsByClassName('blocks');\rlet grid = new Array();\rfor (let i = 0; i \u003c blocks.length; i++) {\rif (i % col === 0) {\rgrid.push(new Array());\r}\r//初始化计雷数\r blocks[i].count = 0;\rgrid[parseInt(i / col)].push(blocks[i]);\r}\rreturn grid;\r}\r ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:1","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["coding"],"content":"方格打开与标记 通过 onmousedown 事件，传入点击的方格的坐标及event，判断event为左键还是右键。左键打开方格，右键标记方格。 //方格点击事件 _i：坐标i _j:坐标j e:鼠标事件\rfunction block_click(_i, _j, e) {\r//跳过已打开的方格\r if (grid[_i][_j].isOpen) {\rreturn;\r}\r//鼠标左键打开方格\r if (e.button === 0) {\r...\r//执行递归打开方格函数\r block_open(_i, _j);\r}\r//鼠标右键标记方格\r else if (e.button === 2) {\rlet block = grid[_i][_j];\rif (block.innerHTML !== '▲') {\rblock.innerHTML = '▲';\r} else {\rblock.innerHTML = '';\r}\r}\r}\r ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:2","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["coding"],"content":"地雷随机分布 第一次打开的方格不能为地雷，把生成地雷的函数放在第一次点击方格后。 通过循环用 Math.random() 函数来随机生成地雷的二维坐标。 判断坐标是否不为第一次点击方格的坐标以及该坐标没有雷存在。 是则将方格设置为地雷，当前地雷数+1，将该方格所在九宫格内的方格的计雷数+1。 否则跳过进入下个循环，直到地雷的数量达到设定的最大雷数，结束循环。 //方格点击事件 _i：坐标i _j:坐标j e:鼠标事件\rfunction block_click(_i, _j, e) {\r//跳过已打开的方格\r if (grid[_i][_j].isOpen) {\rreturn;\r}\r//鼠标左键打开方格\r if (e.button === 0) {\r//第一次打开\r if (isFirstOpen) {\risFirstOpen = false;\rlet count = 0; //当前地雷数\r //生成地雷\r while (count \u003c maxCount) {\r//生成随机坐标\r let ri = Math.floor(Math.random() * row);\rlet rj = Math.floor(Math.random() * col);\r//坐标不等于第一次点击方格的坐标 \u0026\u0026 非雷方格\r if (! (ri === _i \u0026\u0026 rj === _j) \u0026\u0026 !grid[ri][rj].isMine) {\rgrid[ri][rj].isMine = true; //自定义属性isMine代表方格为地雷\r count++; //当前地雷数+1\r //更新九宫格内非雷方格的计雷数\r for (let i = ri - 1; i \u003c ri + 2; i++) {\rfor (let j = rj - 1; j \u003c rj + 2; j++) {\r//判断坐标防越界\r if (i \u003e -1 \u0026\u0026 j \u003e -1 \u0026\u0026 i \u003c row \u0026\u0026 j \u003c col) {\r//计雷数+1\r grid[i][j].count++;\r}\r}\r}\r}\r}\r}\r//执行打开方格函数\r block_open(_i, _j);\r}\r}\r ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:3","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["coding"],"content":"递归打开方格 当打开的方格为计雷数为0的方格，自动打开九宫格内的非雷方格。如果打开的非雷方格九宫格内仍有非雷方格，用递归继续打开九宫格内的非雷方格，直到没有为止。 //递归打开方格函数\rfunction block_open(_i, _j) {\rlet block = grid[_i][_j];\rop(block);\r//设定打开方格的状态与样式\r function op(block) {\rblock.isOpen = true; //isOpen为自定义属性，设置为true代表已打开\r block.style.background = '#ccc'; //将背景设置为灰色\r block.style.cursor = 'default'; //将鼠标停留样式设置为默认\r }\r//打开计雷数为0的方格\r if (block.count === 0) {\r//遍历九宫格内的方格\r for (let i = _i - 1; i \u003c _i + 2; i++) {\rfor (let j = _j - 1; j \u003c _j + 2; j++) {\r//判断是否越界\u0026\u0026跳过已打开的方格\u0026\u0026非雷\r if (i \u003e -1 \u0026\u0026 j \u003e -1 \u0026\u0026 i \u003c row \u0026\u0026 j \u003c col \u0026\u0026 !grid[i][j].isOpen \u0026\u0026 !grid[i][j].ismine) {\r//递归打开方格函数\r block_open(i, j);\r}\r}\r}\r} // 踩雷\r else if (block.isMine) {\r...\r} //打开计雷数不为0的方格\r else {\rblock.innerHTML = block.count; //显示计雷数\r }\r}\r ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:4","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["coding"],"content":"踩雷游戏结束 打开方格为地雷时，提示游戏结束。通过遍历矩阵打开所有埋地雷位置。 else if (block.isMine) {\rblock.innerHTML = '雷'; //显示为 '雷'\r //遍历矩阵打开所有埋地雷的方格\r for (let i = 0; i \u003c row; i++) {\rfor (let j = 0; j \u003c col; j++) {\r//找到地雷\r block = grid[i][j];\rif (!block.isOpen \u0026\u0026 block.isMine) {\rop(block); //设置打开状态和样式\r block.innerHTML = '雷'; //显示为 '雷'\r }\r}\r}\rclearInterval(timer); //游戏结束停止计时，清除定时器\r //提示游戏结束\r alert(\"你踩到雷了！游戏结束\");\r}\r ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:5","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["coding"],"content":"游戏胜利条件 当所有非雷方格被打开即为游戏胜利。在每次打开方格函数中都遍历一遍矩阵，当找到有未打开的非雷方格时则退出遍历，遍历完所有方格均未找到未打开的非雷方格时则游戏胜利。 //方块点击事件 _i：坐标i _j:坐标j e:鼠标事件\rfunction block_click(_i, _j, e) {\r//跳过已打开的方块\r if (grid[_i][_j].isOpen) {\r//...\r }\r//鼠标左键打开方块\r if (e.button === 0) {\r//...\r }\r//鼠标右键标记方块\r else if (e.button === 2) {\r//...\r }\r//遍历矩阵\r let isWin = true;\rfor (let i = 0; i \u003c row; i++) {\rfor (let j = 0; j \u003c col; j++) {\rlet block = grid[i][j];\r//如果有未打开的非雷方块\r if (!block.isMine \u0026\u0026 !block.isOpen) {\risWin = false;\r}\r}\r}\rif (isWin) {\ralert(\"游戏胜利\");\r}\r}\r 游戏逻辑部分到这里就结束了，剩余雷数和计时可用全局变量实现。 附：源码地址 参考资料 原生 JS 实现扫雷 (分析+代码实现) ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:6","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["coding"],"content":"ECMAScript 6(以下简称ES6)是 JavaScript 语言的下一代标准,已经在2015年6月正式发布了。Mozilla公司将在这个标准的基础上,推出 JavaScript 2.0。ECMAScript 和 JavaScript 是什么关系？简单来说，ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:0:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"let和const var 函数作用域function scope,不在函数内时作用域是全局的 用let和const声明变量, let, const 块级作用域block scope,作用域是{}内 eg.执行以下语句判断区别： for (var i = 0; i \u003c 10; i++) {\rconsole.log(i);\rsetTimeout(function () {\rconsole.log(`i:${i}`);\r}, 1000)\r}\rfor (let i = 0; i \u003c 10; i++) {\rconsole.log(i);\rsetTimeout(function () {\rconsole.log(`i:${i}`);\r}, 1000)\r}\r let, const不能重复声明变量值 let声明的变量是可以重新赋值的, const声明的变量只能修改引用类型的属性值 变量提升：let, count有变量提升,未声明先使用存在临时性死区(Temporal dead zone),详见mdn ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:1:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"箭头函数 特点：简明的语法,隐式返回(省去return关键字),匿名函数 this:普通函数this是动态绑定的 const Jelly = {\rname: 'Jelly',\rhobbies: ['Coding', 'Sleeping', 'Reading'],\rprintHobbies: function () {\r// console.log(this);\r this.hobbies.map(function (hobby) {\r// console.log(this);\r console.log(`${this.name}loves ${hobby}`);\r})\r}\r}\rJelly.printHobbies(); map中的回调函数是一个独立的函数,不作为对象的方法,并且没有通过call bind apply 来改变里面的this，this指向window,严格模式下指向undefined const Jelly = {\rname: 'Jelly',\rhobbies: ['Coding', 'Sleeping', 'Reading'],\rprintHobbies: function () {\r// console.log(this);\r var self = this;\rthis.hobbies.map(function (hobby) {\r// console.log(this);\r console.log(`${self.name}loves ${hobby}`);\r})\r}\r}\rJelly.printHobbies();\r 箭头函数的this值继承父作用域,是词法作用域,定义的时候就指向明确,且不会绑定this： const Jelly = {\rname: 'Jelly',\rhobbies: ['Coding', 'Sleeping', 'Reading'],\rprintHobbies: function () {\r// console.log(this);\r this.hobbies.map(hobby =\u003e {\r// console.log(this);\r console.log(`${this.name}loves ${hobby}`);\r})\r}\r}\rJelly.printHobbies();\r 命名函数在递归,事件绑定时有用,在箭头函数中使用： const greet = name =\u003e {alert(`Hello ${name}`)}; 箭头函数不适用的情况： 需要使用this慎用 需要使用arguments(箭头函数没有arguments) ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:2:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"模板字符串 模板字符串中的换行和空格都是会被保留的。 模板字符串可嵌套,支持三元表达式。 标签模板字符串,是一个函数的调用。 alert`Hello world!`;\r// 等价于alert('Hello world!');\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:3:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"解构赋值 针对数组或者对象进行模式匹配,然后对其中的变量进行赋值。 是对赋值运算符的扩展,方便提取对象属性值,可嵌套可忽略。 let [a, b, c, d, e] = 'hello';\rlet obj = {p: ['hello', {y: 'world'}] };\rlet {p: [x, { y }] } = obj;\r// x = 'hello'\r// y = 'world'\rlet obj = {p: ['hello', {y: 'world'}] };\rlet {p: [x, { }] } = obj;\r// x = 'hello'\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:4:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"计算属性 对象字面定义属性名位置的 [ ] 中可以放置任意合法表达式。 const keys = ['name', 'age', 'birthday']\rconst values = ['jelly', 18, '2016-01']\rconst Laravist = {\r[keys.shift()]: values.shift(),\r[keys.shift()]: values.shift(),\r[keys.shift()]: values.shift(),\r}\rconsole.log(Laravist);\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:5:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"Symbol ES6引入了一种新的原始数据类型表示独一无二的值,最大的用法是用来定义对象的唯一属性名。 用于生成唯一标识符避免命名冲突,可作为私有属性在对象内部使用,不能for循环遍历 const classRoom = {\r[Symbol('lily')]: { grade: 60, gender: 'female' },\r[Symbol('nina')]: { grade: 70, gender: 'female' },\r[Symbol('nina')]: { grade: 90, gender: 'female' },\r}\rconst syms = Object.getOwnPropertySymbols(classRoom).map(sym =\u003e classRoom[sym]);\rconsole.log(syms);\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:6:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"剩余参数 const player = ['jelly', 123, 2.4, 3.6, 1.7]\rconst [name, id, ...scores] = player;\rconsole.log(name, id, scores);\r 扩展运算符可以将可遍历对象元素扩展成新的参数序列,而不用改变原来的对象 const younger = ['aaa', 'bbb', 'ccc'];\rconst older = ['xxx', 'yyy', 'zzz'];\rconst members = [...younger, 'ddd', ...older];\rconst newmembers = members;\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:7:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"Promise Promise用于避免回调地狱 const p = new Promise((resolve, reject) =\u003e {\rsetTimeout(() =\u003e {\rreject(Error('Laravist isn\\'t awesome!'));\r}, 2000);\r})\rp.then(data =\u003e { console.log(data) })\r.catch(err =\u003e { console.error(err) });\r await操作符用于等待一个Promise对象,它只能在异步函数async function内部使用。 await针对所跟不同表达式的处理方式： Promise对象：await 会暂停执行,等待Promise对象resolve,然后恢复async函数的执行并返回解析值。 非Promise对象：直接返回对应的值。 function testAwait(x) {\rreturn new Promise(resolve =\u003e {\rsetTimeout(() =\u003e {\rresolve(x);\r}, 2000);\r});\r}\rasync function helloAsync() {\rvar x = await testAwait(\"hello world\");\rconsole.log(x);\r}\rhelloAsync();\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:8:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"Class class是语法糖,本质是funciton,没有变量提升 一个继承的例子: function MyArray() {\rArray.apply(this, arguments);\r}\rconst colors = new MyArray();\rcolors[0] = 'red';\rconsole.log(colors.length); //undefined\rcolors.length = 0;\rconsole.log(colors[0]); //red\r ES5 是先新建子类的实例对象this, 再将父类的属性添加到子类上,原生构造函数会忽略apply方法传入的this, 父类的内部属性无法获取,导致无法继承原生的构造函数。 class MyArray extends Array {\rconstructor() {\rsuper();\rconsole.log(this);\r}\r}\rconst colors = new MyArray();\rcolors[0] = 'red';\rconsole.log(colors.length); // 1\rcolors.length = 0;\rconsole.log(colors[0]); // undefined\r ES6 允许继承原生构造函数定义的子类,因为ES6是先新建父类的实例对象this, 然后再用子类的构造函数修饰this,使得父类的素有行为都可以继承。 ES6 可以自定义原生数据结构的子类，这是 ES5 无法做到的。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:9:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"一些补充 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"新增for…of循环： 先回顾js中for循环的几种写法 const fruits = ['apple', 'banana', 'orange', 'mango'];\rfor (let i = 0; i \u003c fruits.length; i++) {\rconsole.log(fruits[i]);\r}\r 可读性不是很好 fruits.forEach(fruit =\u003e {\rconsole.log(fruit);\r})\r 不能在循环中break或continue for (let index in fruits) {\rconsole.log(fruits[index]);\r}\r 会遍历对象上所有可枚举属性 for (let fruit of fruits) {\rconsole.log(fruit);\r}\r 不会遍历数组中非数字属性,能够break或continue 应用数组解构语法 for (let [index, fruit] of fruits.entries()) {\rconsole.log(`${fruit}rank in ${index + 1}in my favorite fruits`);\r}\r for…of可以应用于可迭代对象(部署了iterator接口或提供Symbol.iterator方法的数据结构) 数组,字符串,arguments,NodeList,map.set等,但不支持对象 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:1","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"Array.from()和Array.of() es6新增数组方法Array.from()和Array.of()： 注意是数组原型对象上的静态方法 Array.from()用于把可迭代对象转化成数组,Array.of()传入参数生成数组 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:2","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"Proxy与Reflect Proxy与Reflect是ES6为了操作对象引入的 API 。 Proxy 可以对目标对象的读取、函数调用等操作进行拦截,然后进行操作处理。它不直接操作对象,而是像代理模式,通过对象的代理对象进行操作。 ES6中将Object的一些明显属于语言内部的方法移植到了Reflect对象上。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:3","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"迭代器与生成器 Iterator是ES6引入的一种新的遍历机制,通过一个键为Symbol.iterator的方法来实现。 Generator函数:在function后面,函数名之前有个*,函数内部有yield表达式。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:4","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"Map与Set Object的键只能是字符串或者Symbols, Map的键可以是任意值,Map中的键值是有序的(FIFO原则),Map的键值对个数可以从size属性获取。 Set对象允许你存储任何类型的唯一值,NaN与NaN是不恒等的,但是在Set中只能存一个。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:5","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["coding"],"content":"闭包就是能够读取其他函数内部变量的函数。在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成\"定义在一个函数内部的函数”。闭包是将函数内部和函数外部连接起来的桥梁，实现了变量的私有化问题。 有如下例子，我们想要用一个counter记录add函数的执行次数。 function add() {\rvar counter = 0; //局部变量\r counter++;\rconsole.log(\"counter = \" + counter);\r}\radd(); // counter = 1\radd(); // counter = 1\r 由于counter是局部变量，每次我们执行add()函数，都是输出 counter = 1; 我们想要执行函数时改变counter的值，一种可行的办法是： var counter = 0; //全局变量，谁都可以访问，修改\rfunction add() {\rcounter++;\rconsole.log(\"counter = \" + counter);\r}\radd(); // counter = 1\radd(); // counter = 2\r 但是这样会带来问题，由于counter是全局变量，我们可能会在函数外不小心改变了counter的值， 比如在函数外写了一句counter = -100；就打乱了我们原来的计数，显然我们并不希望在函数外任意地改变counter的值。 我们可以这样写： function add() {\rvar counter = 1; //局部变量\r console.log(\"counter = \" + counter);\rplus = function() { //全局函数\r counter++; console.log(\"counter = \" + counter);\r}\r}\radd(); //counter = 1 counter初始化\rplus(); //counter = 2\r 这样我们就无法在函数外任意改变counter了，进一步的写法是： function add() {\rvar counter = 1; //局部变量\r console.log(\"counter = \" + counter);\rvar plus = function() { //局部函数\r counter++; console.log(\"counter = \" + counter);\r};\rreturn plus;\r}\rvar plus1 = add(); // counter = 1\rplus1(); // counter = 2\r plus函数名有些多余，add可以简化为立即执行函数。 var plus1 = (function add() {\rvar counter = 0; //局部变量\r return function() { //全局函数\r counter++; console.log(\"counter = \" + counter);\r};\r})();\rplus1(); // counter = 1\rplus1(); // counter = 2\r 发现add函数名也可以去掉了，简化为匿名函数，如下就是闭包的一般写法： var plus1 = (function() {\rvar counter = 0; //局部变量\r return function() { counter++; console.log(\"counter = \" + counter);\r};\r})();\rplus1(); // counter = 1\rplus1(); // counter = 2\r 闭包实现了变量私有化，局部变量的本质，全局变量的生命周期。 ","date":"2019-10-07","objectID":"/2019-10-17-js-basis/:0:0","tags":["JavaScript"],"title":"JS 闭包写法的演变过程","uri":"/2019-10-17-js-basis/"},{"categories":null,"content":"关于网站 个人博客，记录所学所思 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于我  喜欢编程，音乐和阅读。  拖延症患者。  种一颗树的最好时间是十年前，其次是现在。 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于版权 本站所有原创文章均受 创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0 保护。 任何个人及媒体在转载本站原创内容 (包含文字、图像、摄影作品等) 时请遵守以下版权要求： 注明转载 注明来源为本站首页网址，或所转内容在本站的完整网址 ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"}]