[{"categories":["Thinking"],"content":" 无名，天地之始。有名，万物之母。 —《道德经》 容我慎重地提醒你生与死是至高无上的。时光匆匆，机会转瞬即逝。我们每个人都应努力觉醒。觉醒。谨慎，不要浪费你的生命。人类已经深入物质领域，扎根于我们存在的精神与物质层面。如同卡尔荣格所说：“想要接触天堂，必须深入地狱”。从巴比伦的熔炉中浮出来的，是形象的彻底转变和新的人类潜能。东方的传统中说，觉醒的莲花出自轮回的迂泥，出离自苦。基督教则描述了伊甸园的没落。用很深奥的术语来说的话，这是一种独立于上帝旨意的个人自我或个人意志的创造。 伴随着这个分裂的自我，一个外在思想世界跟着出现。一个似乎与这个有限的自我分裂的形式世界。角色，或是小我（ego），是由我们的思想从投射出来的外在世界追求各种事物的模式所构成的。我们所渴求的外在事物是善恶的知识树，或二元对立树的果实。你可以说原罪是小我或二元意识的欲望。这就是幻象（maya），人类现在所处的境地。追求外在的果实意味着错过目标，错过当下。 从历史上看，人类意识偶尔会出现罕见的觉醒。圣人、瑜伽士、贤者和智慧的守护者。但是人类现在有了一个独特的机会，可以集体进行这次旅程；因为我们重新发现了更高的世界，并从受限自我的集体梦境中醒来，去展望和共创共享新的现实。 绝大多数人目前的生活，几乎完全认同于他们所存在的，粗略的身体和心理层面，完全不知道更高层次的存在。大多数人不知道，或怀疑他们的自我结构中，潜藏着灵性的能力，等待被启发。透过实现这些能力，我们可以连接到更微妙的存在层次，同时使自我结构渗透到我们的真实本性中；而不去认同所有层次的心智或幻象。如果我们检视历史上始终存在的灵性传统，我们会发现伟大的贤者、神秘主义者和先知都描述了一个连续的存在。 古老的吠陀教义描述了灵魂的五个能层（kosha），从粗糙的身体和精神领域，也就是大多数人今天生活在其中的受制约的世界，延伸到精微领域，包括充满活力的星光体和更高的精神领域，也就是实存的角色原型样板。最后到达没有思想或感觉的因果（causal）领域。原始意识的实现，灵魂内神识的觉醒，驱散了所有这些领域——所有幻象的层次。古老的传统包含许多概念和语言框架，指向从粗略到微妙到因果的连续统一体。无论是吠陀传统的脉轮系统或能层系统，还是道教的丹田，所有变化场域内的各个层次都是幻象；掩盖我们真实本性的螺旋却也是生命本身的展现。正是透过生命的螺旋，我们才能体验人类的生活。当我们意识到所有层次的幻象都是自性空的时候，就有可能体验到一种深不可测的非二元性或一种言语道断的神秘结合，包含并超越所有其他层次。 亨利·大卫·梭罗有句名言，大多数人过着平静的绝望生活。他们带着自己的歌声走进坟墓。他们的绝望来自于对自己无止境的探索。对「物」的追求；金钱、权力、人际关系、他人的认可。苦的根源在于对事物的执着心，而不是事物本身。你拥有什么不重要，重要的是你对你所拥有的东西的执着。 我们透过神经可塑性在感官层面形成依恋与执着。无论注意力在哪里，神经元都会激发并连接在一起，在脑中建立一个程序；一种倾向的模式，这模式也就是头脑本身。当我们有任何无意识的倾向或生活模式时，我们实际上并没有沉迷于事物本身。我们并非沉迷于毒品、酒精、性、食物或媒体，而是沉迷于它们在我们体内产生的感觉。 透过直接观察身体，观察在意识的根本层次上，有着不断改变现象的这个场域，我们可以重新得到自由。我们保持平等心，不做反应、不去判断任何感觉的好坏。为了获得自由，我们透过将意识带入微妙的内心世界来了解这些依恋与执着是如何形成的。我们开始将心理和感官现象视为一个变化的场域，而不是执着于那些带来认同和形式世界的创造的思想和感觉。这个变化场也被称为普拉纳（Prana）或内在能量；内在活力的感觉。 对物质主义态度的转变正带领我们前往一个新的世界。我们正在目睹的是旧范式的释放，同时还有想要无休止地获得更多的病态小我想法。现在你周遭看起来像是一片黑暗，像是一片疯狂。事实上这就是在我们的地球世界中看觉醒时的样子。你正在目睹旧模式的瓦解。 许多人对当前的政治、社会、经济和宗教制度感到失望。他们不再相信与期待媒体行业和所谓的灵修系统。他们不信任医疗机构或政府。人们失望（disillusion）了。这种幻象的驱散是看到真相的必要过程；与我们所生活的这个时代固有的精神疾病面对面，并从小我意识中走出来。我所说的小我意识是指无意识地运作的渴求和瞋恨的模式；集体轮回或条件模式创造了幻象的条件——对我们的角色、社会群体或我们定义自己的任何事物的深度认同以及我们在这一生中扮演的各种形象和角色原型。 自我结构是与世界接轨的介面——我们不摆脱或破坏这个介面，而是从它那里去除认同。我们对“我”的感觉或存在感就不会被束缚在一个有限的形式上。这样我们就不会在形式世界发生变化时受苦。 人类的道路是从“前自我存在”（pre-egoic existence）也就是我们在孩提时代与母亲所经历的融合一体，到创造出一个人的旅程。我们成长，创造出一个角色。这是我们进化的必要部分。为的是产生自我意识，带来自我或“我”的感觉。我们实际上正处于发展的青春期。我们正处于自我认同阶段。但是超越自我意识的下一步，是实现自我的超个人（transpersonal）层次。实现意识的共享层次；实现不同层次的逻各斯（Logos）或更高等的心智。或者说灵魂的层次，如果你喜欢这种说法。 我们的同情范围扩大了。这是透过爱的展现。 从旧模式的小我意识来看，这种瓦解是可怕的。如果你固守旧的模式，将会感到困惑和痛苦。那些觉醒实际上会被视为一种威胁。觉醒将被视为一场危机，因为它是对已知事物的瓦解。现在我们就像茧中的毛毛虫，正在蜕变。转变的过程中有一个时间点，毛毛虫既不是毛毛虫也不是蝴蝶。此时对于正在蜕变的那个旧自己，似乎已经失去了一切。但这只是过程的一部分。信仰是对进化冲击的臣服；深知我们正在走向本源。集体错觉，古代精神导师称之为幻象（maya），与我们对旧模式的集体依恋有关。它与人类的傲慢有关；相信我们知道我们要去哪里， 我们在做什么，以及我们是谁。 法国画家保罗·高更以其题为《我们从哪里来，我们是什么，我们要去哪里？》的一幅画而闻名。这三个问题需要谦虚。为了找出真相，我们首先必须承认我们不知道真相。如果我们想找到答案，我们就没有答案。必须有一种真正的探索和审视自己的意愿。就像但丁在《神曲》中的朝圣者一样，人们开始了在黑暗森林中认识自己的旅程，误入歧途，认识到我们迷路了。 在古老的吠陀传统中，存在和生成的维度由湿婆和夏克提来代表。夏克提代表了典型的女性、向下的流动或显化的流动。透过指向下的三角形，它指向由精神到形式世界的衰退。湿婆代表向上的流动或解放的流动。向上的三角形指向没有任何特性的纯粹意识；超越形式或超越世界的进化。只要我们在二元世界中运作，认同有限的心智，这两种潮流就构成了无路可走的道路。我们在显化之流和解脱之流中工作，做与不做，居住在时间限制和永恒之中。当这两个维度在神圣的结合中结合，实现一体性时，就是三摩地。当它们结合时，它们代表了这两个维度的平衡和共存，就像大卫之星或心脉轮（Anahata）符号，它是代表精神之心的古老符号，未击中的声音，原始“唵”的超然源泉，正在将宇宙舞蹈成实存。据说在三摩地中你会听到存在的天国音乐，或者克里希那的长笛，或者毕达哥拉斯所说的“天体音乐”。当然，这些都是觉醒于你的实存生命深处的东西，超越有限的思想和感官的东西的比喻。 有一些灵修系统会透过诸如观察呼吸、气或普拉那的感觉等练习来关注身体上细微的部份，运用可以透过有限心智学习的技巧实践和过程。为了实现三摩地而直接采用有限心智的一切，都是“正面方式”（via positiva）的一部分，这就是我们所说的夏克提路径。还有一些关于超越显化世界的灵修系统，我们称之为“负面方式”（via negativa）或湿婆路径。透过放下所有我们不是的一切，我们开始意识到我们超越了名称和形式。通往三摩地的道路被赋予了许多名称，例如冥想、自我探询或祈祷。 今天修练这些东西的人，大多是在修练一些技巧，但这种通向三摩地的古老禅定，其实并不是一种活动。它不是你做或修行的事情，它实际上是禅修者、求道者或行者的止息。真正的冥想是与实相的结合，只有当小我尝试冥想失败并意识到自己的局限性时，它才会开始发生。小我，也就是你所认为的你，必须在所有冥想尝试中失败，才能实现真正的冥想。我们越接近真理，就越接近三摩地，做的越少，技巧也就越少。这些技术都是过去的一部分。我们放弃做事和做事者。我们放弃寻求和寻求者，来到无条件的当下。有些老师过分强调技巧，而有些老师则低估了技巧。重要的是要了解该技术是垫脚石。我们不需要放弃这项技术，但也不执着于它。实现三摩地的经过时间考验的方法是透过长期的精神实践。无论你称这种练习为冥想、自我探询还是祈祷，都有一个必须唤醒的真理。 2500年前编纂瑜伽经的瑜伽士和圣人帕坦伽利（Patanjali）教导说，瑜伽的整个努力都是为了让心的漩涡停止。你可以说是业障，支配一个人生活的深层无意识模式的停止。这些受限的模式在梵文中被称为vritti’s。同样地，道元禅师说，禅定是身心逐渐的放下。在佛教中，它是涅槃或涅槃；是有限的自我心智波动的停止，导致对有限的自我意识的认同。在基督教中，我们发现相同的常年教导，但透过一个非常不同的比喻表达，使用当时历史上常见的语言。用基督教的术语来说，实现三摩地就是透过对罪的宽恕，实现基督自性，并达到神的国度。希伯来语中的「罪」这个词的字面意思是“没有达到目标”——意味着错过当下，追求外在世界的幸福，而不是实现真正满足的源泉。 进入当下，活在当下就是学会放弃受制约的心智的偏好。透过对变化场域中出现的任","date":"2022-02-01","objectID":"/2022-02-01-samadhi-3/:0:0","tags":["Samadhi"],"title":"无路之路","uri":"/2022-02-01-samadhi-3/"},{"categories":["Thinking"],"content":" 镜子互相反射，而影子又再次互相反射以至无穷，一个层面的变化会导致所有层面的同时变化。 – Samadhi 从古至今，世界上最伟大的精神导师都认为人类最本质的真相并不在于拥有某种特殊的宗教或精神文化。这个真相其实就在每个人的内心。诗人鲁米说：那个永不曾升起或落下的月亮在哪里？那个永不曾伴随或离开我们的灵魂在哪里？不要说它在这里或那里。 所有的创造都是“那个”，除了能看东西的眼睛。在“巴别塔”的故事中，人性碎裂成无数的语言、信念、文化和爱好。“巴别”的字面意思是“上帝之门”，这个门就是我们的思想意识，即我们局限性的自我架构。那些体悟到真实本性的人，他们的本质超越了名相，他们得以窥见大门之内那些神圣的秘密。 那则盲人摸象的古老寓言，常被用来比喻面对同一个真相却有各种各样不同观念的情形。一群盲人分别触摸一头大象的不同部位，然后得到一些对大象的认识。摸到象腿的人说大象就像一棵树。摸到大象尾巴的人说大象就像一根绳子。而摸到象牙的人说大象像一根长矛。摸到大象耳朵的人，又说大象像一面大扇子。摸到大象身体的人，坚持说大象就像一堵墙。问题在于我们只接触到了大象的一部分，却坚信自己了解到的就是真相。我们不承认或没有认识到每个人的经验只是对同一头大象不同部分的了解。永恒哲学就是已经认识到所有的精神或宗教文化都在阐述一个共同的宇宙真相，一个神秘的、超乎人类思维的真相，所有的精神类知识和信条都建立在它的基础之上。 斯瓦米•维韦卡南达针对永恒教义总结道：“所有宗教的尽头就是体悟灵魂之神，这是那个共同的宗教。”我们在这部影片中所说的“神”这个词就是指那个神秘的、超乎人类局限性思维的真相。要体悟“真我”或内在的“本我”，就要体悟人类殊胜的本性。每个灵魂都有显现更高层级觉知的潜力，都可以从沉睡和对形相的认同中觉醒。 身为作家和预言家的奥尔德斯•赫胥黎因《美丽新世界》一书而成名。他还写了另一本名为《长青哲学》的书。在书中他提到一则历史上不断重现的教义，这则教义以其所属文化的形式表达出来。他写道：永恒哲学以最简洁的方式在一个梵文习语中呈现出来，即“那就是你”。“本我”或那个永恒存在的“我”，就是梵心——所有客观存在的最高准则，每个人的终极任务就是亲自去探寻真相，明白自己到底是谁。每一种传统文化就像钻石的一面，从一个独特的视角反射着同一个真相。而同时，它们又互相共鸣，互相印证。不论是何种语言或概念体系，所有秉持永恒教义的宗教都在告诉我们，我们与一种更伟大的、超乎寻常的力量联结着。我们可以从一个或多个源头学习和领会关于真相的教导，而无须与它们产生自我认同。据说所有真正的精神教导都只像是指向终极真相的手指。如果我们过于执着于那些教义和信条，将会阻碍精神的进化。要体悟超乎所有概念的真相，就要放下所有的执着和依附，放下所有的宗教观念。从“自我”的视角来看，将你引向三摩地的那根手指则是直接指向了地狱。圣十字若望曾说：“如果一个人想确认自己脚下的路，他必须闭上双眼，在黑暗中行走。” 三摩地开始于面向未知的那一跃。据说在古代传统中，为了体悟三摩地，必须让知觉彻底远离所有事物、所有外在现象、所有局限性的思想和感知，从而走向觉醒，走向内在本源和人的本心或本质。在这部影片中，我们所说的“三摩地”指的那个是超乎人类思维的真相，也就是被称为“无余涅槃”的最高三摩地。 在“无余涅槃”的状态中，“自我”的活动以及所有探索行为都停止了。估且描述为：当接近它时，它远离了；当离开它时，它又回来了；没有知觉或无知觉的区分，没有存在或不存在的区分，也没有意识或无意识的区分。对思维来说，这绝对高深莫测、无法理解。当“自我”又重新浮现时，将是一种空白，一种重生，一切都将是新的。只剩下一种神圣的回味长久伴随着我们继续前行。 在古代文化中有很多种三摩地，随着语言的变迁造成了很多混淆。我们用“三摩地”这个词指的是那个超乎人类思维的联结状态，但我们也可以用其它文化中的词来表达。三摩地是一个古老的梵语词汇，在古印度吠陀、瑜伽和数论派文化中很常见，并渗透到许多其它的文化体系中。三摩地是帕坦伽利所传授的“瑜伽八支行法”的第八支，也是佛陀所说的“八正道”中的第八道，佛陀称之为“正定”，也就是“静脉”的止息，或自我思维的止息。帕坦伽利将瑜伽或三摩地称为“心念灭尽”，即“意识的旋涡停止盘旋”之意。也就是知觉从整个思维运作机制中解脱出来。三摩地并不意指任何概念，因为要想体悟三摩地就要放下所有概念性思维。 不同的宗教用不同的词汇来表述这种殊胜的联结状态。事实上，“宗教”这个词本身也是如此。在拉丁文中，“宗教”意指“重新绑定”或“重新联结”，与“瑜伽”涵义类似，“瑜伽”的本义就是“联结”，联结尘世与解脱的彼岸。在伊斯兰教，“伊斯兰”这个词在古阿拉伯语中是对神灵恭顺或祈求之意，意指“自我”彻底的谦恭或顺从。 基督教神秘主义者如圣方济、圣特雷莎和圣十字若望都描绘了与上帝、与内心神圣王国的殊胜联结，在《多马福音》中，基督说：“王国不在这里或那里，圣父的王国在地球上无处不在，而世人却看不到。”从永恒教义的角度来看，古希腊哲学家柏拉图、普罗提诺、巴门尼德和赫拉克利特的著作，都指向同一个真理。普罗提诺教导说人类最伟大的奋斗就是引导灵魂去往最高的完美境界，并与神联结。 拉科塔族圣人黑麋鹿曾说：“最高的，也是最重要的平和，就是体悟到自身与宇宙及其能量相通如一，体悟到宇宙的中心有伟大的灵魂，而这个宇宙中心其实无处不在，就在我们每个人的内心时，来自灵魂深处的那种平和。 在觉醒之路上，除非我们进入三摩地，否则永远会有两个极端或两扇门可以进入，也就是两个维度：一个通向纯粹的觉醒，而另一个通向表象世界。向上就会通向觉悟，而向下则通向迷失和一切或有形或无形的幻象。 至于相对和绝对之间的区别，可以用印度圣哲尼萨伽达塔的话来说明，“智慧就是知道自己一无所有，爱就是知道自己拥有一切，而我的生命，在这两者之间前行。”这种联结产生一种新的殊胜的觉知。这两个极端的联结或相通，或者说二元认知的瓦解产生出一些新的东西，然而，所生即是空，所生从未生。觉醒之花生出新的认知，你可以称之为永恒的“三位一体”。神、天父或那个超乎思维的、不可知的、永恒的状态，与神圣的阴性能量——即所有变化的事物相联结。这种联结导致一种魔力般的转换，一种死亡和重生。 在吠陀教义中，这种殊胜的联结体现于两种最基本的能量：湿婆和夏克提。在历史长河中，这种联结的名相虽多有变换，但其本质未变。这种联结导致一种新的殊胜的觉知，一种崭新的世间存在方式。两极汇合，成为一种没有中心、不受限制的宇宙能量，这就是纯粹的爱。不再有所谓得到或失去，因为已经空无一物，但又圆满至极。 无论是美索不达米亚的神秘学院、巴比伦人和亚述人的精神文化、古埃及的宗教、古非洲的努比亚和凯马特文化、全世界的萨满传统或土著文化、古希腊的神秘主义、亦或诺斯底教、非二元论者、佛教、道教、犹太教、拜火教、耆那教、穆斯林教、基督教，都可以发现其共通之处就是他们最高深的精神领悟，都能指引其信徒去体悟三摩地。 三摩地这个词的本义就是指那个体悟到万物同一的状态，也就是联结，你自身各方面的联结。但是不要将关于三摩地的真正体悟混淆为知识层面的理解。是你的寂静和空性联结了生命螺旋的各个层级。正是通过这些关于三摩地的古老教义，人类才能去了解所有宗教的共同根源，并再一次与生命螺旋、大灵、法或道达成一致，生命螺旋是从微观通向宏观的桥梁，也是从DNA通向内在的能量莲花，进而通过脉轮到达星系旋臂的桥梁。灵魂的各个层级都通过这个螺旋显现出来，如永恒的旋臂，存在着，探索着。真正的三摩地就是体悟到“自我”的各个层次和灵魂的各个层级都具有空性。生命螺旋就是二元纠缠和生死轮回的永恒运转。有时，我们忘记了自己与生命本源相联结。我们的眼界非常狭窄，把自己局限为一种在地球上爬动的生物，只是再一次完成了回到本源的旅程，回到那个无处不在的中心。 庄子说：“当没有了此和彼的对立，也就得到了道的精髓，站在了生命螺旋的中心，然后就可以目睹万物之无穷。”那则古老的咒语“唵嘛呢叭咪吽”蕴含着一种诗意。当一个人觉醒或体悟到莲花之中自有珍宝，则其本性就会从灵魂中醒来，从真相中醒来，这也就是真相本来的样子。用赫密斯公理“在上如在下，在下如在上”，我们可以类比理解思索和静止、相对和绝对之间的关系。 有一个方法可以理解三摩地的非概念性，那就是用黑洞来类比。在传统理论中，黑洞被描述为一个重力极强的空间，以至于光和所有物质都无法逃离。而新理论假定所有的物体，从最小的微观粒子到大的宏观构造如星系，在其中心都有一个黑洞或神秘的奇点。按这个新的理论，我们将那个无处不在的中心比作黑洞。在佛教的禅宗，有许多诗词和公案可以让我们直接面对那个无门之门。只有穿过那个无门之门，才能体悟三摩地。 黑洞的“事件视界”是一个时空界限，这个界限之内的事物无法被界限之外的观察者看到，也就是说，“事件视界”之内发生的一切对你来说都是未知。可以说黑洞的“事件视界”与无门之门非常类似，也就是“有我”和“无我”之间的临界。一旦穿过“事件视界”，就不再有“我”。在黑洞的中心就是一维的“奇点”，这个无穷小的点却拥有无数个太阳的质量。虽然拥有无穷大的质量，但它却是比沙粒还要小得多的极小宇宙。“奇点”是超越时空概念的深奥存在。按照物理学理论，那里没有运动，也不存在物质。 总之，它不属于知觉世界，但也不能简单描述为静止，它超越了运动和静止。当你体悟到这个中心无处不在又并不存在，二元对立就消失了，即空即有，即生即灭。这个玄妙至极的中心点，你可以称之为持续运动的静止，或包含万物的虚空。道家的老子曾说：“玄而又玄，众妙之门。”作家和比较神话学大师约瑟夫•坎贝尔描绘了一个轮回的图符，也属于永恒哲学","date":"2021-12-03","objectID":"/2021-12-03-samadhi-2/:0:0","tags":["Samadhi"],"title":"非想之想","uri":"/2021-12-03-samadhi-2/"},{"categories":["Thinking"],"content":" 你永远不可能真正自由，因为无论你去哪里，你的监狱都如影随形。 – Samadhi 三摩地是一个古老的梵语词汇，现代没有与之含义相同的词了。要制作一部关于“三摩地”的影片，会遇到一个重大的挑战。“三摩地”指的是某种在思维层面无法表达的东西。这部影片只是我自己心路历程的展示。目的不是要给你讲解“三摩地”，也不是要给你洗脑，而是要启发你去直面你的本性。现在，“三摩地”比以往任何时候都更重要。在现在这个时代，我们不仅忘记了“三摩地”，而且已经忘记了我们曾忘记了什么。这种“忘记”是一种幻象，是自我的迷失。 身为人类，我们大部分人都淹没在日常生活中，很少想过我们是谁？我们为什么来到这里，我们要去往哪里？我们大部分人从没体会过真我、灵魂，或是佛陀所说的“了知”它超越了各种名相，超越了思维。于是，我们就把“自我”局限于我们的身体。有意或无意地，我们会害怕我们这个肉身，也就是我们所理解的那个“我”，会死亡。 在当今世界，很多人进行宗教或精神的练习，借用瑜伽、祈祷、冥想、颂咒或其它仪式，这些人绝大部分是在进行某种局限性的技能练习。也就是说他们只是在建构“自我”。探寻和练习并不是问题所在，认为自己已经在这些外在形式上找到了答案才是问题所在。 大部分的精神追求在形式上与随处可见的病态想法并无二致。这是内心深处的一种焦虑。不只要生而为人，更要像人一样活着。“自我”在建构时想要更多金钱、更多权力、更多的爱、更多的一切。那些走在所谓精神追求道路上的人也想要更精神化、更清醒、更淡然、更平和，更觉醒。你观看此影片的危险之处就是你的思维想要获得“三摩地”，更危险的是，你认为自己已经获得了“三摩地”。每当你想要得到什么东西的时候，就可以确定这是“自我”建构在起作用。三摩地不是要帮你得到或增加什么。 要体悟到三摩地，就要在你死亡之前先学会死亡。生和死，如同阴和阳，是一个不可分割的连续体。持续地进行，没有开始，也没有结束。当我们拒绝死亡，也就拒绝了生存。当你直接体验到你到底是谁，也就不会再害怕生或死。 我们的社会和文化告诉我们自己是谁，同时，我们也在内心深处无意识中成了那些生理性的渴望或厌恶的奴隶，它控制着我们如何选择。自我建构不过是一种不断重复的冲动，是一种趋势。我们的精神一旦选择了一条路，就不断去重复那条路，不论它对我们的机体是有利还是有害。我们的记忆或意识有无数层级，盘旋再盘旋。当你的知觉认同了这种意识或自我建构，它就让你陷入了社会制约，或者说是一个矩阵。 我们可以意识到“自我”的某些方面，但实际上却是那些无意识的古老的路线，那些原始的生存恐惧，在驱动着整个矩阵运转。人们无休止的追求快乐和躲避痛苦的生存模式，演变为病态的行为…我们的工作…我们的关系…我们的信仰，我们的思想，以及我们的整个生活方式。就像牛一样，大多数人都在被动的奴役中生存和死亡，把他们的生命限制在矩阵之中。我们生活在狭隘的模式中。生活经常充满着巨大的痛苦，但我们从来没有想过，其实我们可以变得自由其实我们可以放弃从过去传承下来的生活方式，转而尝试内心深处埋藏已久的那种生活。 我们降生于这个世界，虽然拥有生理的身体结构，但却没有自我觉知。当你看着小孩儿的眼睛，里面没有自我的痕迹，只有清澈的空灵。长大后的人，变成了一个戴在自我意识上的面具。莎士比亚说:“世界是一个舞台，所有的男人和女人只是演员而已。”在一个觉醒的个体中，觉醒的光芒会穿越人性，穿过面具，当你一旦觉醒，就不再会认同自己的角色。你不再相信你只是自己所戴的面具。但你也不会放弃扮演你的角色。 在柏拉图完成《理想国》2400年之后，人类仍在尝试走出柏拉图的洞穴。但事实上，我们可能比以往任何时候都更加痴迷于幻象。柏拉图曾让苏格拉底描述了一群人，他们一生都被锁在洞穴里，面向一面空墙。他们看到的只有他们背后的火光所照射的物品投射在墙上的影子。这木偶一般的影像就是他们的全部世界。据苏格拉底所说，这些影子就是囚徒们所看到的现实。即使告诉他们外面世界的样子，他们仍然继续相信那些影子就是全部世界。虽然他们也会怀疑外面还有更多的东西，但仍不愿意离开他们所熟悉的世界。 今天的人类就像洞穴里那些只能看到墙上投影的人。那些投影就像是我们的思想。思想的世界就是我们所唯一了解的世界。但是还有另一个世界，超越了思想，超越了二元思维。你愿意走出洞穴，摒弃所有已知，去发现你到底是谁吗？ 要体验三摩地的状态，就需要将注意力从那些影子上移开，从思想上移开，去面向光明。当一个人已经习惯了黑暗，那么他们必须逐渐地去适应光明。就像适应任何新模式一样，这需要时间和努力，需要心甘情愿的去探索新世界，摆脱旧世界。思维可以被比作意识的陷阱，迷宫或监狱。并不是说你在监狱里，而是你自己就是监狱。 监狱是一种幻象。如果你认同迷失的自我，那么你就是在沉睡。一旦你意识到了这个监狱，而试图逃离这种幻象，那么你还是将幻象当作了真实，你仍然在沉睡，只是现在梦幻变成了一场噩梦。你就会永远追逐或逃离那些影子。三摩地正是从分离的自我或自我建构的梦幻中觉醒。三摩地正是从对监狱的认同中觉醒，这个监狱就是“我”。你永远不可能真正自由，因为无论你去哪里，你的监狱都如影随形。 觉醒并不意味着摆脱思维或矩阵，恰恰相反当你不认同它时，你才能更充分地体验人生这出戏，享受这场表演，无欲无惧。在古代教义中，这被称为利拉的神圣游戏：二元世界中的游戏。 人类的意识是一个连续体。在一端，人类认同这个物质性的我。在另一端，就是三摩地——自我的终结。在这个连续体中，我们朝三摩地的方向所迈出的每一步，都会为我们减少一些痛苦。减少痛苦并非指生命没有痛苦了。三摩地超越了苦与乐的二元对立。也就是说，减少了思维，减少了自我臆造的对各种遭遇的抗拒，正是这种抗拒导致了痛苦。即使是短暂地体会三摩地，也能让你看到连续体的另一端有什么。看到除了这个物质世界和自我利益之外，还有另外的东西。 当在三摩地中确实终结了自我的架构时，就不再有自我思维、自我概念，和二元对立，但还有”本我“、”乐知“或”无我“。于此空性，即现般若或智慧之光，体悟到内在的我远远超越二元世界，超越整个连续体。这个内在的我是永恒的，不生不灭，不增不减。觉醒就是生命的原始螺旋、不断变化的外在世界或承载时间的莲花，与永恒本我的融合。当你不再认同自我，你内在的能量就如同持续展开的花朵一样生长，并成为时间维度与无时间维度之间的生命桥梁。 体悟到本我，只是进入觉醒之路的开始。在成功地将三摩地融入生活的其他方面之前，大部分人将会在冥想中，无数次地体验与失去三摩地。有一种情况并不罕见：在冥想或自我探寻中，洞察到自我本性，然后发现自己又再次落入旧的模式，忘记了自己到底是谁。 要在生命中每一个方面和自我的每一个方面都体悟到寂静或空性，就要让内心变得空寂，随万物舞动。寂静并不是与运动相分离的某种事物。也不是运动的对立面。在三摩地中，寂静与运动是同一的，形相与空性是同一的。这对思维而言是不可理解的，因为思维的世界是二元的。 西方哲学之父勒奈·笛卡尔有句著名的格言：“我思故我在。”这句话最清楚不过地概括了文明的衰落，以及对洞穴墙壁上投影的绝对认同。笛卡尔的错误，就像几乎所有人类的错误一样，将思想与存在画上等号。 笛卡尔在他最著名论文的开篇写道，几乎所有的事情都可以被怀疑；可以怀疑感官，也可以怀疑思想。如同佛陀在《迦罗摩经》中所说，为了探究真相，人们必须怀疑所有的传统、经典、教义，以及思维和感观中的所有内容。这两个人都是以极大的怀疑论开始探索，但不同的是，笛卡尔在思想层面便停止探究，而佛陀却更深入，他的探究穿越了，思维的最深层。或许，如果当时笛卡尔超越了他的思维层面，他或许就能体悟到真实本性，那么当今的西方意识也就完全是另外一个样子了。 但事实是，笛卡尔描述了一个邪恶的魔鬼，它使我们困在幻象的面纱之下。笛卡尔并没有认识到这个邪恶的魔鬼是什么。如同《黑客帝国》这部电影所描述的，我们全都被连接在某种精心制作的程序中，从而只看到一个虚幻的世界。在这部电影里，人类生活在矩阵之中，在另一个层面上，他们只是电池，把自己的生命之能输送给机器，机器则用人类的能量维持自己的运转。 人们总是想把世界的状况或自己的不悦归咎于自身之外的事物。或许是某个人，或某个团体、某个国家、宗教或某个掌控者，比如笛卡尔的恶魔，或《黑客帝国》中的智能机器。讽刺的是，笛卡尔正是用他所设想出来的恶魔来定义他自己的。当你体悟到三摩地，你就会明白，的确有一个掌控者，的确有一台机器和一个恶魔在日复一日地过滤你的生活。这台机器就是你。 你的自我结构是由许多微小的制约性子程序或小心魔组成的。一个小心魔渴望食物，另一个渴望金钱，还有的渴望身份、地位、权力、性、亲昵。还有一个心魔想要得到他人的注意或重视。欲望是无止境的，永远不会满足。 我们花很多的时间和精力粉饰我们的监狱，屈服于外界压力而改善我们的面具，满足着这些小心魔，使他们越来越壮大。像吸毒者一样，我们越是想要满足这些小心魔，我们的心魔也越来越多。解脱之道不是自我提升，也不是满足自己的各种心魔，而是完全放弃自己的所有心魔。 有些人担心，唤醒自己的真实本性，将意味着失去自己的独特个性以及对生活的享受。其实恰恰相反，只有自我的束缚被接触时，灵魂的独特个性才能显露出来。因为我们还在矩阵中沉睡，所以我们大部分人从来都不知道灵魂真正想表达什么。 通往三摩地之路需要冥想，既要观察这个变化无常的被束缚的自我，又要体悟你恒常不变的真实本性。当你达到寂静的状态，也就是你存在的本源时，就安静地等待进一步的指示，而不必要求外在世界必须改变。不是自我的意志，而是更高的意志会自动执行。 如果你的思维只是试着改变外在世界来符合你所认为的探寻之路应有的样子，这像为了改变镜中的样子","date":"2021-11-30","objectID":"/2021-11-30-samadhi-1/:0:0","tags":["Samadhi"],"title":"自我迷失","uri":"/2021-11-30-samadhi-1/"},{"categories":["Coding"],"content":"区块链是一个分布式数据库，任何人都可以读取的它的区块数据。区块链是不可变的，意味着一旦将区块添加到链中，就只能在使链的其余部分无效的情况下才能对其进行更改，这就是加密货币基于区块链来实现的原因。 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:0:0","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"区块和链 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:1:0","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"区块 区块链允许我们检测何时有人操纵了任何先前的区块，如何确保完整性呢？每个区块都根据前一个区块的哈希值，结合区块内的其他内容计算出自己的哈希值，作为该区块的唯一标识。 const SHA256 = require(\"crypto-js/sha256\"); class Block { constructor(timestamp, data, previousHash = '') { this.timestamp = timestamp; this.data = data; this.previousHash = previousHash; this.hash = this.calculateHash(); } calculateHash() { return SHA256(this.timestamp + JSON.stringify(this.data) + this.previousHash).toString(); } } ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:1:1","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"链 但第一个区块是特殊的，它没有前一个区块，我们称它为创世区块。 class Blockchain { constructor() { this.chain = [this.createGenesisBlock()]; } createGenesisBlock() { return new Block(\"01/01/2021\", \"Genesis block\", \"0\"); } getLatestBlock() { return this.chain[this.chain.length - 1]; } addBlock(newBlock) { newBlock.previousHash = this.getLatestBlock().hash; newBlock.hash = newBlock.calculateHash(); this.chain.push(newBlock); } isChainValid() { for (let i = 1; i \u003c this.chain.length; i++){ const currentBlock = this.chain[i]; const previousBlock = this.chain[i - 1]; if (currentBlock.hash !== currentBlock.calculateHash()) { return false; } if (currentBlock.previousHash !== previousBlock.hash) { return false; } } return true; } } isChainValid 方法用于验证区块链是否被篡改。若有人想要篡改区块链上的某个区块，他必须要更改这个区块之后的所有区块，才能确保区块链仍是完整的。 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:1:2","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"工作量证明 现在，我们来总结上面的区块链中的问题： 添加区块非常容易，攻击者可大量添加垃圾区块 篡改区块并不会耗费多少时间 结合上面两条可造出最长链 … 如果区块的添加需要付出大量的算力成本，就可以在动机层面就杜绝攻击，区块链中这种机制叫工作量证明。简单来说，就是只添加哈希值满足特定条件的区块。 如果你想添加一个区块，首先需要付出算力，让你的区块的哈希值满足特定条件： class Block { constructor(timestamp, data, previousHash = '') { this.timestamp = timestamp; this.data = data; this.previousHash = previousHash; this.hash = this.calculateHash(); this.nonce = 0; } calculateHash() { return SHA256(this.timestamp + JSON.stringify(this.data) + this.previousHash + this.nonce).toString(); } mineBlock(difficulty) { while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join(\"0\")) { this.nonce++; this.hash = this.calculateHash(); } console.log(\"BLOCK MINED: \" + this.hash); } } mineBlock 可筛选出的区块是哈希值的前 difficulty 位均为 0 的区块。通过调整 difficulty 的值，可以控制添加新区块的时间间隔： constructor() { this.chain = [this.createGenesisBlock()]; this.difficulty = 2; } addBlock(newBlock) { newBlock.previousHash = this.getLatestBlock().hash; newBlock.mineBlock(this.difficulty); this.chain.push(newBlock); } 在比特币中，大约每10分钟才会添加一个新的区块，而这个计算有效哈希的过程被称为挖矿。 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:2:0","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"交易和矿工奖励 当区块链中储存的信息为转账信息时，区块链就成\u0008了分布式账本。 class Block { constructor(timestamp, transactions, previousHash = '') { this.timestamp = timestamp; this.transactions = transactions; this.previousHash = previousHash; this.hash = this.calculateHash(); this.nonce = 0; } calculateHash() { return SHA256(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).toString(); } } class Transaction { constructor(fromAddress, toAddress, amount){ this.fromAddress = fromAddress; this.toAddress = toAddress; this.amount = amount; } } 我们的区块链中只能在一个区块中存储 1 个交易，并且矿工没有任何奖励，我们来解决这个问题。 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:3:0","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"数字签名 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:4:0","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"Docker 包括三个基本概念: Image(镜像)、Container(容器)、Repository(仓库)，理解了这三个概念，就理解了 Docker 的整个生命周期。 ","date":"2021-05-02","objectID":"/2021-05-02-docker/:0:0","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"基本概念 Docker 里的基本概念: Image(镜像): 镜像类似于创建虚拟机时只读的系统镜像文件 Container(容器): 容器可类比于可以运行的虚拟机，容器可以被创建、启动、停止、删除、暂停等。 Repository(仓库): 仓库是集中存放镜像文件的地方 tar 文件: 类似于 vmware 中的 vmdk 文件 Dockerfile: 定义镜像如何构建的配置文件 镜像与容器类似对象与实例的关系，一个镜像可以创建多个容器 ","date":"2021-05-02","objectID":"/2021-05-02-docker/:1:0","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"实战 在 Docker 官网注册好账号后，进入 play-with-docker 添加一个新的实例，就会进入 ssh 页面。 ","date":"2021-05-02","objectID":"/2021-05-02-docker/:2:0","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"创建容器 搜索远程仓库中的 nginx 镜像 $ docker search nginx 从远程仓库拉取 nginx 镜像, 可以在 dockerhub 中查指定版本的拉取命令 $ docker pull nginx 查看本地已有的镜像: $ docker images 用镜像创建容器, -d 指定后台运行, -p 指定外，内端口映射 $ docker run -d -p 80:80 nginx play-with-docker 的网页中出现了可点击的 80 字段，可以再启动一个外部 81 端口的映射 $ docker run -d -p 81:80 nginx ","date":"2021-05-02","objectID":"/2021-05-02-docker/:2:1","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"修改容器 查看正在运行的容器信息 $ docker ps 通过容器 ID 进入外部 81 端口的容器 $ docker exec -it 80fca9b9217d bash $ cd usr/share/nginx/html \u0026\u0026 ls 里面的 index.html 就是外部 81 端口网页中显示的 html, 修改这个文件 cat index.html echo hello \u003e index.html 强制刷新浏览器，网页内容为 “hello” 修改成功 $ exit 退出容器后，删除外部 80 端口容器，我们不用这个未修改的容器 $ docker rm -f 42a0565b5ba8 commit 构建镜像 将修改后的 81 端口容器重新保存为镜像后，启动新的 82 端口容器 docker commit 80fca9b9217d m1 docker images $ docker run -d -p 82:80 m1 这是对 commit 的实践，符合预期，另一种构建镜像的方式是使用 Dockerfile Dockerfile 构建镜像 $ vim Dockerfile 按照 dockerfile 语法写配置，FROM 指定新镜像的基础镜像，ADD 将当前文件夹下的所有文件拷贝到指定目录 FROM nginx ADD ./ /usr/share/nginx/html/ $ vim index.html hello, 83 $ ls Dockerfile index.html 以当前目录的 Dockerfile 作为镜像构建配置文件 $ docker build -t m2 . $ docker run -d -p 83:80 m2 容器启动后就可以网页查看了效果了, 网页内容为 “hello, 83” ","date":"2021-05-02","objectID":"/2021-05-02-docker/:2:2","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"导出镜像 $ docker save m2 \u003e m2.tar 删除镜像 m2 $ docker rmi m2 提示 container 0618f427bb2b 正在用这个镜像, 需要先删除容器 $ docker rm -f 0618f427bb2b $ docker rmi m2 $ docker images m2 镜像删除了，用 m2.tar 重新生成 m2 镜像 $ docker load \u003c m2.tar $ docker images ","date":"2021-05-02","objectID":"/2021-05-02-docker/:2:3","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"补充 到这里，我们已入门 docker，其他内容待补充。。。 参考资料 10分钟，快速学会docker Docker 从入门到实践 ","date":"2021-05-02","objectID":"/2021-05-02-docker/:2:4","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Thinking"],"content":" 在可计算性理论中，如果一系列操作数据的规则(如指令集、编程语言、细胞自动机)可以用来模拟任何图灵机，则称该系统是「图灵完备」的或能做「通用计算」的。 – wikipedia 通用计算(图灵完备)是计算能力的体现，意味着解决所有可计算问题的能力。在理论上却不难实现，可能的一个原因是计算能力是传递关系：如果 A 能模拟图灵机，而 B 能模拟 A，则 B 能模拟图灵机。 ","date":"2021-01-30","objectID":"/2021-01-30-tag-system/:0:0","tags":["Theory"],"title":"一些通用计算模型","uri":"/2021-01-30-tag-system/"},{"categories":["Thinking"],"content":"标签系统 图灵机由纸带，读写头，控制规则，状态表四个部分组成。标签系统(tag system)是一个类似图灵机的计算模型，它是一套字符串的转换规则：反复在一个字符串的末尾添加部分字符并在开头处删除部分字符(控制规则)。于是，标签系统会朝着字符串的末尾“移动”(读写头)。 标签系统可表示为三元组 (m, A, P)，其中： m 是删除数 A 是有限的符号字母表(状态表)，其中有特殊的停机符号 P 是添加字符的规则集合 Tag system m: 2 A: {1,2,3,H} P: 1 --\u003e 3321H 2 --\u003e 331 3 --\u003e 33 Computation Initial word: 211 1331 313321H 3321H33 21H3333 H3333331(halt). 当初始全为 3 的字符串时，程序永不停机，这意味着标签系统是图灵完备的。 ","date":"2021-01-30","objectID":"/2021-01-30-tag-system/:1:0","tags":["Theory"],"title":"一些通用计算模型","uri":"/2021-01-30-tag-system/"},{"categories":["Thinking"],"content":"循环标签系统 循环标签系统(cyclic tag system)是一类有额外限制的标签系统： 循环标签系统的字符只有 0 和 1 规则只在当前字符串以 1 开始时才生效 删除数是 1 这些约束对于支持通用计算来说过于苛刻了，作为补偿，允许循环尝试生成规则： Cyclic tag system m: 1 A: {0, 1} P: 1 --\u003e 011, 10, 101 Computation Initial word: 1 P word -------- -------- 011 1 10 011 101 11 011 1101 10 101011 101 0101110 011 101110 ... ... 字符串为空时，程序才会停机。而这个程序永不停机，因为 word 中一直有 1，这意味着循环标签系统也是图灵完备的。它的规则非常简单，不过它的行为却很复杂：接下来发生什么并不明显，字符串何时扩张，何时收缩？只能运行程序，然后观察它的行为。 ","date":"2021-01-30","objectID":"/2021-01-30-tag-system/:2:0","tags":["Theory"],"title":"一些通用计算模型","uri":"/2021-01-30-tag-system/"},{"categories":["Thinking"],"content":"Rule 110 一维元胞自动机建立在一行无限长的格子序列上，它的规则是： 每个格子有黑白两种状态 每个格子下一刻的状态由此刻的自身状态和左右邻居的状态共同决定 依照上述规则，有 256 种可能情况，若规定黑色为 1，白色为 0： \r上图对应 01101110(二进制)，这就是 Rule 110(十进制)，它也是图灵完备的，因为它被证明可以模拟循环标签系统。下面做简单解释： 在元胞自动机中，有的结构会随时间做周期性地“移动”，它们被称为“滑翔机”或“飞船”： \r上图是 Rule 110 中已发现的所有滑翔机，以及一个滑翔机枪：每周期发射一次A 和 B 滑翔机。这里展示了用通过特定排列的滑翔机来模拟 P: 1 --\u003e 11, 10 的循环标签系统，这不是完成通用计算的高效方式，但对简单的细胞自动机来说这仍是一项令人印象深刻的技术成果。比起二进制的字符串，图像可能更容易让人观察计算行为的普遍规律。 如果我们建立了宇宙的完整模型，是否意味着我们没有自由意志了呢？“Computational irreducibility” 意味着，就算你知道了一切规则，你可能也无法提前预测这些规则将会做什么 — 唯一的办法是运行这些规则看看它们到底会做出什么来。 参考资料 Universality in Elementary Cellular Automata Cyclic Tag System in Rule 110 - escom 复杂的极限在哪里 理解混沌和决定论的关系 ","date":"2021-01-30","objectID":"/2021-01-30-tag-system/:3:0","tags":["Theory"],"title":"一些通用计算模型","uri":"/2021-01-30-tag-system/"},{"categories":["Coding"],"content":"本文翻译自 stereobooster 的博客文章：metaprogramming，少量删改。完整内容参阅原文。 ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:0:0","tags":["Theory"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Coding"],"content":"什么是元编程 不好的是，没有一个达成共识的单一定义。让我们参阅一下： 元编程是一种编程技术，指计算机程序具有将其他程序视为其数据的能力。 – wikipedia 元编程是指程序具有了解自身或操纵自身的多种方式。 – stackoverflow 上的流行答案 “支持元编程”意味着用户可以有效修改该语言内置语法(例如 Lisp 的宏)或扩展该语言常规语法(例如 C 的预处理程序)。 – rosettacode 没有一个很好的定义，让我们看一些例子。当人们谈论元编程时，他们可能指的是： macros in Lisp (1960) preprpcessor in C (1973) hygenic macros in Scheme (1986) C++ templates (1986) “Dynamic” metaprogramming in Smalltalk (1980) and Ruby (1995-2005?) Reflections in Java (1997) ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:1:0","tags":["Theory"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Coding"],"content":"两类元编程 元编程大致分为两类： 一种是(编译时)作为源代码(例如宏，预处理器，模板)，通常称为“宏” 另一种是(运行时)基于“OOP 技巧”(例如动态调度和反射)以支持其他行为，这没有名字，我把它称为“动态” compile time runtime macros in Lisp ? + Preprocessor, templates + Dynamic metaprogramming + ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:2:0","tags":["Theory"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Coding"],"content":"动态元编程 元编程是编写在运行时操纵(自身)语言结构的代码。 – Ruby 元编程 元编程在 Ruby 中比在其他的动态类型语言中更常用，尤其是在 Rails 中，例如：Path and URL Helpers。动态元编程的缺点是“事物”没有源代码：你看到了一个函数，但是你不知道它的定义位置，这破坏了“grep test”。另一个缺点是它趋向于变慢，例如，参见 Rails / DynamicFindBy。 编程语言： Ruby JavaScript Python 2, Python 3 主要用法： 消除重复代码(DRY)，例如，David Beazley 在演讲中展示了很多例子。 创建嵌入式领域特定语言(EDSL)，Martin Fowler 称它们为内部 DSL。例如，Sass(能转换为 CSS 的 Ruby EDSL)，Haml(能转换为 HTML 的 Ruby EDSL)，Active Record 查询接口(能转换为 SQL 的 Ruby EDSL)，最重要的是 Rake(替代 Make 的 Ruby EDSL)。 “扩展语言” 关于扩展语言 如何扩展语言？可以添加更多关键字(扩展词法)，也可以添加更多关键字的组合规则(扩展语法)。 我们很容易添加更多关键字，例如，定义新的函数、模块、变量，但并不是所有种类 – 仅限于语言语法允许使用的标识符(例如，我不能定义 :?:)。在 Ruby 和 Python 中，可以重载运算符(+,-,\u003e,\u003c 等)，但不能定义新的运算符。据我所知，这些语言均不允许我定义新的语法规则，例如，我无法定义自己的 if/else 版本。 但程序员们总能找到一种方法来解决这个问题 – 可以重用现有的语法，让它看起来像是另一种语法。例如，在函数式语言中，有一个漂亮的“模式匹配”的概念。OCaml: match value with | pattern -\u003e result | pattern -\u003e result 或是 Scheme: (let ((l '(hello (world)))) (match l ((x y) (values x y)))) 这是在 JavaScript 中的实现： const { matches } = require(\"z\"); const result = matches(1)( (x = 2) =\u003e \"number 2 is the best!!!\", (x = Number) =\u003e `number ${x}is not that good`, (x = Date) =\u003e \"blaa.. dates are awful!\" ); 这是一个旧语法，但如果你细心，它看起来就像 OCaml 中的模式匹配。在幕后，它使用 toString 检查实际的代码，因为以前没有一等公民的反射对象。另一个值得注意的技术是“链式”(例如 jQuery 和 Active Record 查询接口)。 ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:2:1","tags":["Theory"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Coding"],"content":"Macros(宏) 宏是一个宽泛的范畴，让我们看一下使用示例来了解这一点。 语法扩展 在 Lisp 中 if/else 表达式像这样： (if condition (print 1) (print 2)) 定义具有相同结构的函数很容易： (my-if condition (print 1) (print 2)) 关键在于，Lisp 中的函数是立即执行的。这意味着在将参数传递给函数之前，它就会执行 then 和 else 两个分支，这就是宏的作用。有了宏，就可以定义自己的 if 版本，像你期望的那样。 另请参阅： Idris Syntax Extensions Racket Module Syntax, Racket Macros DSL JSX 是 ECMAScript 中类似 XML 的语法扩展，没有任何定义的语义 – Draft: JSX Specification 它本质上是一个 DSL。而负责编译它的 Babel 插件是一个预处理器。你可以使用其他的元编程技术来实现同样的结果 – 参见 JSX 的替代方案。 多态性 …多态语言，其中一些值和变量可能有一个以上的类型。多态函数是指其操作数(实际参数)可以有一个以上类型的函数。多态类型是指其操作可以适用于一种以上类型的值的类型。 – On Understanding Types, Data Abstraction, and Polymorphism 令我惊讶的是: 动态类型语言，是非常灵活的(但也很容易给自己找麻烦)。 静态类型的语言，具有完全的多态性支持，如 OCaml，Haskell 等。 没有多态性或在多态性上有一定限制的静态类型语言(Pascal，Go)。 最后一类编程语言可以使用元编程来实现类似多态性的东西(“提高灵活性”)。在 GO 中，没有参数多态(或类型参数，或泛型)，于是人们创造了解决方法，例如，gengen(类似的解决方案 genny，generic，gen)。 package list import \"github.com/joeshaw/gengen/generic\" type List struct { data generic.T next *List } 然后，您需要运行预处理器： $ gengen github.com/joeshaw/gengen/examples/list string 你会得到类型准确的代码: package list type List struct { data string next *List } 另请参阅：Who needs generics? Use … instead!, The Next Step for Generics. DRY 模板元程序员利用这种机制来提高：源代码的灵活性和运行时性能。 – Walter E. Brown “Modern Template Metaprogramming: A Compendium, Part I” 在C++中，有函数重载(即一种多态)，但它会产生很多重复： double abs(double x) { return (x \u003e= 0) ? x : -x; } int abs(int x) { return (x \u003e= 0) ? x : -x; } 你可以编写函数模板： template\u003ctypename T\u003e T abs(T x) { return (x \u003e= 0) ? x : -x; } ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:2:2","tags":["Theory"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Coding"],"content":"性能 通常认为，在编译时进行宏扩展可以提高性能。对我来说这很合理，但我没有很好的例子。 相关：Compile-time reflection and compile-time code execution in Zig. ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:2:3","tags":["Theory"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Coding"],"content":"宏和类型 Lisp(和Scheme)宏非常强大，但它们不能与静态类型检查器一起很好地工作。假设我们有确保能够终止的宏，并且能在编译时扩展(语法糖)并进行类型检查生成的代码，下一个问题是在生成的代码中报告类型错误，这也会很混乱。 有多种尝试使宏与静态类型更好地配合使用，例如： Hackett Inferring Type Rules for Syntactic Sugar 参考资料 Metaprogramming 谈元编程与表达能力 Emacs之魂：宏与元编程 ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:2:4","tags":["Theory"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Interview"],"content":"TCP 在不可靠的 IP 协议之上实现了可靠性，使得我们在开发上层应用时，不必关注网络传输的种种复杂性。可靠，指的是采用一系列技术来保障数据在发送方和接收方是一致的。我们了解下 TCP 如何实现可靠性。 ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:0:0","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Interview"],"content":"信道不可靠 需要解决的问题是，数据在信道上传输时，不总是符合预期，例如出现以下情况： 损坏：发送 10，11，接收到 10，10 乱序：发送 10，11，接收到 11，10 丢失：发送 10，11，只接收到 10 …… 我们看 TCP 是怎么解决这些问题的，学习它的做法，这可以作为一类问题的处理思路。 \r解决问题的办法其实写在了 TCP 报文头上，下面具体分析： ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:1:0","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Interview"],"content":"数据损坏 检验和机制：Checksum 用于校验报文是否在传输过程中发生了变化，计算方法： 1.将报文中的 Checksum 置零 2.基于整个报文(头部 + 数据部分)计算出 Checksum 接收方收到报文后，计算出 Checksum 并与报文中的 Checksum 对比。若一致，数据没有损坏。不一致，数据损坏，丢掉数据包。 ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:1:1","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Interview"],"content":"乱序和冗余 字节编号机制：建立连接时，发送方和接收方各自初始化一个seq(Seq...) 值，并且让对方知道，这就是为什么 TCP 连接时需要三次握手。发送方每次发送数据，都是在自己前一次的 seq 值上加本报文的 data 字节数，得到本报文的 seq 值。接收方接收到多个报文后，按 seq 的值对所有数据包进行升序排列，就能得到有序的报文。并且接收方可以判断接收的数据包之间是否有间隔或冗余。 ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:1:2","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Interview"],"content":"数据丢失 确认应答机制：接收方收到发送方的报文后，将 ack(Ack) 传递给对方，ack 的值表示接收方期望收到的下一次 seq 值。ack 的计算与发送方报文的 ack，ACK 无关(对\"确认\"进行再确认无意义，在不可靠的信道上，双方不可能达成一致性确认，两军问题)，这下再看 TCP 三次握手的图就清晰多了。 超时重传机制：报文在信道中丢失了，发送方就收不到对方的 ack。发送方在发送报文后，启用定时器(RTO)。一定时间没有返回就重传报文，就要知道报文在两方的往返时间(RTT)，根据 RTT 设计 RTO。而 RTT 实际上是波动的，当 RTO \u003c RTT 时，就造成了数据冗余。 快速重传机制：以数据驱动重传，例如发送方发送了 seq=1、 seq=2、 seq=3、 seq=4 的报文，其中 seq=1 的报文丢失了，发送方会收到三个连续的 ack=1，此时就触发快速重传机制，重传 seq=1。 ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:1:3","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Interview"],"content":"基本可靠 上面的设计在简单场景中是基本可靠的，即确保了字节流在通信双方完全相同。在复杂的场景中，TCP 还有很多其他的机制来实现可靠性。例如，造成数据丢失的原因有很多： 发送方对数据的处理效率高于接收方，接收方达到处理能力极限，而发送方无法感知，依然大量传递数据，就造成了数据丢失。(流量太快) 发送太多的数据造成数据在信道中过于拥堵，也会造成数据丢失。(流量太多) 这两种情况都会触发 TCP 的重传机制，而重传只会丢失更多数据，应对这两种情况，我们需要更多的机制： 流量控制机制：找到 TCP 两方中效率低的一方一次能处理的数据峰值，用 Window 表示，发送方根据 Window 的大小发送数据包，直到接收方收到所有数据包再进行下一次数据发送。 拥塞控制机制：找到信道一次能容纳的数据峰值，具体的实现涉及很多复杂的算法。 可靠性其实是一个很大的话题，有很多细节值得深究，本文只是让读者对可靠性有个基本的认识。 参考资料 车小胖的知乎回答 seq 和 ack 号的正确理解 图解 TCP 重传、滑动窗口、流量控制、拥塞控制 ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:2:0","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Thinking"],"content":"学习函数式编程总是给人一种学习哲学的错觉，Haskell 不仅定义了程序运算需要的类型，还给输入输出(IO)这样动作也定义了类型，并且把运行程序时的外部状态(RealWorld)当成函数的参数。 ","date":"2020-12-28","objectID":"/2020-12-28-monad/:0:0","tags":["Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Thinking"],"content":"IO haskell 中 IO 的类型定义： newtype IO a = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld -\u003e (# GHC.Prim.State# GHC.Prim.RealWorld, a #)) 简化表示如下， type IO a = GHC.Types.IO (World -\u003e (# World, a #)) 程序运行时，输入值需要参与到程序运算中。用函数表示输入动作： World -\u003e (# World, a #) 输出值不能再参与程序运算。用函数表示输出动作： World -\u003e (# World, () #) 在 GHCi 中用 :l 加载下面的程序文件： {-# LANGUAGE UnboxedTuples #-} import GHC.Types noExec (GHC.Types.IO a) = a inStr = noExec (getLine) outStr = noExec (putStrLn \"hello world!\") exec = GHC.Types.IO 然后用 :t inStr，:t outStr 查看类型，确实是我们说的那样。 ","date":"2020-12-28","objectID":"/2020-12-28-monad/:1:0","tags":["Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Thinking"],"content":"Monad 考虑函数与单个数值或字符之间的运算： (i -\u003e o) -\u003e i -\u003e o ghci\u003e ((+4) 2) + ((*2) 3) 12 ghci\u003e (\\x -\u003e(\\y -\u003e if x \u003e y then x else y)) 8 6 8 调用函数就能计算结果，不过这样做计算对人来说太麻烦了。 简化计算的办法是将值放在上下文环境(e)中，例如 [1,2,3]，(1,'a',3.14) 等。怎么在不破坏值的上下文前提下，应用函数完成计算呢？ f -\u003e e(i) -\u003e e(o) 换句话说，考虑 f 可能的情况，定义通用计算模型？ f = (i -\u003e o) f = e(i -\u003e o) f = e(i -\u003e e(o)) f = (e(i) -\u003e o) ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:0","tags":["Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Thinking"],"content":"Maybe 后面的讨论会用到 Maybe 类型： data Maybe a = Nothing | Just a ghci\u003e :t Nothing Nothing :: Maybe a ghci\u003e :t Just 2 Just 2 :: Num a =\u003e Maybe a ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:1","tags":["Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Thinking"],"content":"Functor 处理函数暴露，值处于上下文的情况： (i -\u003e o) -\u003e e(i) -\u003e e(o) ghci\u003e (+3) (Just 2) error ghci\u003e fmap (+3) (Just 2) Just 5 fmap 怎么实现的？模式匹配： fmap f Nothing = Nothing fmap f (Just x) = Just (f x) fmap 的动作是将上下文中的值取出，用函数处理后，重新放回上下文： class Functor f where fmap :: (a -\u003e b) -\u003e f a -\u003e f b instance Functor Maybe where fmap f Nothing = Nothing fmap f (Just x) = Just (f x) 只要能被 fmap 处理，这种上下文就是 Functor，Maybe 是 Functor ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:2","tags":["Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Thinking"],"content":"Applicative 处理函数与值处于同一种上下文的情况： e(i -\u003e o) -\u003e e(i) -\u003e e(o) ghci\u003e (Just (+3)) (Just 2) error ghci\u003e (Just (+3)) \u003c*\u003e (Just 2) Just 5 实现 \u003c*\u003e 同样用模式匹配： fmap f Nothing = Nothing fmap f (Just x) = Just (f x) Nothing \u003c*\u003e _ = Nothing (Just f) \u003c*\u003e x = fmap f x \u003c*\u003e 的动作是直接从上下文中取出函数，之后就是 Functor 的情况了，用 fmap 处理 class Functor f =\u003e Applicative f where pure :: a -\u003e f a (\u003c*\u003e) :: f (a -\u003e b) -\u003e f a -\u003e f b instance Applicative Maybe where pure = Just Nothing \u003c*\u003e _ = Nothing (Just f) \u003c*\u003e x = fmap f x 只要能被 \u003c*\u003e 处理，这种上下文就是 Applicative，Maybe 是 Applicative ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:3","tags":["Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Thinking"],"content":"Monad 处理值与函数的返回值处于同一种上下文的情况： e(i) -\u003e (i -\u003e e(o)) -\u003e e(o) 这里交换了函数和值的顺序，数据流向是从左往右的。 ghci\u003e (Just (+3)) \u003c*\u003e (Just 2) Just 5 ghci\u003e (\\x -\u003e Just (x + 3)) (Just 2) error ghci\u003e (Just 2) \u003e\u003e= (\\x -\u003e Just (x + 3)) Just 5 实现 \u003e\u003e= (发音为bind) 同样用模式匹配： Nothing \u003e\u003e= f = Nothing Just x \u003e\u003e= f = f x \u003e\u003e= 的动作是直接从上下文中取出值，应用到函数上 class Applicative m =\u003e Monad m where (\u003e\u003e=) :: m a -\u003e (a -\u003e m b) -\u003e m b (\u003e\u003e) :: m a -\u003e m b -\u003e m b return :: a -\u003e m a instance Monad Maybe where return x = Just x Nothing \u003e\u003e= _ = Nothing Just x \u003e\u003e= f = f x 能被 \u003e\u003e= 处理，并且实现 Applicative 的行为就是 Monad。每种 Monad 至少能处理三种函数： f = (i -\u003e o) f = e(i -\u003e o) f = e(i -\u003e e(o)) 我们可以利用 \u003e\u003e= 的性质实现链式操作： ghci\u003e let add3 = (\\x -\u003e Just (x + 3)) ghci\u003e (Just 2) \u003e\u003e= add3 \u003e\u003e= add3 \u003e\u003e= add3 \u003e\u003e= add3 Just 14 IO 类型也被 Haskell 定义为一种 Monad： ghci\u003e getLine \u003e\u003e= readFile \u003e\u003e= putStrLn Haskell 为我们提供了一些用于 Monad 的语法糖，称为 do 语法： foo = do filename \u003c- getLine contents \u003c- readFile filename putStrLn contents 在这篇文章中，我们用函数模拟了一阶逻辑， 而 Monad 是函数对结构化程序的模拟。 ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:4","tags":["Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Thinking"],"content":"补充 处理值与函数的参数处于同一种上下文的情况： (e(i) -\u003e o) -\u003e e(i) -\u003e e(o) class Func f where comp :: (f a -\u003e b) -\u003e f a -\u003e f b instance Func Maybe where comp f Nothing = Nothing comp f x = Just (f x) ghci\u003e comp (\\x -\u003e if x == (Just \"pwd\") then \"true\" else \"false\") (Just \"pwd\") Just \"true\" 这里 查阅 Maybe 的相关实现, 有时间再补充。 参考资料 Your easy guide to Monads, Applicatives, \u0026 Functors 关于 Monad 的学习笔记 Primitive Haskell Haskell Tutorial hackage.haskell.org ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:5","tags":["Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Coding"],"content":"如果你没有听说过 λ 演算，可以阅读我的这篇文章。如果你没有编译原理相关知识，可以阅读我的这篇文章。首先介绍调度场算法，后面的实现中会用到。 ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:0:0","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Coding"],"content":"调度场算法 调度场算法是一种将中缀表达式转换为后缀表达式的经典算法，由 Dijkstra 提出，因其操作类似于火车调车场而得名。为什么要转换，为了处理运算符的优先级： \r之后，程序处理后缀表达式 output 就像玩消消乐。 ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:1:0","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Coding"],"content":"处理括号 首先后缀表达式里没有括号，所以括号不应该被输出。由于括号里一定是一个完整的表达式，可以这样修改算法。把左括号的优先级当作最低，这样括号就不会立即出栈： 1.依次按顺序读入， 读到数字：直接输出； 读到一般运算符：如果栈顶的运算符优先级不低于该运算符，则输出栈顶运算符并使之出栈，直到栈空或不满足上述条件为止；然后入栈； 读到左括号：直接入栈； 读到右括号：输出栈顶运算符并使之出栈，直到栈顶为左括号为止；令左括号出栈。 2.当读入完毕时，依次输出并弹出栈顶运算符，直到栈被清空。 这样处理后，就能让括号内的运算符优先级最高。 除括号外，在 λ 演算有语义的运算符只有 . 和函数与参数之间的空格。. 用于区分函数变量和函数体，空格表示将参数作用于函数。它们都是中缀表达式，我们用调度场算法把它们转换为后缀表达式。 ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:1:1","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Coding"],"content":"词法分析 对任意的 λ 演算表达式，只保留函数间的空格。 /** remove any space that isn't in one of the following spots: )_(, x_(, )_x, x_x, x_\\, )_\\ */ function remove_extra_spaces(str) { return str.trim() .replace(/\\s+([^\\(\\wλ])/g, '$1') .replace(/([^\\)\\w])\\s+/g, '$1'); } // all spaces are lambda application =\u003e whitespace matters function lex(str) { let tokens = remove_extra_spaces(str) .split(/(\\)|\\(|λ|\\.|\\w+|\\s+)/) .filter(t =\u003e t != ''); return tokens; } lex(' ( λ a. λ b. a ) a b ') // [\"(\", \"λ\", \"a\", \".\", \"λ\", \"b\", \".\", \"a\", \")\", \" \", \"a\", \" \", \"b\"] ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:2:0","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Coding"],"content":"语法分析 按照调度场算法处理运算符，空格的优先级高于 .，因为函数的参数是函数。设计如下递归下降解析器： // shunting yard algorithm function parse(tokens) { let output = []; let stack = []; while(tokens.length \u003e 0) { let current = tokens.shift(); if(current.match(/\\w+/)) { output.push(new Var(current)); } else if(current.match(/\\s+/)) { // swap if both o1 and o2 are application stack_to_output(stack, output, () =\u003e stack[stack.length-1].match(/\\s+/)); stack.push(current); } else if(current == \"(\" || current == '.') { stack.push(current); } else if(current == \")\") { stack_to_output(stack, output, () =\u003e stack[stack.length-1] != '('); if(stack.length == 0) { console.log(\"mismatched parenthesis\"); } stack.pop(); // pop off left paren } } if(stack.indexOf('(') != -1 || stack.indexOf(')') != -1) { console.log(\"mismatched parenthesis\"); } else { stack_to_output(stack, output, () =\u003e true); } return output.pop(); } 加入运算符到后缀表达式 output function stack_to_output(stack, output, condition) { while(stack.length \u003e 0 \u0026\u0026 condition()) { let top = stack.pop(); let s = output.pop(); let f = output.pop(); output.push(top == '.' ? new Abs(f, s) : new App(f, s)); } } 这里用到了 AST 节点，给出定义： function Var(id) { this.type = 'var'; this.id = id; this.free_vars = new Set([id]); } function App(func, arg) { this.type = 'app'; this.func = func; this.arg = arg; this.free_vars = new Set([...func.free_vars, ...arg.free_vars]); } function Abs(v, expr) { this.type = 'abs'; this.var = v; this.expr = expr; this.free_vars = new Set([...expr.free_vars]); this.free_vars.delete(this.var.id); } 只有 abs 类型里的参数 var 是约束变量，例如 (λa.b) 生成的 AST 如下 Abs { type: 'abs', var: Var { type: 'var', id: 'a', free_vars: Set(1) { 'a' } }, expr: Var { type: 'var', id: 'b', free_vars: Set(1) { 'b' } }, free_vars: Set(1) { 'b' } } (λa.b) c 生成的 AST 如下 App { type: 'app', func: Abs { type: 'abs', var: Var { type: 'var', id: 'a', free_vars: [Set] }, expr: Var { type: 'var', id: 'b', free_vars: [Set] }, free_vars: Set(1) { 'b' } }, arg: Var { type: 'var', id: 'c', free_vars: Set(1) { 'c' } }, free_vars: Set(2) { 'b', 'c' } } ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:3:0","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Coding"],"content":"实现解释器 在每个 AST 节点上封装一个 stepped 布尔值，表示对应的表达式是否能够 β 规约。只有在调用函数时，才能进行 β 规约，替换掉函数里的约束变量。代码的实现思路是观察 AST 的结构，例如 (λa.b) c 能够被替换的是 (λa.b)，对应的 AST 结构是 app 里的 abs var redexes = 0; function stepper(node) { switch (node.type) { case 'var': return { stepped: false, node: node }; case 'app': switch(node.func.type) { case 'var': case 'app': let func_evaled = stepper(node.func); if (func_evaled.stepped) { return {stepped: true, node: new App(func_evaled.node, node.arg)}; } let arg_evaled = stepper(node.arg); return {stepped: arg_evaled.stepped, node: new App(node.func, arg_evaled.node)}; case 'abs': // redex redexes++; return {stepped: true, node: substitute(node.arg, node.func.var, node.func.expr)}; } break; case 'abs': let new_expr = stepper(node.expr); return { stepped : new_expr.stepped, node : new Abs(node.var, new_expr.node) }; } } 实现替换函数 substitute，代码的实现思路同样是观察 AST 的结构 // substitute e for x (variable) in expr function substitute(e, x, expr) { switch (expr.type) { case 'var': return expr.id == x.id ? e : expr; case 'app': return new App(substitute(e, x, expr.func), substitute(e, x, expr.arg)); case 'abs': if(expr.var.id == x.id) { return expr; } else if(!e.free_vars.has(expr.var.id)) { return new Abs(expr.var, substitute(e, x, expr.expr)); } else { do { var z = rename(expr.var.id); } while(e.free_vars.has(z) || variables(expr.expr).has(z)); return new Abs(new Var(z), substitute(e, x, substitute(new Var(z), expr.var, expr.expr))); } } } 进行 β 规约时，约束变量的名字可能重复，这就需要使用 α 变换重命名约束变量 function rename(variable) { let [match, prefix, num] = /^(.*?)([\\d]*)$/.exec(variable); return prefix + (num == '' ? 1 : parseInt(num) + 1); } function variables(expr) { switch (expr.type) { case 'var': return new Set([expr.id]); case 'app': return new Set([...variables(expr.func), ...variables(expr.arg)]); case 'abs': return new Set([...variables(expr.expr), expr.var.id]); } } 最后实现一个由 AST 节点重新生成 λ 演算表达式的函数 // unnecessary parenthesises uses in some abstractions function ast_to_expr(expr) { switch (expr.type) { case 'var': return expr.id; case 'abs': return `(λ${expr.var.id}.${ast_to_expr(expr.expr)})`; case 'app': return ast_to_expr(expr.func) + ' ' + (expr.arg.type == 'app' ? '('+ast_to_expr(expr.arg)+')' : ast_to_expr(expr.arg)); } } 现在可以自顶向下的解释 λ 演算表达式的计算规则了 let expr = '(λn. (λf. (λx. (f ((n f) x))))) (λf. (λx. x))'; function run(expr) { let t = new Date().getTime(); let ast = parse(lex(expr)); let new_expr = stepper(ast); while(new_expr.stepped) { console.log(redexes + ': ' + ast_to_expr(new_expr.node)); new_expr = stepper(new_expr.node); } let delay = new Date().getTime() - t; console.log('delay: ' + delay); console.log('redexes: ' + redexes); console.log('final: ' + ast_to_expr(new_expr.node)); } run(expr); expr 中第一个表达式是数字的后继函数，第二个表达式是数字 0 1: (λf.(λx.f ((λf.(λx.x)) f x))) 2: (λf.(λx.f ((λx.x) x))) 3: (λf.(λx.f x)) delay: 10 redexes: 3 final: (λf.(λx.f x)) 可以看到经过 3 次计算后，最终的表达式是数字 1，我们实现了 λ 演算解释器！ 附：源码地址 参考资料 算法学习笔记: 调度场算法 parkertimmins/lambda_interpreter ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:4:0","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Thinking"],"content":"程序的解释和编译通常需要经过词法分析，语法分析和生成抽象语法树等阶段。 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:0:0","tags":["Theory","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"前置知识 算术表达式根据运算符所在的位置可以分为三种表示方法： 前缀表达式(波兰式)，如 (- (+ 3 (* 2 4)) 1)，Lisp 语言就是使用这种表示方法 中缀表达式，如 3 + 2 * 4 - 1，最适合人阅读的表示方法 后缀表达式(逆波兰式)，如 3 2 4 * + 1 -，计算机处理起来比较方便 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:1:0","tags":["Theory","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"编译原理 为了讲清楚程序解释与编译，我们自定义一种类似 Lisp 的前缀表达式： mul 3 sub 2 sum 1 3 4 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:0","tags":["Theory","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"语法和语义 为了完整地定义编程语言，我们需要： 语法(Syntax)，就是程序看起来的样子(我们已经定义了)。 语义(semantics，描述程序的含义。一些编程语言有官方的书面规范。而另一些只有一个可用的解释器或者编译器，它们的语义是 “靠实现规范” 的。 我们用 JS 代码来规范前缀表达式的语义： const OpMapper = { sum: args =\u003e args.reduce((a, b) =\u003e a + b, 0), sub: args =\u003e args.reduce((a, b) =\u003e a - b), div: args =\u003e args.reduce((a, b) =\u003e a / b), mul: args =\u003e args.reduce((a, b) =\u003e a * b, 1) }; 按照我们规范的语义，前缀表达式等价为如下 JS 代码： mul(3, sub(2, sum(1, 3, 4))) // or 3 * (2 - (1 + 3 + 4)) ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:1","tags":["Theory","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"词法分析 词法分析将源代码中每一个有语义的字符(token)提取出来，用数组表示。 const lex = str =\u003e str.split(' ').map(s =\u003e s.trim()).filter(s =\u003e s.length); const tokens = lex('mul 3 sub 2 sum 1 3 4') // tokens = [\"mul\", \"3\", \"sub\", \"2\", \"sum\", \"1\", \"3\", \"4\"] ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:2","tags":["Theory","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"语法分析 - 语法描述 用 EBNF 来描述我们的程序语法： digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 num = digit+ op = sum | sub | mul | div expr = num | op expr+ - 抽象语法树 确定了语法后，一开始定义的前缀表达式可以表示为如下程序树(AST)： \r尝试用 JS 代码解析这种逻辑： const Op = Symbol('op'); const Num = Symbol('num'); const parse = tokens =\u003e { let c = 0; const peek = () =\u003e tokens[c]; const consume = () =\u003e tokens[c++]; const parseNum = () =\u003e ({ val: parseInt(consume()), type: Num }); const parseOp = () =\u003e { const node = { val: consume(), type: Op, expr: [] }; while (peek()) node.expr.push(parseExpr()); return node; }; const parseExpr = () =\u003e /\\d/.test(peek()) ? parseNum() : parseOp(); return parseExpr(); }; 程序树中每个节点都被表示为了 JS 对象，我们完成了程序的解析！ 实际上，我们开发了一个简单的递归下降解析器。每个对象的值其实是它的 val 属性，可以通过分治法自顶向下地对整个前缀表达式进行求值。 const evaluate = ast =\u003e { if (ast.type === Num) { return ast.val; } else { // Op needs parameters to be evaluated return OpMapper[ast.val](ast.expr.map(evaluate)); } }; const value = evaluate(parse(tokens)); console.log(value); // -18 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:3","tags":["Theory","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"解释和编译 将程序转换为 AST，然后直接对 AST 求值就是程序的解释(Interpreted)，还有一种求值方式是由 AST 生成中间代码，再由别的解释器或编译器对中间代码求值，就是程序的编译(Compiled)。通过 AST 完成代码转换非常方便，只需设计转换前后的映射表，代码转换就是查表替换。 const compile = ast =\u003e { const opMap = { sum: '+', mul: '*', sub: '-', div: '/' }; const compileNum = ast =\u003e ast.val; const compileOp = ast =\u003e `(${ast.expr.map(compile).join(' ' + opMap[ast.val] + ' ')})`; const compile = ast =\u003e ast.type === Num ? compileNum(ast) : compileOp(ast); return compile(ast); }; const newCode = compile(parse(tokens)); console.log(newCode); // (3 * (2 - (1 + 3 + 4))) 这里生成的中间代码就可以被直接被低级一些的语言解释或编译。 参考资料 Implementing a Simple Compiler on 25 Lines of JavaScript 解谜计算机科学 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:4","tags":["Theory","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"由邱奇创造的 λ 演算(λ-calculus) 是世界上最小的程序设计语言。λ 演算中没有数(number)，字符串(string)，布尔型(boolean) 或任何非函数的数据类型，它只用匿名单参函数就能模拟图灵机。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:0:0","tags":["Theory","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"λ 演算 λ 演算仅由 3 种元素组成：变量、函数 和 应用 \r最基本的函数是恒等函数：$ λx.x $，等同于 $ f(x) = x $，第一个 x 是函数参数，第二个是函数体。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:0","tags":["Theory","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"变量 λ 演算中的变量分为自由变量和约束变量： 在函数 $ λx.x $ 中 x 被称为约束变量，x 被称为约束变量，因为它既在函数体中又是形参。 在 $ λx.y $ 中 y 被称为自由变量，因为它没有被预先声明。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:1","tags":["Theory","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"求值 求值通过 β规约(β-Reduction) 完成，它将替换作用于应用，简单理解就是函数调用。例如对表达式 $ (λx.x)a $ 求值时，我们把函数体中所有的 x 都替换为 a： $ (λx.x) \\ a = a $ $ (λx.y) \\ a = y $ 你可以这样表示高阶函数： $ (λx.λy.x) \\ a = λy.a $ 为了简化表示，λx.λy. 与 λxy. 等价： $ (λxy.x) \\ a = λy.a $ 图灵机的逻辑操作实际上是二进制的 0 1 比较，而 λ 演算中连数字都没有，怎么定义程序逻辑？既然没有数，那就用 λ 函数来表示数！ ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:2","tags":["Theory","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"Church 编码 邱奇数 邱奇数 是用 λ 函数表示的自然数。某个程序过程(函数) f 和它的执行次数 n，存在对应关系： $ 0 = λf.λx.x $ $1 = λf.λx.f x$ $ 2 = λf.λx.f (f x) $ $ 3 = λf.λx.f ( f (f x)) $ … 于是， $ n = λf.λx.f^nx $ 由 β规约得出：$ n \\ f \\ x = (λf.λx.f^nx) \\ f \\ x = f^nx $ 由恒等式 $ f^{m+n}x = f^m(f^nx) $ 推出加法定义： $ plus = λm.λn.λf.λx.m \\ f \\ (n \\ f \\ x) $ 由恒等式 $ f^{m*n}x = (f^n)^mx $ 推出乘法定义： $ mult = λm.λn.λf.m (n \\ f) $ 其他的运算都能用类似的方法推出。 布尔逻辑 布尔逻辑可被看做一种选择，ture 和 false 可以被编码为有两个参数的函数： ture — 选择第一个参数 $ true = λa.λb.a $ false — 选择第二个参数 $ false = λa.λb.b $ 布尔函数本身是条件分支，那 if-else 语句就成语法糖了。因为判定条件最终是布尔函数，直接能将 if-else 的条件分支作为布尔函数的参数(if-else 语句有三个参数，第一个是判定条件)： $ ifelse = λp.λt.λf. p \\ t \\ f $ (p = true or p = false) 接着定义与、或、非的逻辑运算符： $ and = λp.λq. p \\ q \\ p $ $ or = λp.λq. p \\ p \\ q $ $ not = λp. p \\ false \\ true $ 若要图灵完备，必然能实现无限递归。而 λ 演算中只有匿名单参函数，也就是没有提前的函数声明，这能实现无限递归？真的能！ ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:3","tags":["Theory","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"不动点组合子 不动点 函数 $ f $ 的不动点指的是将函数应用在输入值 x 时，会传回与输入值相同的值，使得 $ f(x) = x $。例如，0 和 1 是函数 $ f(x) = x^2 $ 的不动点。现在，假设有某个函数 Y 和任意函数 g，满足： Y g = g (Y g) 就是说将 g 作为 Y 的参数时，得到的新函数 Y g 是 g 的不动点。那神奇的事情就发生了： Y g = g (Y g) = g (g (Y g)) = g (…g (Y g)…) 一旦调用 Y g 就会产生新的 g，任意函数 g 的无限递归不就产生了吗？Amazing！ Y combinator 数学家 Haskell Curry 发现了这个 Y 的存在： $ Y := λf.(λx.f(x \\ x))(λx.f(x \\ x)) $ 证明过程： \r例如我们用匿名函数表达求阶乘时，我们暂称它为 g，实际的 g 和 Y 没有名字， g = λf. λx. (iszero x) 1 (mult x (f (pred x))) 当调用 Y g 时，得到 g(Y g)，由 β规约得出： g(Y g) = λx. (iszero x) 1 (mult x ((Y g) (pred x))) 于是，Y g 就成为了递归函数： Y g = λx. (iszero x) 1 (mult x ((Y g) (pred x))) Y 能够组合一个匿名函数成为递归函数，因此被称为 Y combinator(Y组合子)。由于 lambda 表达式是惰性求值，而很多编程语言例如 JS 中使用严格求值，因此 Y组合子在 JS 中这样表示： let Y = f =\u003e (x =\u003e f(y =\u003e x(x)(y)))(x =\u003e f(y =\u003e x(x)(y))); Church 编码和不动点组合子表明了程序不用其他原始数据类型就能模拟图灵机。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:4","tags":["Theory","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"实践 代码实践参考了计算的本质一书，原文是 Ruby 代码，我把它翻译为 JS 代码了： const Y = f =\u003e (x =\u003e f(y =\u003e x(x)(y)))(x =\u003e f(y =\u003e x(x)(y))); const F = a =\u003e b =\u003e b; const T = a =\u003e b =\u003e a; const zero = f =\u003e x =\u003e x; const one = f =\u003e x =\u003e f(x); const two = f =\u003e x =\u003e f(f(x)); const three = f =\u003e x =\u003e f(f(f(x))); const four = f =\u003e x =\u003e f(f(f(f(x)))); const five = f =\u003e x =\u003e f(f(f(f(f(x))))); const pair = x =\u003e y =\u003e z =\u003e z(x)(y); const left = p =\u003e p(x =\u003e y =\u003e x); const right = p =\u003ep(x =\u003e y =\u003e y); const empty = pair(T)(T); const ushift = l =\u003e x =\u003e pair(F)(pair(x)(l)); const is_empty = left; const first = l =\u003e left(right(l)); const rest = l =\u003e right(right(l)); const if_else = b =\u003e b; const is_zero = f =\u003e f(x =\u003e F)(T); const is_less_or_equal = m =\u003e n =\u003e is_zero(minus(m)(n)); const succ = n =\u003e f =\u003e x =\u003e f(n(f)(x)); const slide = p =\u003e pair(right(p))(succ(right(p))); const pred = n =\u003e left(n(slide)(pair(zero)(zero))); const plus = m =\u003e n =\u003e n(succ)(m); const minus = m =\u003e n =\u003e n(pred)(m); const mult = m =\u003e n =\u003e n(plus(m))(zero); const div = Y(f =\u003e m =\u003e n =\u003e if_else(is_less_or_equal(n)(m)) (x=\u003esucc(f(minus(m)(n))(n))(x)) (zero) ); const a = two; const b = succ(a); const aa = ushift(ushift(empty)(a))(a); const ab = ushift(ushift(empty)(b))(a); const abaa = ushift(ushift(aa)(b))(a); const to_boolean = p =\u003e if_else(p)('T')('F'); const to_char = c =\u003e if_else(is_zero(c))('0')( if_else(is_zero(pred(c)))('1')( if_else(is_zero(two(pred)(c)))('a')('b') ) ); const fold = Y(f =\u003e l =\u003e x =\u003e g =\u003e if_else(is_empty(l)) (x) (y=\u003eg(f(rest(l))(x)(g))(first(l))(y)) ); const pushs = l =\u003e x =\u003e fold(l)(ushift(empty)(x))(ushift); const to_digits = Y(f =\u003e n =\u003e pushs( if_else(is_less_or_equal(n)(pred(two))) (empty) (x =\u003e f(div(n)(two))(x)) )(mod(n)(two)) ) const mod = Y(f =\u003e m =\u003e n =\u003e if_else(is_less_or_equal(n)(m)) (x =\u003e f(minus(m)(n))(n)(x)) (m) ); const range = Y(f =\u003e m =\u003e n =\u003e if_else(is_less_or_equal(m)(n)) (x =\u003e ushift(f(succ(m))(n))(m)(x)) (empty) ); const maps = k =\u003e f =\u003e fold(k)(empty)(l =\u003e x =\u003e ushift(l)(f(x))); const twenty = mult(four)(five); const my_list = maps(range(one)(twenty))(n =\u003e if_else(is_zero(mod(n)(succ(five))))(abaa)( if_else(is_zero(mod(n)(three)))(aa)( if_else(is_zero(mod(n)(two)))(ab)(to_digits(n)) ) ) ); // The above code only uses functions to compconste all calculations, // and the calculation result is a single-character linked list // But the above code does not encode the characters related to the output format, // so use an array to store the result to change the output format const to_array = proc =\u003e { const arr = []; while(to_boolean(is_empty(proc))!='T'){ arr.push(first(proc)); proc = rest(proc); } return arr; } const to_string = s =\u003e to_array(s).map(c =\u003e to_char(c)).join(''); console.log(to_array(my_list).map(v=\u003eto_string(v))); // If you don’t use arrays, you can also use functions to simulate const fact = Y(f =\u003e n =\u003e is_zero(n)(one)( x =\u003e mult(n)(f(pred(n)))(x) )); const arr = s =\u003e to_char(first(s)); const s1 = to_digits(fact(four)); const s2 = rest(s1); const s3 = rest(s2); const s4 = rest(s3); const s5 = rest(s4); // console.log(arr(s1) + arr(s2) + arr(s3) + arr(s4) + arr(s5)); 附：源码地址 参考资料 康托尔、哥德尔、图灵——永恒的金色对角线 Church encoding Learn Lambda Calculus in Y minutes Lambda演算系列 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:2:0","tags":["Theory","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"图灵机是英国数学家图灵于 1936 年提出的一种将人的计算行为抽象化的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:0:0","tags":["Theory"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Thinking"],"content":"基本思想 图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作： 在纸上写上或擦除某个符号； 把注意力从纸的一个位置移动到另一个位置； 而在每个阶段，人要决定下一步的动作，依赖于此人当前所关注的纸上某个位置的符号和此人当前思维的状态。为了模拟人的这种运算过程，图灵构造出一台假想机器，该机器由以下几个部分组成： \r 一条无限长的纸带(tape)，纸带由很多个格子构成，用于输入输出信息。每个格子中包含一个来自有限字母表的符号，字母表中有一个特殊符号表示空白。纸带上一端的格子从 0 开始编号，另一端无限延伸一直到无穷大。 一个读写头(head)，读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。 一套控制规则(table)，根据当前机器状态和纸带内容来确定下一步的动作： 写入或擦除当前格子内容 移动读写头，向左、向右、或不动 保持当前状态或转移到另一状态 一个状态寄存器(state register)，用于保存机器状态。图灵机的状态个数有限，并且有一个特殊的状态：停机状态。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:1:0","tags":["Theory"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Thinking"],"content":"图灵完备 只要能模拟单带图灵机，就是图灵完备(递归可枚举)的。这意味着其计算能力与通用图灵机等同。不是图灵完备的情况: 递归或循环有限，无法写不终止的程序(如 while(true){}) 不能模拟无限长纸带(没有足够的空间来完成计算) 但图灵完备也有可能带来坏处，有些场景我们需要限制语言的表达能力，通过限制无限循环却保程序一定是可终止的。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:2:0","tags":["Theory"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Thinking"],"content":"极简实现 Brainfuck 是一种极小化的图灵完备的程序语言，它仅由八种运算符构成。 它的工作机制与单带图灵机高度一致，它用一个一维数组存取数据，数组元素初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一元素。指针可以向左/右移动，也可以读取/修改当前值。如果你了解 C 语言，那么一看表格便明白它每个运算符的含义： Brainfuck C \u003e ++ptr; \u003c --ptr; + ++*ptr; - --*ptr; . putchar(*ptr); , *ptr = getchar(); [ while (*ptr) { ] } 不了解也没关系，它每个运算符的含义如下： \u003e 指针右移一格 \u003c 指针左移一格 + 使指针当前格数值加一 - 使指针当前格数值减一 . 把当前格数值按 ASCII 表输出到终端 , 从终端接收一字节的数据，存储其 ASCII 数值到当前格 [ 当指针当前值为 0 时，程序跳转至与之对应的 ] 之后；否则程序正常执行 ] 程序跳转回与之对应的 [ 处 有了这些工具，我们可以很快写出一个计算乘法的程序。因为 ASCII 表中 ‘A’ 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 ‘A’。 +++++ [ \u003e +++++++++++++ \u003c - ] \u003e . 把 Brainfuck 的一维数组命名为 arr，则开始的数组元素为 arr[0]，arr[0] 右边的数组元素为 arr[1]。第一句代码将 arr[0] 的数值递增 5 次变为 5。 然后，循环执行“右移指针，递增 13 次，左移指针，递减 1 次”。当 arr[0] 的值最终被递减为 0 的时候，循环结束。此时 arr[1] 的值执行了 5 次“递增 13 次”的操作，即 65。最后指针右移至 arr[1]，输出它对应的 ASCII 值即为 A。 结合 网站1 和 网站2 思考一下这门八个字符的编程语言是怎样模拟图灵机的每个组成部分的。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:3:0","tags":["Theory"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Thinking"],"content":"“我是谁？”，这种对指代自身的疑问每个人都会有。在自然语言和形式语言中，如果一个句子直接或间接提及自身，就称为自指(Self-reference)，自指的语句常常会造成悖论。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:0:0","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"不可判定怪圈 “这句话在说谎”，那么引号中的话是真话吗？你会发现，你若判定真，就会推出假。而你若判定假，又会推出真。不停的判定下去，就会陷入怪圈： \r在程序中，这就是无穷递归。与意识的自指相似的是别洛索夫发现的B-Z 反应。意识中的悖论竟在自然界中有对应，这不禁让人疑惑：我们真的有自由意志吗？ ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:1:0","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"崩塌的数学大厦 在 1900 年巴黎数学家大会上，希尔伯特提出了他的 23 个著名数学问题。以希尔伯特为首的很多数学家，打算让数学矗立在一个坚实的地基(公理体系)上，一劳永逸地解决所有对数学可靠性的疑问，这可是一项宏图大志。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:2:0","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"第二个问题 这 23 个问题中的第 2 个问题是完成数学家们理想计划的关键一步，它包含如下三个问题： 数学是完备的吗？(正确的数学陈述，是否总能被证明？) 数学是一致的吗？(数学是否前后一致，没有内部矛盾？) 数学是可判定的吗？(能否仅通过计算判定数学陈述的真假？) 在数学中，不证自明的事实被归纳为公理。公理是数学推演(计算)的起点，对公理的陈述就是命题，已被证明成立的重要命题被称为定理。那么一个可靠的数学系统至少应该满足以下性质： 有效性：在系统中如果前提为真，那么结论也为真 可靠性：系统中的所有定理都为真 一致性：系统中所有公理，定理之间没有矛盾 完备性：系统中不存在无法证明或无法证伪的命题 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:2:1","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"哥德尔不完备定理 这个想法非常美好，然而不久后，哥德尔用两条不完备定理将数学家们拍醒了： 第一定理：任何包含了算术的数学系统不可能同时拥有一致性和完备性(这里算术指皮亚诺算术(PA)的公理，这说明任何一个允许自然数加法和乘法的体系必定是不完备的，通过数学推演无法得到体系中所有真命题)。 第二定理：任何包含了算术的数学系统，如果它是一致的，那么它就不能证明自身的一致性。 哥德尔不完备定理说的是算术系统中“正确”与“可证”是两码事。他的证明是在算术系统 T 中构造出了命题 P：“P 不可在算术系统 T 内证明”(我不可被证明)。这让我们意识到只要一个系统的表达力强到可以自指，那么就是不完备的。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:2:2","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"图灵机的由来 哥德尔得到了第二个问题中前两个问题的答案。不久之后，图灵给出了其中最后一个问题的答案：数学是不可判定的。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:0","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"图灵对计算的思考 什么是计算？计算就是由输入(前提)到输出(结论)的过程。什么是可计算的？可计算就是一定能在有限步骤内完成的计算。为了给可计算一个精确定义，图灵提出了一种叫图灵机的数学模型，并提出了可计算函数(算法)的概念。(为什么可计算就是图灵机可判定，请看邱奇－图灵论题) 图灵对计算的思考让他解决了希尔伯特的问题，他的证明过程分两步: 1.停机问题不可判定 2.停机问题到判定问题的归约 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:1","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"停机问题不可判定 停机问题：是否存在一个程序 P，对于有任意输入参数的程序 w，能够判断 w 会在有限时间内结束或者死循环。图灵用对角论证法证明了，不存在解决停机问题的通用算法。本文用自指做一个反证法证明(程序中的自指就是递归)： 假设存在可以判定任意程序是否停机的程序，我们姑且称它为上帝程序 那么一定存在一个撒旦程序，首先让上帝程序判定自己，然后根据上帝判定结果，相反地运行程序 伪代码描述如下： def P(w, input): if w halts on input: return true else: return false def oppose_P(): if P(oppose_P): while (1): pass else: pass 在撒旦程序中，上帝程序的判断都是错的，所以不存在这样的上帝程序。停机问题是不可判定问题，这响应了哥德尔不完备定理。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:2","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"到判定问题的规约 现在一定存在某个数学陈述能够做为程序 w 的输入参数，而前面的停机问题证明了，不存在能够判定任意程序 w 能否在有限时间内结束的上帝程序，因此数学是不可判定的。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:3","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"自指与自复制 美国哲学家蒯因(Quine)创造了一种不使用代词就能构造自指语句的方法，称为蒯因技巧。如下句子便采用了蒯因技巧： 把“把中的第一个字放到左引号前面，其余的字放到右引号后面，并保持引号及其中的字不变”中的第一个字放到左引号前面，其余的字放到右引号后面，并保持引号及其中的字不变 当你按照该句子的指示操作后，便得到了它自身。该句子仅用动作(数学推演)便完成了一次自复制，数学家克林(Kleene)将蒯因这种语言的操作技巧进行数学化得到了一种更加普适的递归定理。有了这个递归定理以后，数学家就可以在严格的数学公理体系中构造各种自指游戏。哥德尔和图灵也是用递归定理来完成他们的伟大证明。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:4:0","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"思考总结 回到皮亚诺公理的第五条：对于无穷无尽具有相同性质的多米诺骨牌序列，已知第一块会倒下，并且每一块多米诺骨牌的倒下都会导致后一块倒下，是否每一块多米诺骨牌都会倒下？数学给出的假设是会，你觉得呢？数学是建立在有限假设之上的学科，当已知假设无法推导某些与无穷相关的性质时，就会在判定结果中显现出这种无穷无尽。一阶逻辑的逻辑归结是半可判定的，无法用有限归纳描述无穷过程。 自指太神秘了，对它的研究涉及到复杂性科学，作为门外汉的我只能无限感慨。想了解相关知识的读者，可阅读下面的参考资料。 参考资料 计算的极限(零)：逻辑与图灵机 系统中的观察者——被科学遗忘的角色 混沌理论本质一切复杂源于简单 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:5:0","tags":["Theory"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Interview"],"content":"在前端开发的过程中，我们经常需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等，然而有些时候我们并不希望在事件持续触发的过程中频繁地去执行函数，这时候就会用到函数防抖(Debounce)与节流(Throttle)： 防抖：在触发事件 n 秒后才执行函数，如果在 n 秒内又触发了事件，则重新计算时间。 节流：连续触发事件时在 n 秒中只执行一次函数，节流的目的是稀释函数的执行频率。 下面我们简单地了解这两种限制函数执行次数的具体实现方式。首先看这个例子： \u003cbutton type=\"submit\" id=\"btn\"\u003e提交\u003c/button\u003e \u003cscript\u003e var btn = document.getElementById('btn'); btn.addEventListener('click', submit, false); function submit(){ console.log('submit'); } \u003c/script\u003e 每次 button 的点击事件都会执行 submit 函数，我们如何限制 submit 的执行次数？ ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:0:0","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Interview"],"content":"Debounce 防抖是在事件多次触发时让函数只执行一次，有非立即执行和立即执行两种实现。 ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:1:0","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Interview"],"content":"闭包实现防抖 用闭包可以实现一个简单的 debounce 函数来包装 submit 函数，实现防抖效果。 var btn = document.getElementById('btn'); btn.addEventListener('click', debounce(submit, 1000), false); function submit(){ console.log('submit'); } function debounce(fn, timer){ let t = null; return function(){ // 计时未到 timer 的定时器会被清理，函数就不会执行  if(t){ clearTimeout(t); }; t = setTimeout(fn, timer); }; } 连续点击时，始终从最新一次点击开始计时。直到不再点击的 1s 后，才会执行一次 submit。 ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:1:1","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Interview"],"content":"传递 this 和 event 当我们在事件监听中绑定 submit 时，this 指向 button，并且可以拿到 MouseEvent 事件。 var btn = document.getElementById('btn'); btn.addEventListener('click', submit, false); function submit(){ console.log('submit'); console.log(this); // \u003cbutton type=\"submit\" ... console.log(arguments); // Arguments [MouseEvent ... } 现在我们的 submit 被 debounce 包装，此时 this 和事件参数要从 debounce 传递给 submit。 var btn = document.getElementById('btn'); btn.addEventListener('click', debounce(submit, 1000), false); function submit(){ console.log('submit'); console.log(this); // \u003cbutton type=\"submit\" ... console.log(arguments); // Arguments [MouseEvent ... } function debounce(fn, timer){ let t = null; return function(){ let context = this; let args = arguments; if(t) clearTimeout(t); t = setTimeout(()=\u003e{ fn.apply(context, args); }, timer); } } 这就是一个非立即执行的防抖实现，缺陷是第一次点击也需要等待 1s 后才会有反馈。 ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:1:2","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Interview"],"content":"立即执行版本 第一次点击时让函数立即执行。不再点击的 1s 后，新的点击将成为第一次点击，再次执行函数。 function debounce(fn, timer){ let t = null; return function(){ let context = this; let args = arguments; let firstClick = !t; if(t) clearTimeout(t); if(firstClick) { fn.apply(context, args); }; t = setTimeout(()=\u003e{ t = null; }, timer); } } ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:1:3","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Interview"],"content":"Throttle 节流的实现方式是减少函数的触发频率，同样有非立即执行和立即执行两种实现。 ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:2:0","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Interview"],"content":"定时器版本 非立即执行我们自然想到用定时器实现： function throttle(fn, timer) { let t = null; return function() { let context = this; let args = arguments; // 计时未到 timer 时不会执行函数 if (!t) { t = setTimeout(() =\u003e { fn.apply(context, args) t = null; }, timer) } } } ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:2:1","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Interview"],"content":"时间戳版本 立即执行我们要计算时间差，所以用时间戳实现： function throttle(fn, timer){ let begin = 0; return function(){ let now = new Date().getTime(); if (now - begin \u003e timer) { fn.apply(this, arguments); begin = now; } } } 实际上，结合非立即执行和立即执行的两种实现方式，你可以构造出具有更多功能的防抖函数和节流函数，满足业务需求。 参考资料 性能优化之防抖和节流 ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:2:2","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Coding"],"content":"以 useEffect 为圆心，其他 Hooks 为半径，构建 React Hooks 的知识圆环。为什么会想出这样一个标题呢？Hooks 的知识点过于分散，很多朋友在读过 React 官方文档后，还是不知道 Hooks 如何在实际项目中使用。本文希望从 useEffect 的具体用法中引出其他 Hooks，从而构建出完整的 React Hooks 知识体系。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:0:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"心智模型 学习 Hooks 的使用，重点是心智模型的转变。useEffect 的心智模型是实现状态同步，而不是响应生命周期事件。每次触发时 useEffect，它都会捕获本次调用时组件中的数据，也就是所谓的 Capture Value 特性：组件每次渲染都有自己的数据，组件内的函数(包括 effects，事件处理函数，定时器或者 API 调用等)会捕获该次渲染的组件数据。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:1:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"状态同步 首先看这段代码，请判断最终计时器中的 count 和 组件中的 count 分别是多少？ function Counter() { const [count, setCount] = useState(0); console.log(\"组件中的count\", count); useEffect(() =\u003e { console.log(\"触发useEffect\"); const id = setInterval(() =\u003e { console.log(\"计时器中的count\", count); setCount(count + 1); }, 1000); return () =\u003e { console.log(\"销毁了定时器\"); clearInterval(id); } }, []); return \u003ch1\u003e{count}\u003c/h1\u003e; } 答案分别是 0 和 1，多少有点基础的人都能想通或者猜对。现在更改需求，让组件中的 count 每秒加 1。我们有两种写法： 不对依赖数组撒谎 // 每次因 count 变化触发的重渲染都会触发 useEffect function Counter() { const [count, setCount] = useState(0); console.log(\"组件中的count\", count); useEffect(() =\u003e { console.log(\"触发useEffect\"); const id = setInterval(() =\u003e { console.log(\"计时器中的count\", count); setCount(count + 1); }, 1000); return () =\u003e { console.log(\"销毁了定时器\"); clearInterval(id); } }, [count]); return \u003ch1\u003e{count}\u003c/h1\u003e; } 每次重渲染创建 Counter 组件时都会触发 useEffect，销毁上一次的计数器，并创建新的计数器。因此组件中的 count 和计时器中的 count 是同步的。 让 Effect 自给自足 // 移除 useEffect 的非必需的依赖，减少不必要的触发。 function Counter() { const [count, setCount] = useState(0); console.log(\"组件中的count\", count); useEffect(() =\u003e { console.log(\"触发useEffect\"); const id = setInterval(() =\u003e { console.log(\"计时器中的count\", count); // 这里接收的函数描述 count 如何变化(action) setCount(c =\u003e c + 1); }, 1000); return () =\u003e { console.log(\"销毁了定时器\"); clearInterval(id); } }, []); return \u003ch1\u003e{count}\u003c/h1\u003e; } 通过控制台我们发现，计时器中的 count 始终为 0，怎么解释？useEffect 只在组件初次渲染后触发一次，它创建了计时器，计时器记住了当时的 count。既然计时器中的 count 始终为 0，那么 setCount 是怎样让组件状态同步的呢？想搞清楚这一点就不得不提 useReducer 了。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:2:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"useReducer 事实上，useState 是预置了如下 reducer 的 useReducer，相关 源码 ： function basicStateReducer\u003cS\u003e(state: S, action: BasicStateAction\u003cS\u003e): S { return typeof action === 'function' ? action(state) : action; } 也就是说，setCount 接收的 action 函数是在下一次函数组件渲染时，在 useState 中调用的。描述动作和执行动作分开进行，感觉有 Redux 的内味了？没错，React 还为 useReducer 提供了配套的 dispatch 方法： const [state, dispatch] = useReducer(reducer, initialArg, init); 再次更改需求，我们不让计时器每秒加 1，而是由输入的 step 控制。还是对比两种写法： 不对依赖数组撒谎 function Counter() { const [count, setCount] = useState(0); const [step, setStep] = useState(0); useEffect(() =\u003e { const id = setInterval(() =\u003e { setCount(count =\u003e count + step); }, 1000); return () =\u003e clearInterval(id); }, [step]); ... } 让 Effect 自给自足 const initialState = { count: 0, step: 0, }; function reducer(state, action) { const { count, step } = state; if (action.type === 'tick') { return { count: count + step, step }; } else if (action.type === 'step') { return { count, step: action.step }; } else { throw new Error(); } } function Counter() { const [state, dispatch] = useReducer(reducer, initialState); const { count, step } = state; useEffect(() =\u003e { const id = setInterval(() =\u003e { dispatch({ type: 'tick' }); }, 1000); return () =\u003e clearInterval(id); }, []); return ( \u003cdiv\u003e \u003ch1\u003e{count}\u003c/h1\u003e \u003cinput value={step} onChange={e =\u003e { dispatch({ type: 'step', step: Number(e.target.value) }); }} /\u003e \u003cdiv/\u003e ); } 移除 useEffect 的非必需的依赖，就能减少不必要的触发，是一种性能优化思路。还有一种思路是保持 useEffect 的依赖不变，也能减少不必要的触发，这会用到 useCallback 和 useMemo。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:3:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"useCallback React 判断组件中的数据是否发生改变时使用了 Object.is 进行比较。当 useEffect 的依赖数组的元素为引用数据类型时，每次的比较结果都是发生改变，这就失去了依赖数组本身的意义(条件式地触发 useEffect)。看这段代码，我们希望复用网络请求逻辑，这样可行吗？ function SearchResults() { const getFetchUrl = (query) =\u003e { return 'https://hn.algolia.com/api/v1/search?query=' + query; }; useEffect(() =\u003e { const url = getFetchUrl('react'); // Fetch data and do something ... }, [getFetchUrl]); useEffect(() =\u003e { const url = getFetchUrl('redux'); // Fetch data and do something ... }, [getFetchUrl]); ... } 当我们写这段代码时，我们发现网络请求将无限重复，因为函数调用会生成不同引用。一个可能的解决办法是把 getFetchUrl 从依赖中去掉，前提是你能确保它不受数据流变化的影响，否则就会出现意想不到的 bugs。 然而 useEffect 的设计意图就是要强迫你关注数据流的变化，然后去同步状态。当不能把函数从依赖中去掉时，我们可以使用 useCallback 来包装函数从而确保函数的引用相等： /** useCallback 在其依赖变化时，才生成新的函数 * 现在依赖为空，getFetchUrl 永远调用同一个函数 */ const getFetchUrl = useCallback((query) =\u003e { return 'https://hn.algolia.com/api/v1/search?query=' + query; }, []); 更改 getFetchUrl 后就能避免网络请求重复的问题了。useCallback 本质上是对函数添加了一层依赖检查，让函数只在需要改变的时候才改变。 useCallback 的另一个使用场景：当父组件传递函数给子组件的时候，由于父组件的更新会导致该函数重新生成，从而传递给子组件的函数引用发生变化，这就会导致子组件也会更新，这时我们可以通过 useCallback 来缓存该函数，然后传递给子组件同一个函数避免子组件更新(子组件需用 memo 包装)，看这篇 文章 的例子。 useMemo 扩展了 useCallback 的功能，useCallback 只能缓存函数，而 useMemo 可以缓存任何类型的值，同样是为了确保引用相等。除此之外，useMemo 还可以用于避免重复计算。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:4:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"useRef 现在来看这个例子，我们连续点击 Add count 按钮时，3s 后会发生什么？ function Counter() { const [count, setCount] = useState(0); useEffect(() =\u003e { setTimeout(() =\u003e { console.log(count); }, 3000); }); return ( \u003cdiv\u003e \u003ch1\u003e{count}\u003c/h1\u003e \u003cbutton onClick={()=\u003esetCount(count+1)}\u003eAdd count\u003c/button\u003e \u003cdiv/\u003e ); } 3s 后会在控制台依次打印 count 的值 1，2，3 …，然而在一些场景中，我们只想得到最新的 count 值，该怎么做？这就会用到 useRef，useRef 返回一个可变的 ref 对象，它的属性 current 被初始化为传入的参数，并且 useRef 始终返回同一个 ref 对象。 function Counter() { const [count, setCount] = useState(0); const latestCount = useRef(count); useEffect(() =\u003e { latestCount.current = count; setTimeout(() =\u003e { console.log(latestCount.current); }, 3000); }); return ( \u003c\u003e \u003ch1\u003e{count}\u003c/h1\u003e \u003cbutton onClick={()=\u003esetCount(count+1)}\u003eAdd count\u003c/button\u003e \u003c/\u003e ); } 现在我们连续点击会发现 3s 后控制台将多次打印最新的 count 值，这证明我们修改的是同一个 ref 对象。除了用来缓存变量，useRef 还能获得 DOM 元素，需要在元素上绑定 ref 属性： function RefDemo() { const titleRef = useRef(); function changeDOM() { titleRef.current.innerHTML = 'hello world'; titleRef.current.style.color = 'red'; } return ( \u003cdiv\u003e \u003ch2 ref={titleRef}\u003eRefDemo\u003c/h2\u003e \u003cbutton onClick={changeDOM}\u003e修改DOM\u003c/button\u003e \u003c/div\u003e ); } ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:5:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"思考 暂时就先这样吧，后面还会再补充。 参考资料 A Complete Guide to useEffect ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:6:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"现在，我们遵循 React 16.8 的代码体系结构，一步一步地构建我们自己的 mini React。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:0:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"基础回顾 开始之前，我们先回顾 React 是怎么将 JSX 转换成 DOM 节点的： const element = \u003ch1 title=\"foo\"\u003eHello\u003c/h1\u003e const container = document.getElementById(\"root\") ReactDOM.render(element, container) 第一行使用 JSX 来创建元素，但 JSX 不是有效的 JS 代码。React 用 Babel 将 JSX 代码转换为原生 JS 代码。转换过程就是调用 createElement 函数，并将 JSX 的元素类型、props 属性和 childen 元素作为参数依次传入： const element = \u003ch1 title=\"foo\"\u003eHello\u003c/h1\u003e // Babel 调用 createElement 函数完成转换 const element = React.createElement( \"h1\", { title: \"foo\" }, \"Hello\" ) // createElement 根据参数生成 object const element = { type: \"h1\", props: { title: \"foo\", children: \"Hello\", }, } 这就是 React 元素的本质，包含 type 和 props 属性的对象(还有其他属性，我们只关注这两个)。现在我们就能用 element 生成 DOM 节点了。 ​const container = document.getElementById(\"root\") ​ const node = document.createElement(element.type) node[\"title\"] = element.props.title ​ const text = document.createTextNode(\"\") text[\"nodeValue\"] = element.props.children ​ node.appendChild(text) container.appendChild(node) ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:1:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"渲染阶段 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"createElement 现在我们来实现自己的 createElement 函数。注意一个细节，JSX 叶子节点可能是基本数据类型。我们把它包装为对象，统一数据类型(React 不会包装基本类型值或创建空数组，我们这样做是为了数据判断和修改的方便)。 function createElement(type, props, ...children) { return { type, props: { ...props, children: children.map(child =\u003e typeof child === \"object\" ? child : createTextElement(child) ) } }; } function createTextElement(text) { return { type: \"TEXT_ELEMENT\", props: { nodeValue: text, children: [] } }; } ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:1","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"render 创建 DOM 节点并添加元素的 props 属性。 function render(element, container) { const dom = element.type == \"TEXT_ELEMENT\" ? document.createTextNode(\"\") : document.createElement(element.type); const isProperty = key =\u003e key !== \"children\"; Object.keys(element.props) .filter(isProperty) .forEach(name =\u003e { dom[name] = element.props[name]; }); element.props.children.forEach(child =\u003e render(child, dom)); container.appendChild(dom); } 现在将我们的库取名 Didact，让 Babel 调用我们的库转换 JSX。 const Didact = { createElement, render }; /** @jsx Didact.createElement */ const element = ( \u003cdiv style=\"background: salmon\"\u003e \u003ch1\u003eHello World\u003c/h1\u003e \u003ch2 style=\"text-align:right\"\u003efrom Didact\u003c/h2\u003e \u003c/div\u003e ); const container = document.getElementById(\"root\"); Didact.render(element, container); 这样就实现了 JSX 的转换和渲染，在 codesandbox 中试试看。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:2","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Concurrent 在我们加入更多特性之前我们先对代码进行一次重构。因为递归调用存在一个问题：渲染开始就会一直阻塞主进程。如果浏览器需要处理一些高优先级的任务(像用户输入或者保持动画流畅)，需要等到所有元素渲染完成之后再进行处理，这是不好的用户体验。 let nextUnitOfWork = null ​ function workLoop(deadline) { let shouldYield = false while (nextUnitOfWork \u0026\u0026 !shouldYield) { // 迭代子任务 nextUnitOfWork = performUnitOfWork( nextUnitOfWork ) shouldYield = deadline.timeRemaining() \u003c 1 } requestIdleCallback(workLoop) } ​// 主进程空闲时才会调用回调函数 requestIdleCallback(workLoop) ​// 执行当前子任务并返回下一个子任务 function performUnitOfWork(nextUnitOfWork) { // TODO } 现在我们拆分整个任务为一个个小的子任务，浏览器可以在执行完每个小任务后中断渲染流程去处理其他事情。因为我们使用 reqeustIdleCallback 来创建一个循环任务(React 现在使用 scheduler)，它在主进程空闲时才会执行回调函数，它为回调函数提供一个 deadline 参数，据此我们可以知晓还剩多少时间浏览器会拿回控制权。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:3","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Fibers 我们使用 fiber 树连接所有子任务，为每个元素创建一个 fiber，每个 fiber 对应一个子任务。假如我们渲染如下一颗元素树： Didact.render( \u003cdiv\u003e \u003ch1\u003e \u003cp /\u003e \u003ca /\u003e \u003c/h1\u003e \u003ch2 /\u003e \u003c/div\u003e, container ) 生成对应的 fiber 树： \r在渲染中，我们将 container 创建为 root 并将其设置为 nextUnitOfWork。而元素的 fiber 由 performUnitOfWork 生成，我们将为每个 fiber 做三件事： 1.将元素添加到 DOM 中。 2.为元素的子元素创建 fiber。 3.寻找下一个子任务。 现在我们从 render 中提取出创建 DOM 节点的逻辑，稍后我们会使用它。 function createDom(fiber) { const dom = fiber.type == \"TEXT_ELEMENT\"? document.createTextNode(\"\"): document.createElement(fiber.type) const isProperty = key =\u003e key !== \"children\" Object.keys(fiber.props) .filter(isProperty) .forEach(name =\u003e { dom[name] = fiber.props[name] }) ​ return dom } 在 render 函数中，我们将 nextUnitOfWork 的 DOM 属性设置为 container。 function render(element, container) { nextUnitOfWork = { dom: container, props: { children: [element], }, } } ​ let nextUnitOfWork = null 接下来在 performUnitOfWork 中完成每个 fiber 的三件事。 function performUnitOfWork(fiber) { // 需要与父节点的 DOM 连接时才创建 DOM 节点 if (!fiber.dom) { fiber.dom = createDom(fiber) } ​ if (fiber.parent) { fiber.parent.dom.appendChild(fiber.dom) } ​ // 为子元素创建 newFiber，dom 属性为空 const elements = fiber.props.children let index = 0 let prevSibling = null ​ while (index \u003c elements.length) { const element = elements[index] ​ const newFiber = { type: element.type, props: element.props, parent: fiber, dom: null, } if (index === 0) { fiber.child = newFiber } else { prevSibling.sibling = newFiber } ​ prevSibling = newFiber index++ } // 寻找下一个子任务，优先级依次是子节点、兄弟节点、叔叔节点。 if (fiber.child) { return fiber.child } let nextFiber = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } } ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:4","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Commit 处理元素时我们每次向 DOM 添加一个新节点。但浏览器是会中断渲染过程的，这样用户会看到不完整的 UI。我们怎么避免这种情况呢？答案是重构操作 DOM 的代码。 首先在删除 performUnitOfWork 中添加 DOM 节点的代码： // if (fiber.parent) { // fiber.parent.dom.appendChild(fiber.dom) // } 然后在 render 中用 wipRoot 保存 fiber root 节点。 function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, } nextUnitOfWork = wipRoot } ​ let nextUnitOfWork = null let wipRoot = null 直到本次全部元素渲染结束时，我们才将整个 fiber 树提交到 DOM 中。 function commitRoot() { // 将所有元素的 fiber 递归附加到 DOM commitWork(wipRoot.child) wipRoot = null } ​ function commitWork(fiber) { if (!fiber) { return } const domParent = fiber.parent.dom domParent.appendChild(fiber.dom) commitWork(fiber.child) commitWork(fiber.sibling) } function workLoop(deadline) { let shouldYield = false while (nextUnitOfWork \u0026\u0026 !shouldYield) { nextUnitOfWork = performUnitOfWork( nextUnitOfWork ) shouldYield = deadline.timeRemaining() \u003c 1 } ​ // 直到没有下一个子任务，将整个 fiber 树提交到 DOM 节点中 if (!nextUnitOfWork \u0026\u0026 wipRoot) { commitRoot() } requestIdleCallback(workLoop) } ​// 主进程空闲时才会调用回调函数 requestIdleCallback(workLoop) ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:5","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"更新阶段 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:3:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Reconciliation 到目前为止，我们只是将元素添加到了 DOM 中，但是我们怎么去更新或者删除节点呢？(diff) 在每个 fiber 中添加 alternate 属性保存上一次提交到 DOM 中的 fiber。先在 wipRoot 中添加： function commitRoot() { commitWork(wipRoot.child) // 渲染结束时存储当前的 fiber root currentRoot = wipRoot wipRoot = null } ​ function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, alternate: currentRoot, } nextUnitOfWork = wipRoot } ​ let nextUnitOfWork = null // 增加 currentRoot 用于保存当前提交到 DOM 中的 fiber 树 let currentRoot = null let wipRoot = null 将 performUnitOfWork 中创建新 fiber 的逻辑移到 reconcileChildren 函数中，给每个子 fiber 添加 alternate 和 effectTag 属性(effectTag 属性用于 Commit 阶段)： // 协调(比较和复用)当前 fiber 的所有子 fiber function reconcileChildren(wipFiber, elements) { let index = 0 let oldFiber = wipFiber.alternate \u0026\u0026 wipFiber.alternate.child let prevSibling = null while ( index \u003c elements.length || oldFiber != null ) { const element = elements[index] let newFiber = null const sameType = oldFiber \u0026\u0026 element \u0026\u0026 element.type == oldFiber.type // 需要添加新的 fiber if (element \u0026\u0026 !sameType) { newFiber = { type: element.type, props: element.props, dom: null, parent: wipFiber, alternate: null, effectTag: \"PLACEMENT\", } } // 需要更新原来的 fiber if (sameType) { newFiber = { type: oldFiber.type, props: element.props, dom: oldFiber.dom, parent: wipFiber, // oldFiber 被替换时才需要用 alternate 保存 alternate: oldFiber, effectTag: \"UPDATE\", } } // 需要删除原来的 fiber if (oldFiber \u0026\u0026 !sameType) { oldFiber.effectTag = \"DELETION\" } if (oldFiber) { oldFiber = oldFiber.sibling } if (index === 0) { wipFiber.child = newFiber } else if (element) { prevSibling.sibling = newFiber } prevSibling = newFiber index++ } } ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:3:1","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Commit 现在我们需要修改 commitWork 函数完成 DOM 的修改。 function commitWork(fiber) { if (!fiber) { return } const domParent = fiber.parent.dom if ( fiber.effectTag === \"PLACEMENT\" \u0026\u0026 fiber.dom != null ) { domParent.appendChild(fiber.dom) } else if ( fiber.effectTag === \"UPDATE\" \u0026\u0026 fiber.dom != null ) { updateDom( fiber.dom, fiber.alternate.props, fiber.props ) } else if (fiber.effectTag === \"DELETION\") { domParent.removeChild(fiber.dom) } commitWork(fiber.child) commitWork(fiber.sibling) } 这里的 updateDom 就是用来更新 DOM 节点的属性。 const isProperty = key =\u003e key !== \"children\" \u0026\u0026 !isEvent(key) const isEvent = key =\u003e key.startsWith(\"on\") const isNew = (prev, next) =\u003e key =\u003e prev[key] !== next[key] const isGone = (prev, next) =\u003e key =\u003e !(key in next) function updateDom(dom, prevProps, nextProps) { // 删除旧的属性 Object.keys(prevProps) .filter(isProperty) .filter(isGone(prevProps, nextProps)) .forEach(name =\u003e { dom[name] = \"\" }) // 删除旧的事件监听 Object.keys(prevProps) .filter(isEvent) .filter( key =\u003e !(key in nextProps) || isNew(prevProps, nextProps)(key) ) .forEach(name =\u003e { const eventType = name .toLowerCase() .substring(2) dom.removeEventListener( eventType, prevProps[name] ) }) // 设置新的属性 Object.keys(nextProps) .filter(isProperty) .filter(isNew(prevProps, nextProps)) .forEach(name =\u003e { dom[name] = nextProps[name] }) // 添加新的事件监听 Object.keys(nextProps) .filter(isEvent) .filter(isNew(prevProps, nextProps)) .forEach(name =\u003e { const eventType = name .toLowerCase() .substring(2) dom.addEventListener( eventType, nextProps[name] ) }) } 在 codesandbox 中查看完整代码。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:3:2","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"函数组件 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:4:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Commit 现在，我们考虑在已有代码的基础上，增加对函数组件和 Hooks 的支持。看这个函数组件： /** @jsx Didact.createElement */ function App(props) { return \u003ch1\u003eHi {props.name}\u003c/h1\u003e } const element = \u003cApp name=\"foo\" /\u003e const container = document.getElementById(\"root\") Didact.render(element, container) 如果我们将 jsx 转换为 js，Babel 的解析方式会是这样： function App(props) { return Didact.createElement( \"h1\", null, \"Hi \", props.name ) } // 这里虽然会调用 createElement，但并不会调用 App 获取子元素 const element = Didact.createElement(App, {name: \"foo\"}, ) 观察 Babel 的解析后会发现： 我们不能为函数 App 创建 DOM 节点，因为没有 html 标签，只能渲染它的子元素。 子元素不会通过 createElement 的第三个参数传递，子元素需手动调用函数获取。 为函数创建子 fiber 我们可以这样做： function updateFunctionComponent(fiber) { // 由于 Babel 调用 createElement，得到的 fiber.type 就是函数名 const children = [fiber.type(fiber.props)] reconcileChildren(fiber, children) } 我们需要修改 commitWork，因为函数的 fiber 没有 DOM 节点。我们要考虑如果在 fiber 树中存在无 DOM 节点的 fiber 时，如何连接 DOM： 要找到一个 DOM 节点的父节点，我们需要找到一个包含 DOM 节点的 fiber。 当需要移除一个 fiber 节点时，我们需要找到一个包含 DOM 节点的子节点。 function commitWork(fiber) { if (!fiber) { return } // 寻找到包含 DOM 的父节点 let domParentFiber = fiber.parent while (!domParentFiber.dom) { domParentFiber = domParentFiber.parent } const domParent = domParentFiber.dom ​ if ( fiber.effectTag === \"PLACEMENT\" \u0026\u0026 fiber.dom != null ) { domParent.appendChild(fiber.dom) } else if ( fiber.effectTag === \"UPDATE\" \u0026\u0026 fiber.dom != null ) { updateDom( fiber.dom, fiber.alternate.props, fiber.props ) } else if (fiber.effectTag === \"DELETION\") { // 寻找到包含 DOM 的子节点 commitDeletion(fiber,domParent); } commitWork(fiber.child) commitWork(fiber.sibling) } function commitDeletion(fiber, domParent) { if (fiber.dom) { domParent.removeChild(fiber.dom) } else { commitDeletion(fiber.child, domParent) } } ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:4:1","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Hooks 最后一步，既然我们使用了函数组件，那么就要给它加上状态。 首先更新为函数创建子 fiber 的函数： let wipFiber = null let hookIndex = null ​ function updateFunctionComponent(fiber) { wipFiber = fiber // 记录当前 hook 的索引 hookIndex = 0 // 支持在同一个组件中多次调用 useState 函数 wipFiber.hooks = [] const children = [fiber.type(fiber.props)] reconcileChildren(fiber, children) } 然后我们写自己的 useState 函数： function useState(initial) { const oldHook = wipFiber.alternate \u0026\u0026 wipFiber.alternate.hooks \u0026\u0026 wipFiber.alternate.hooks[hookIndex] // 如果存在旧的 hook，我们从旧的 hook 中拷贝状态到新的 hook const hook = { state: oldHook ? oldHook.state : initial, queue:[] } // 拿到 action(更新状态的回调函数) 处理 state const actions = oldHook ? oldHook.queue : [] actions.forEach(action =\u003e { hook.state = action(hook.state) }) // setState 将 action 添加到 hook 的 queue 中 ​ const setState = action =\u003e { hook.queue.push(action) wipRoot = { dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot, } // 重新渲染这颗 fiber tree nextUnitOfWork = wipRoot } wipFiber.hooks.push(hook) hookIndex++ // 返回 state 和 setState return [hook.state, setState] } 就这样，我们构建出了我们自己的 mini React，在 codesandbox 中查看完整代码。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:4:2","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"经验总结 本文的目的之一是让你更轻松地深入学习 React，这就是我们在几乎所有地方都使用与 React 相同的变量和函数名称的原因。但是我们构建的代码库并没有包含很多的 React 特性以及优化，以下是 React 与我们的实现做得不同的地方： 我们的渲染阶段会遍历整棵树，而 React 会跳过那些没有发生改变的子树。 我们会在提交阶段遍历整个树，而 React 只会保留产生影响的 fiber 节点。 我们为每个 fiber 创建一个新的对象，而 React 会复用之前树上的 fiber 节点。 我们在渲染阶段收到一个新的更新时，会丢弃之前的工作树，从根节点重新开始。而 React 给每一个更新标记一个过期时间戳，通过这个时间戳来决定各个更新之间的优先级。 除此之外还有很多… 参考资料 Build your own React ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:5:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"本文是我最近阅读一篇英文技术文章后写的小结。阅读前请注意，本文不涉及任何 Recoil 源码。仿写的代码并不是 Recoil 真正的实现方式，本文只仿造实现了 Recoil 中两个重要的 API 接口：Atom 和 Selector。 如果你不熟悉 Recoil，请先阅读我的这篇 文章 或者阅读它的 官方文档。然后新建 React 项目： npx create-react-app recoil-clone --typescript 在根目录下新建 coiled.tsx 文件，下面的代码都在这个文件中实现。 ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:0:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"状态基类 定义一个 Stateful 表示共享状态的基类，Atom 和 Selector 需继承这个基类。为了监听状态的变化，我们使用观察者模式。这种设计模式在 RxJS 之类的库中很常见，我将从头开始编写一个简单的同步版本。 interface Disconnect { disconnect: () =\u003e void; } export class Stateful\u003cT\u003e { // Set 是 callback 的集合 private listeners = new Set\u003c() =\u003e void\u003e(); constructor(protected value: T) {} // 取值函数 snapshot(): T { return this.value; } // 此处才会调用所有的监听者 private emit() { for (const listener of Array.from(this.listeners)) { console.log('调用监听者: ' + listener); listener(); } } // update 方法可以被 Stateful 的子类 Atom 和 Selector 继承 protected update(value: T) { if (this.value !== value) { this.value = value; console.log('新值: ' + this.value); this.emit(); } } // 订阅就加入监听者的 Set 集合，此方法接收 callback，返回也是 callback subscribe(callback: () =\u003e void): Disconnect { console.log('注册监听者：' + callback); this.listeners.add(callback); return { disconnect: () =\u003e { console.log('注销监听者：' + callback); this.listeners.delete(callback); }, }; } } ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:1:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"自定义 hook 下面是只读 hook 的实现方式。atom 和 selector 均可读，因此参数只需满足 Stateful 类型。这里注册的监听者 updateState 巧妙地利用了函数组件的重渲染机制，因为 useState 的参数为引用数据类型，{} === {} 的值为 false，因此只要调用 updateState 函数就会重渲染组件。关于 React 组件何时会重渲染可以读这篇 文章。 export function useCoiledValue\u003cT\u003e(value: Stateful\u003cT\u003e): T { // 只要调用 updateState 就会触发重渲染 const [, updateState] = useState({}); useEffect(() =\u003e { console.log('渲染结束调用 useEffect, 添加监听者') // 注册 updateState 为监听者, 监听者是 callback 的 Set 集合 const { disconnect } = value.subscribe(() =\u003e updateState({})); return () =\u003e disconnect(); }, [value]); console.log('此时 useCoiledValue 的值: ' + value.snapshot()); return value.snapshot(); } 下面是读写 hook 的实现方式，这里的读写 hook 只适用于 atom，默认 selector 不可写。 export function useCoiledState\u003cT\u003e(atom: Atom\u003cT\u003e): [T, (value: T) =\u003e void] { const value = useCoiledValue(atom); return [value, useCallback(value =\u003e atom.setState(value), [atom])]; } ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:2:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"Atom Atom 继承 Stateful，需要一个默认的写值方法。 export class Atom\u003cT\u003e extends Stateful\u003cT\u003e { public setState(value: T) { super.update(value); } } 暴露的接口函数是仿写 Recoil 中的 atom 函数。 export function atom\u003cV\u003e(value: { key: string; default: V }): Atom\u003cV\u003e { return new Atom(value.default); } ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:3:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"Selector Selector 继承 Stateful，Selector 是 Atom 或其他 Selector 的派生值，因此需要添加依赖。 export class Selector\u003cT\u003e extends Stateful\u003cT\u003e { // 将 dep 加入 Set 集合 private registeredDeps = new Set\u003cStateful\u003cany\u003e\u003e(); private addDep\u003cV\u003e(dep: Stateful\u003cV\u003e): V { if (!this.registeredDeps.has(dep)) { // 注册 updateSelector 为监听者，并将 dep 加入 Set 集合 dep.subscribe(() =\u003e this.updateSelector()); this.registeredDeps.add(dep); } return dep.snapshot(); } // 调用 generate 直接返回当前的 dep 值 private updateSelector() { this.update(this.generate({ get: dep =\u003e this.addDep(dep) })); } constructor(private readonly generate: SelectorGenerator\u003cT\u003e) { super(undefined as any); this.value = generate({ get: dep =\u003e this.addDep(dep) }); } } // selector 接收 atom 或者其他 selector 作为依赖 type SelectorGenerator\u003cT\u003e = (context: { get: \u003cV\u003e(dep: Stateful\u003cV\u003e) =\u003e V }) =\u003e T; 暴露的接口函数是仿写 Recoil 中的 selector 函数。 export function selector\u003cV\u003e(value: { key: string; get: SelectorGenerator\u003cV\u003e; }): Selector\u003cV\u003e { return new Selector(value.get); } ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:4:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"使用 将 index.tsx 作如下修改后，启动项目 yarn start，查看浏览器的 cosole 面板，项目成功运行。 import React from 'react'; import ReactDOM from 'react-dom'; import { atom, useCoiledState, useCoiledValue, selector } from './coiled'; import './App.css'; const textState = atom\u003cstring\u003e({ key: 'textState', default: '', }); const charCountState = selector\u003cnumber\u003e({ key: 'charCountState', get: ({get}) =\u003e { const text = get(textState); return text.length; }, }); function TextInput() { const [text, setText] = useCoiledState(textState); const onChange = (event: any) =\u003e { setText(event.target.value); }; return ( \u003cdiv\u003e \u003cinput type=\"text\" value={text} onChange={onChange} /\u003e \u003cbr /\u003e Echo: {text} \u003c/div\u003e ); } function CharacterCount() { const count = useCoiledValue(charCountState); return \u003c\u003eCharacter Count: {count}\u003c/\u003e; } function App() { return ( \u003cdiv className=\"App\"\u003e \u003cTextInput /\u003e \u003cCharacterCount /\u003e \u003c/div\u003e ); } ReactDOM.render(\u003cApp /\u003e, document.getElementById('root')); 在 codesandbox 中查看完整代码。 ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:5:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"思考 我们仿造 Recoil 实现了自己的状态共享。但请思考以下内容： Selectors 不会取消对 atoms 的监听。这意味着当你不再使用他们时，会造成内存泄漏。 Selectors 和 Atoms 在重渲染前仅做一个浅比较。在某些场景下，使用深比较更加合理。 Recoil 使用唯一 key 值标识每一个 atom 或 selector，并且它被用作支持 “App-wide observation” 的元数据。这里的实现仅仅是为了保持 API 相似。 Recoil 在 selectors 里支持异步，这里没有实现这个特性。 我在 github 上发现了 jotai 项目。它与我的仿写非常相似，并且支持异步。 参考资料 Rewriting Facebook’s “Recoil” React library … ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:6:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"我们知道，如今流行的前端框架都是 SPA(单页应用)，在投入生产时会出现中首屏加载慢，不利于 SEO 等问题。于是，现代前端同构框架应运而生。Next.js 是 React 的同构框架，它的页面由 React 组件构成。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:0:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"路由系统 Next.js 的路由系统基于文件路径自动映射，一般约定在根目录的 pages 文件夹内： pages/index.js –\u003e / pages/about.js –\u003e /about pages/blog/[slug].js –\u003e /blog/:slug( slug 是动态生成的) pages/post/[...all].js–\u003e /post/*(匹配 /post,/post/a,/post/a/b 等) Next.js 创建的是多页应用，pages 内的每个文件都是单个页面。Next.js 中用形如 [params] 文件(文件夹)表示动态路由页面。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:1:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"路由跳转 Next.js 中路由跳转方式有两种，使用的 api 分别是 next/link 和 next/router。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"next/link 从 next/link 导入的 \u003cLink\u003e 是 React 组件，可接收以下属性: href 是导航到的路径，是页面跳转的必需属性，href 可以是字符串或者对象 \u003cLink href=\"/about?name=jackylin\"\u003e //这里 href 有两层 {}, github page 无法识别语法，只能写为一层了 \u003cLink href={ pathname: \"/about\", query: { name: \"jackylin\" },}\u003e as 是浏览器 url 栏显示的路径，当 href 中包含动态页面 ([param]) 时使用 const pids = ['id1', 'id2', 'id3'] { pids.map((pid, index) =\u003e ( \u003cLink href='/post/[pid]' as={`/post/${pid}`} key='index'\u003e \u003ca\u003ePost {pid}\u003c/a\u003e \u003c/Link\u003e ))} passHref 将 \u003cLink\u003e 的 href 传递给子项，当子项是包装 \u003ca\u003e 的组件时，此属性必需 prefetch 预加载，将页面提前加载到本地缓存 官方文档还有一些其他 属性 和用法示例，需要注意的是 \u003cLink\u003e 只能有一个子项。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"next/router 相较于 next/link，next/router 能自定义配置复杂的路由跳转。next/router 提供如下 api： useRouter 是 React hook，只能用于函数组件 withRouter 是高阶组件，可用于类组件和函数组件 他们的实例对象 router 具有以下的属性，方法，事件等。 属性：pathname 是文件名，query 是查询参数，asPath 是浏览器中显示的路径。 方法：router.push(url, as, options) 是路由跳转方法，跳转的页面路径(url)必需。url 可以是字符串形式，也可以是对象形式。在需路由跳转的元素上绑定点击事件。 export default function ReadPost({ post }) { const router = useRouter() return ( \u003cspan onClick={() =\u003e { router.push({ pathname: '/post/[pid]', query: { pid: post.id }, }) }} \u003e 查看文章 \u003c/span\u003e ) } 对比前面讲的 \u003cLink\u003e 组件，能看出 \u003cLink\u003e 组件其实是封装了 router，点击事件等。 事件：Next.js 在路由跳转的生命周期内置了一些的钩子事件，若我们有监听路由变化的需求，可订阅这些钩子事件来实现需求。具体用法请参阅 官方文档。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"路由传参 Next.js 支持查询字符串格式的参数传递，参数以字符串或者对象的格式传递: \u003cLink\u003e 的 href 属性或者 router.push 中的 url。参数的接收可以用 useRouter 或 withRouter: // router 直接读取参数 const Post = () =\u003e { const router = useRouter(); return ( \u003cdiv\u003e文章编号：{router.query.pid}\u003c/div\u003e ) } export default Post //使用 withRouter 接收参数时，router 作为组件参数 const Post = ({ router }) =\u003e { return ( \u003cdiv\u003e文章编号：{router.query.pid}\u003c/div\u003e ) } export default withRouter(Post) ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"获取数据 Next.js 中获取数据的方法有 getServerSideProps，getStaticProps 和 getStaticPaths。还有一个 getInitialProps，官方文档已不推荐使用。这些方法都是服务端的异步方法，只能在 pages 文件夹内使用。 Next.js 有两种预渲染形式： 服务端渲染(SSR)：html 在每次访问路由时都会重新生成。对应的数据获取方法：getServerSideProps。由于“服务端渲染”比“静态生成”慢，因此常用于数据频繁更新的页面。 静态生成(SSG)：html 是在构建时生成的，并且会在每次请求时重用。对应的数据获取方法： getStaticProps 和 getStaticPaths。这对于可以在用户请求之前就预渲染的页面非常有用，可以将其与客户端渲染结合使用以引入其他数据。 Next.js 引入了自动静态优化的功能，就是说如果页面中没有使用 SSR 方法，Next.js 在 build 阶段就会生成 html，访问页面路由直接返回生成的 html，以此来提升性能。 选择 SSR 还是 SSG？ 如果页面内容真动态(例如来源数据库且经常变化)，使用 SSR。 如果是静态页面或者伪动态(来源数据库但是不变化)，使用 SSG。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"getServerSideProps 在数据频繁更新的页面使用，每次访问路由时都会调用。getServerSideProps 方法是升级了 9.3 之前的 getInitialProps 方法。 const Blog = ({ data }) =\u003e { return \u003cdiv\u003etitle: {data.title}\u003c/div\u003e } // 在每次页面请求时才会运行，在构建时不运行。 export async function getServerSideProps() { const res = await fetch('https://jsonplaceholder.typicode.com/todos/1') const data = await res.json() return { props: {data} } } export default Blog ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"getStaticProps 页面内容取决于外部数据时使用。 // posts 依赖外部数据 const Blog = ({ posts }) =\u003e { return \u003cdiv\u003etitle: {posts.title}\u003c/div\u003e } // 此函数只在构建时被调用一次，后面不会再次调用 export async function getStaticProps() { // 调用外部 API 获取内容 const res = await fetch('https://jsonplaceholder.typicode.com/todos/1') const posts = await res.json() // 在构建时将接收到 `posts` 参数 return { props: { posts, }, } } export default Blog ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"getStaticPaths 页面路径取决于外部数据时使用，结合 getStaticProps 使用。 const Post = ({ post }) =\u003e { return ( \u003cdiv\u003e文章id: {post.id}, 文章标题: {post.title}\u003c/div\u003e ) } // 此函数只在构建时被调用一次，后面不会再次调用 export async function getStaticPaths() { // 取全部文章数据 const res = await fetch('https://jsonplaceholder.typicode.com/todos') const posts = await res.json() const paths = posts.map(post =\u003e `/posts/${post.id}`) // fallback为 false，表示不在 getStaticPaths 的路径是 404 页面。 return { paths, fallback: false } } // params 来自 paths: [{ params: { ... } }] export async function getStaticProps({ params }) { // 取具体文章数据 const res = await fetch(`https://jsonplaceholder.typicode.com/todos/${params.id}`) const post = await res.json() return { props: { post } } } export default Post api 的更多细节用法请阅读 官方文档。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"其他功能 ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"自定义配置 Next.js 在 pages 文件夹内的默认配置文件有 _app.js,_document.js,404.js 等。 以 _app.js 为例，它的功能是初始化当前路由的页面组件，接口如下： /** * Component 是当前路由的页面组件，每次路由切换时，Component 都会更新 * pageProps 是初始属性，该初始属性由某个数据获取方法预先加载到你的页面中，否则它将是一个空对象 */ function MyApp({ Component, pageProps }) { return \u003cComponent {...pageProps} /\u003e } export default MyApp 比如我们要使用 recoil 进行状态管理，所有页面组件都应该为 \u003cRecoilRoot\u003e 的子组件。 import { RecoilRoot } from 'recoil' export default function MyApp({ Component, pageProps }) { return ( \u003cRecoilRoot\u003e \u003cComponent {...pageProps} /\u003e \u003c/RecoilRoot\u003e ) } 其他配置文件的作用请阅读 官方文档。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"自定义构建 Next.js 根目录 next.config.js 可配置项目构建。例如扩展默认 webpack 配置，接口如下： module.exports = { webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) =\u003e { // Note: we provide webpack above so you should not `require` it config.plugins.push(new webpack.IgnorePlugin(/\\/__tests__\\//)) // Important: return the modified config return config }, } 例如在 Next.js 默认的 babel 配置中添加一个 loader： // https://github.com/vercel/next.js/tree/canary/packages/next-mdx module.exports = { webpack: (config, options) =\u003e { config.module.rules.push({ test: /\\.mdx/, use: [ options.defaultLoaders.babel, { loader: '@mdx-js/loader', options: pluginOptions.options, }, ], }) return config }, } ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"api 路由 Next.js 提供简单的后端 api 能力，在 pages/api 内的文件都将映射为 /api/* 的后端接口。它们不会和页面一起打包。 // pages/api/post.js import {getPosts} from 'lib/posts' const Posts = async (req, res) =\u003e { const posts = await getPosts() res.statusCode = 200 res.setHeader('Content-Type', 'application/json') res.end(JSON.stringify(posts)) } export default Posts 目前 Next.js 没有提供数据库和测试相关的功能，需自行配置或与其他框架配合使用。 参考资料 Next.js 官方文档 Next.js 简明教程 手把手带你入门 NextJs ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":" 在计算机科学中，函数式编程是一种编程范式，其中通过应用和组合函数来构造程序。它是一种声明式编程范式，其中函数定义是每个返回一个值的表达式树，而不是一系列更改程序状态的命令性语句。 – wikipedia ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:0:0","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"声明式与命令式 假设我们有个需求：把下面字符串变成每个单词首字母大写。 const string = 'functional programming is great'; ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:0","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"命令式 如果你没有听说过函数式编程，用传统的编程思路，很自然的写出如下 命令式编程 代码： const string = 'functional programming is great'; let arrays = string.split(' '); let newArray = []; for (let i = 0; i \u003c arrays.length; i++){ let str = arrays[i].slice(0, 1).toUpperCase() + arrays[i].slice(1); newArray.push(str); } const newString = newArray.join(' '); 这样当然能完成任务，结果是产生了一堆临时变量。光是变量名就不好想，同时过程中掺杂了大量逻辑，一个函数需要从头读到尾才知道它具体做了什么，并且一旦出问题很难定位。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:1","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"声明式 声明式编程 被看做是形式逻辑的理论，把计算看做推导。常见的声明式编程有数据库查询(SQL语句)，正则表达式，函数式编程等。函数式编程倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 const string = 'functional programming is great'; const newString = string .split(' ') .map(str =\u003e str.slice(0, 1).toUpperCase() + str.slice(1)) .join(' '); 函数式编程的核心思想：通过函数转换数据，组合多个函数来求结果。 对比两种编程思想：命令式编程考虑我该如何做，而声明式编程考虑我要做什么。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:2","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"核心概念-纯函数 函数式编程中的“函数”指满足以下特性的函数，也被称为 纯函数： 输出仅取决于输入(无状态，每次的执行结果都是可预测和易测试的) 不产生副作用(只计算输出值，不修改输入值，不做其他任何操作) 因此纯函数更像数学中的函数，只是描述输入与输出之间映射关系的表达式。 一个典型的纯函数设计是 redux 中的 reducer。好的我懂了，但是为什么要强调纯函数呢？因为纯函数的特性决定了它的众多优点： ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:0","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"易读易推理 纯函数容易阅读和推理，因为所有依赖关系都由参数提供。这意味着我们只需阅读函数的声明即可快速了解函数的作用及其依赖关系，而不用担心函数内有其他行为(副作用)。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:1","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"移植性 对于常见的普通函数，同一函数不能直接在移植到别的上下文中使用，通常会为了实现同一类功能而编写不同的函数。 // 普通函数 const signUp = function(attrs) { let user = saveUser(attrs); welcomeUser(user); }; // 依赖 Db const saveUser = function(attrs) { let user = Db.save(attrs); ... }; // 依赖 Email const welcomeUser = function(user) { Email(user, ...); ... }; 编写纯函数的好处是它需要的东西都在输入参数中已经声明，所以它方便移植到别的地方，因为它的依赖关系是很清晰的。 // 纯函数 const signUp = function(Db, Email, attrs) { return function() { let user = saveUser(Db, attrs); welcomeUser(Email, user); }; }; const saveUser = function(Db, attrs) { ... }; const welcomeUser = function(Email, user) { ... }; ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:2","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"引用透明性 因为纯函数内部没有全局引用，所以在任何使用纯函数的地方中把纯函数替换成它的执行结果，都不会对程序的整体运行产生影响，不会产生隐性问题。 const greet = (name) =\u003e { return `hello, ${name}`; }; console.log(greet('beijing')); // 可做如下等价替换 console.log('hello, beijing'); ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:3","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"可缓存 纯函数对相同输入总有相同输出，可以根据输入来做缓存，相同的输入可以不做重新计算。 // 下面的代码我们可以发现相同的输入，再第二次调用的时候都是直接取的缓存 let squareNumber = memoize((x) =\u003e { return x*x; }); squareNumber(4); //=\u003e 16 squareNumber(4); // 从缓存中读取输入值为 4 的结果 //=\u003e 16 squareNumber(5); //=\u003e 25 squareNumber(5); // 从缓存中读取输入值为 5 的结果 //=\u003e 25 这是怎么实现的呢? 请看下面的代码: const memoize = (f) =\u003e { // 由于使用了闭包，所以函数执行完后 cache 不会立刻被回收 const cache = {}; return () =\u003e { let arg_str = JSON.stringify(arguments); // 利用 cache 做一个简单的缓存，当这个参数之前使用过时，我们立即返回结果就行 cache[arg_str] = cache[arg_str] || f.apply(f, arguments); return cache[arg_str]; }; }; ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:4","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"并行处理 纯函数不会访问共享的内存，因此不用担心线程的执行顺序，对任何纯表达式的求值都是线程安全的。 const x = f(a); const y = g(b); const z = h(c); // 线程安全 const result = x + y + z; 前三个表达式之间没有数据依赖关系，它们的执行顺序可以颠倒，或者并行执行也互不干扰。只要它们能在分配给 result 之前执行。 说了这么多优点，其实纯函数的优秀的原因是因为它不使用全局引用： 大神语录 Shared mutable state is the root of all evil(共享的可变状态是万恶之源) – Pete Hunt ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:5","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"应用和组合函数 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:0","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"高阶函数 在数学和计算机科学中，高阶函数 是至少执行以下一项的函数： 将一个或多个函数作为参数(即过程参数) 返回一个函数作为其结果 ES6 中常用的高阶函数包括：map，filter，reduce，find，some，every 等。 // 数组求和 const arr = [5, 7, 1, 8, 4]; // 不使用高阶函数 let sum = 0; for (let i = 0; i \u003c arr.length; i++) { sum = sum + arr[i]; } console.log(sum); //25 // 使用高阶函数 const sum = arr.reduce((accumulator, currentValue) =\u003e accumulator + currentValue,0); console.log(sum); //25 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:1","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"闭包 通常情况下我们说的 闭包 指的是函数内部的函数。闭包的形成条件： 存在内、外两层函数 内层函数对外层函数的局部变量进行了引用 闭包的用途：定义一些作用域局限的持久化变量，这些变量可用来做缓存或者计算的中间量等。 闭包的弊端：持久化变量不会被正常释放，持续占用内存造成内存浪费，所以需要额外的手动清理机制。 // 匿名函数创造了一个闭包，实现简单的缓存工具 const cache = (function() { const store = {}; return { get(key) { return store[key]; }, set(key, val) { store[key] = val; } } }()); console.log(cache) //{get: ƒ, set: ƒ} cache.set('a', 1); cache.get('a'); // 1 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:2","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"柯里化 柯里化 是一种将多参函数拆解为多个单参函数序列的技术。 function curryIt(fn) { // 参数fn函数的参数个数 let n = fn.length; let args = []; return function(arg) { args.push(arg); if (args.length \u003c n) { return arguments.callee; // 返回这个函数的引用 } else { return fn.apply(this, args); } }; } function add(a, b, c) { return [a, b, c]; } // c 是内部匿名函数 const c = curryIt(add); // 可以分步传参 const c1 = c(1); // 将 1 加入 args 中，返回 c 的引用 const c2 = c1(2); const c3 = c2(3); // [1, 2, 3] // 也可以直接调用 const c3 = c(1)(2)(3); // [1, 2, 3] 可以看出，柯里化是一种函数的“预加载”技术，可以通过闭包实现对参数的缓存。 类似的概念有将多参函数拆解为任意参数个数的部分函数应用： // Currying f(a)(b)(c) const f = a =\u003e b =\u003e c =\u003e a + b + c; // Partial application f(a)(b,c) const f = a =\u003e (b, c) =\u003e a + b + c; ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:3","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"函数组合 柯里化是函数的拆解，函数组合就是多个函数组合为一个函数。compose 简单实现： const compose = (f, g) =\u003e x =\u003e f(g(x)); const g = x =\u003e x + 1; const f = x =\u003e x * 5; const fg = compose(f, g); fg(2); // 15 我们要合成的函数可能不止两个，更通用的 compose 实现： function compose(...args) { return function(x) { let composeFun = args.reduceRight(function(first, second) { //从右边开始迭代，这里实际是把右边放入左边 return second(first); }, x); return composeFun; } }; // 简化为箭头函数 const compose = (...args)=\u003e(x)=\u003e args.reduceRight((f,s)=\u003es(f),x); 现在我们可以自由组合函数： function addHello(str){ return 'hello ' + str; } function toUpperCase(str) { return str.toUpperCase(); } function reverse(str){ return str.split('').reverse().join(''); } const composeFn=compose(reverse,toUpperCase,addHello); composeFn('ttsy'); // YSTT OLLEH 最后，软件工程没有银弹。每种编程范式各有利弊，我们要根据实际需求选择合适的编程范式。 参考资料 维基百科 JavaScript函数式编程入门经典 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:4","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"如果你想了解 Javascript 的编译原理，那么你就得了解 AST(Abstract Syntax Tree)，目前前端常用的一些插件或者工具，比如 JS 转译、代码压缩、CSS 预处理器、ESLint、Prettier 等功能的实现，都是建立在 AST 的基础之上的。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:0:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"JS 编译流程 首先是 JS 引擎读取 JS 文件中的字符流，然后通过 词法分析 生成 tokens，之后再通过 语法分析 生成 AST，最终 JS 引擎将 AST 编译成字节码或机器码，然后再运行。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"词法分析 词法分析，也称为扫描(scanner)，简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的 Token。Token 是 JS 代码在语法含义上不可分割的最小单元。除此之外，还会过滤掉源程序中的注释和空白字符(换行符、空格、制表符等)。 最终，整个代码被分割进一个 tokens 的数组中。如下代码： const href = 'https://github.com/' 经过词法分析生成类似这样的 tokens： [ { \"type\": \"Keyword\", \"value\": \"const\" }, { \"type\": \"Identifier\", \"value\": \"href\" }, { \"type\": \"Punctuator\", \"value\": \"=\" }, { \"type\": \"String\", \"value\": \"'https://github.com/'\" } ] ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:1","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"语法分析 语法分析会将词法分析出来的 tokens 转化成有语法含义的 AST 结构。同时，验证语法，如果语法有错，抛出语法错误。 { \"type\": \"Program\", \"body\": [ { \"type\": \"VariableDeclaration\", \"declarations\": [ { \"type\": \"VariableDeclarator\", \"id\": { \"type\": \"Identifier\", \"name\": \"href\" }, \"init\": { \"type\": \"Literal\", \"value\": \"https://github.com/\", \"raw\": \"'https://github.com/'\" } } ], \"kind\": \"const\" } ], \"sourceType\": \"script\" } 这里 可以看到代码的转换。这里 有 tokens 和 AST 的简单 JS 实现。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:2","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"AST 节点规范 业界已经有很多成熟的解析库，常用的库都集成在 AST Explorer 中，可以实现代码与符合 The ESTree Spec 的 AST 之间的相互转换。下面对规范里的 ES5 的 API 做简要说明。 ESTree AST 中每个节点都要实现以下的 Node 接口，loc 字段表示相关代码的位置信息： interface Node { type: string; loc?: SourceLocation; } interface SourceLocation { source: string | null; start: Position; end: Position; } interface Position { line: number; // \u003e= 1 column: number; // \u003e= 0 } ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Programs 根节点 interface Program \u003c: Node { type: \"Program\"; body: [ Statement ]; } AST 的顶部， body 包含了多个 Statement(语句)节点。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:1","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Patterns 模式 interface Pattern \u003c: Node { } 在 ES6 的解构赋值中有意义，如 let {name} = user，其中{name}部分为 ObjectPattern, 对于 ES5，唯一的子类是 Identifier ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:2","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Expression 表达式 interface Expression \u003c: Node { } 表达式，子类很多，有二元表达式(n*n)、函数表达式(var fun = function(){})、数组表达式(var arr = [])、对象表达式(var obj = {})、赋值表达式( a=1)等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:3","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Identifier 标识符 interface Identifier \u003c: Expression, Pattern { type: \"Identifier\"; name: string; } 写代码时自定义的名称，如变量名，函数名，属性名等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:4","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Literal 字面量 interface Literal \u003c: Expression { type: \"Literal\"; value: string | boolean | null | number | RegExp; } 从 value 的类型可以看出，字面量就是值，他的类型有字符串，布尔，数值，null 和正则。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:5","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Statement 语句 interface Statement \u003c: Node { } 语句，子类有很多， 块语句、 if/switch语句、 return语句、 for/while语句、 with语句等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:6","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Declaration 声明 interface Declaration \u003c: Statement { } 声明，子类主要有变量申明、函数声明。 ES6，7，8，… 的更多类型补充可以看这一篇 文章。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:7","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"AST 的运用 将原代码转化为 AST，修改 AST，再重新转化为新代码就能完成代码转译。Babel 将最新语法的 JS 代码转化为 ES5 的原理就是这样的。 \rBabel 操作 AST 会用到以下工具包： @babel/parser 用于将代码转换为 AST @babel/traverse 用于对 AST 的遍历，包括节点增删改查、作用域等处理 @babel/generator 用于将 AST 转换成代码 @babel/types 用于 AST 节点操作的 Lodash 式工具库,各节点构造、验证等 更多api详见 Babel手册。 下面是用一个例子讲述具体操作步骤： var obj = { fn(){ console.log(\"hello\") } } 我们需要把以上代码转换成下面这样： const obj = { fn(){ console.log(\"hello\",\"world\") } } 将两份代码在 AST Explorer 中打开。选择 @babel/parser 为解析器，右边有选项隐藏不需要的属性。对比两颗 AST 发现差异是 kind 和 arguments，因此代码如下： const parser = require(\"@babel/parser\"); const traverse = require(\"@babel/traverse\").default; const generate = require(\"@babel/generator\").default; const t = require(\"@babel/types\"); let sourceCode = ` var obj = { fn(){ console.log(\"hello\") } } ` let ast = parser.parse(sourceCode); traverse(ast, { VariableDeclaration(path) { let { kind } = path.node if (kind === \"var\") { kind = \"const\" } }, CallExpression(path) { let { callee, arguments } = path.node if (t.isMemberExpression(callee) \u0026\u0026 callee.object.name === \"console\" \u0026\u0026 callee.property.name === \"log\") { arguments.push(t.stringLiteral(\"world\")) } } }) console.log(generate(ast).code); 这里 还有更多例子。 参考资料 JS之 执行过程 JS 语法树学习 Javascript抽象语法树 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:3:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Interview"],"content":"Webpack 是一个前端构建工具，前端构建工具的作用就是把开发环境的代码转化成运行环境代码。一般来说，开发环境的代码是为了更好的阅读，而运行环境的代码则是为了能够更快地执行。因此开发环境和运行环境的代码形式也不相同。比如，开发环境的代码，要通过混淆压缩后才能放在线上运行，这样代码体积更小，但对代码执行不会有任何影响。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:0:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Interview"],"content":"应用场景 一般的构建工具可以处理但不限于以下场景： 代码压缩 将 JS、CSS 代码混淆压缩，让代码体积更小，加载更快。 语法编译 编写CSS时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等，这些标准目前都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。 模块化处理 CSS 和 JS 的模块化语法，目前无法被浏览器兼容。因此开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如使用 Webpack、Rollup 等处理 JS 模块化。 使用 webpack，构建的前端项目是高度可配置的(替换 react，vue 默认 cli 工具)。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:1:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Interview"],"content":"核心概念 以下概念提取自 webpack 的官方文档，学习更多细节请参阅官方文档。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Interview"],"content":"Entry 入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。 进入入口起点后, webpack 会找出有哪些模块和库是入口起点(直接和间接)依赖的。 每个依赖项随即被处理,最后输出到称之为 bundles 的内存文件中。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:1","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Interview"],"content":"Output output 属性指定 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。 基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:2","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Interview"],"content":"Module 模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:3","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Interview"],"content":"Chunk 代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:4","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Interview"],"content":"Loader loader 让 webpack 能够去处理那些非 JS 文件(webpack 自身只理解 JS)。 loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。 本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图(和最终的 bundle)可以直接引用的模块。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:5","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Interview"],"content":"Plugin loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。 插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:6","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Interview"],"content":"构建流程 Webpack 在启动后，会从 Entry 开始，递归解析 Entry 依赖的所有 Module，每找到一个 Module，就会根据 Module.rules 里配置的 Loader 规则进行相应的转换处理，对 Module 进行转换后，再解析出当前 Module 依赖的Module，这些 Module 会以 Entry 为单位进行分组，即为一个 Chunk。因此一个 Chunk 就是一个 Entry 及其所有依赖的 Module 合并的结果。最后 Webpack 会将所有的 Chunk 转换成文件输出 Output。在整个构建流程中，Webpack 会在恰当的时机执行 Plugin 里定义的逻辑，从而完成 Plugin 插件的优化任务。 简单的解释就是这样，详细构建流程请看这篇文章。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:3:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Interview"],"content":"配置入门 下面以一个配置一个 react 开发环境为例，学习 webpack 的基本配置方法。 新建文件夹 webpack-demo，终端进入文件夹执行 npm init 初始化项目。 安装 react: yarn add react react-dom 安装 webpack: yarn add webpack webpack-cli webpack-dev-server -D webpack-cli 提供了一组用于运行和设置 webpack 的命令 Webpack-dev-server 提供 http 服务，实时重载(hot模式)，cors 配置，端口配置等 安装 babel: yarn add @babel/core @babel/preset-react @babel/preset-env babel-loader -D @babel/core 是核心依赖项 @babel/preset-react 添加对 JSX 支持 @babel/preset-env 添加对 ES6 的支持 babel-loader 使用 Babel 和 webpack 转换 react 代码为 JS 安装 CSS Loaders: yarn add css-loader style-loader -D css-loader 从收集 CSS 并将 CSS 转化为字符串 style-loader 将从 css-loader 中获得的字符串嵌入在 html 中的 style 标签中 安装插件: yarn add html-webpack-plugin -D html-webpack-plugin 用于将生成的 output 文件嵌入到指定 html 文件 准备文件: 在根文件夹下创建 src 和 dist 文件夹，在 src 文件夹下创建 main.js，app.js，index.css， 在 dist 文件夹下创建 index.html。 创建 webpack.config.js，这是默认的 webpack 配置文件： //webpack.config.js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { entry: './src/main.js', output: { path: path.join(__dirname, '/dist'), filename: 'bundle.js' }, devServer: { port: 8080 }, module: { rules: [ { test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel-loader', }, { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] }, plugins: [ new HtmlWebpackPlugin({ template: './dist/index.html' }) ] } “entry”: 这是入口 js，webpack将从此处开始打包。 “output”: 打包的文件将位于 “/dist/bundle.js”。 “devServer”: 它定义了 weback-dev-server 的配置，开发服务器的默认端口是8080。 模块规则-这些是转译规则： “test”: 正则表达式，指定哪种文件需要通过 loader 转译。 “exclude”: 指定 loader 应忽略的文件。 “use”: 应用 loader 的数组，注意是从右往左加载 loader。 babel 转译的配置文件 .babelrc： { \"presets\":[\"@babel/preset-env\", \"@babel/preset-react\"] } 在 package.json 中添加脚本： \"start\": \"webpack-dev-server --mode development --open --hot\", \"build\": \"webpack --mode production\" 将创建的空文件补充完整： \u003c!-- dist/index.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eReact Web\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c!-- html-webpack-plugin 插件生成如下标签 \u003cscript src='bundle.js'\u003e\u003c/script\u003e --\u003e \u003c/body\u003e \u003c/html\u003e // src/main.js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App.js'; ReactDOM.render(\u003cApp /\u003e, document.getElementById('root')); // src/app.js import React, { Component } from 'react'; import './index.css'; class App extends Component { render() { return ( \u003cdiv\u003e \u003ch1\u003eHello!!\u003c/h1\u003e \u003ch2\u003eWelcome to your React App..!\u003c/h2\u003e \u003c/div\u003e ); } } export default App; /* src/index.css */ * { margin: 0; padding: 0; } 运行代码: yarn start，打包文件: yarn run build，动手试试吧！ 参考资料 webpack 官方文档 webpack打包原理? 看完这篇你就懂了! 实现一个简单的Webpack ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:4:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"WebSocket 是一种服务端和客户端之间的双向通信协议，和 HTTP 一样是基于 TCP 协议的应用层协议，并且 WebSocket 在握手阶段依赖于 HTTP 连接。 WebSocket 广泛应用于多用户实时交流，服务端数据持续变化的场景。比如社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等需要高实时的场景。 学习 WebSocket，请看这篇教程。在 node.js 中，通常使用 socket.io 这个库。socket.io 封装了 WebSocket 服务端 JS 库，同时也提供客户端的 JS 库。Socket.IO 支持以事件为基础的实时双向通讯。它可以兼容各种浏览器或移动设备，从而让开发者可以聚焦到功能的实现而不是平台的兼容性。 ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:0:0","tags":["Network"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"Socket.IO 常用 api 常用服务端 api： socket.on('eventName', msg =\u003e {}) /*服务器端监听客户端emit的事件，事件名称可以和客户端是重复的，但是并没有任何关联。 socket.io内置了一些事件比如connection，disconnect，exit事件*/ socket.emit('eventName', msg) //服务端各自的socket向各自的客户端发送数据 socket.broadcast('eventName', msg) //服务端向其他客户端发送消息，不包括自己的客户端 socket.join(channel) //创建一个频道（非常有用，尤其做分频道的时候，比如斗地主这种实时棋牌游戏） io.sockets.in(channel) //加入一个频道 io.to(channel).emit('eventName', msg) //向一个频道发送消息，包括自己的客户端 socket.broadcast.to(channel).emit('eventName', msg) //向一个频道发送消息，不包括自己的客户端 io.emit('eventName', msg) //向所有客户端发送数据 io.sockets.adapter.rooms //获取所有的频道 常用客户端 api： //客户端 io.connect(url) //客户端连接上服务器端，可简写为 io(url)，无跨域时为 io() socket.on('eventName', msg =\u003e {}) //客户端监听服务器端事件 socket.emit('eventName', msg) //客户端向服务器端发送数据 socket.disconnect() //客户端断开链接 更多的 api 请参阅 Socket.IO 的官方文档。这里有一篇搭建实时聊天室的文章，注意文中的 index.html 和 client.js 中的线上服务器地址 realtime.plhwin.com:3000 已经没有了，改为本地地址 localhost:3000 就能运行代码了。index.html 里的 \u003cscript src=\"/socket.io/socket.io.js\"\u003e\u003c/script\u003e 指向的文件是其实是 \u003cscript src=\"../server/node_modules/socket.io-client/dist/socket.io.js\"\u003e\u003c/script\u003e 整体的开发思路就是服务端和客户端其中一端触发事件，另一端就监听事件。文中的示例程序只用到了事件触发 socket.emit 和事件监听 socket.on。下文的示例程序展示了 Socket.IO 中更多 api 的用法。用户进入聊天室时需要选择房间，进入相同房间的用户才能内部交流，不同房间之间的内部信息不能互通。 \r","date":"2020-08-11","objectID":"/2020-08-11-websocket/:1:0","tags":["Network"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"服务端实现 WebSocket 依赖于 http，这里需要安装 socket.io 和 express // server.js const path = require('path'); const http = require('http'); const express = require('express'); const socketio = require('socket.io'); const formatMessage = require('./utils/messages'); const { userJoin, getCurrentUser, userLeave, getRoomUsers } = require('./utils/users'); const app = express(); const server = http.createServer(app); const io = socketio(server); // Set static folder app.use(express.static(path.join(__dirname, 'public'))); const botName = 'ChatCord Bot'; // Run when client connects io.on('connection', socket =\u003e { socket.on('joinRoom', ({ username, room }) =\u003e { const user = userJoin(socket.id, username, room); socket.join(user.room); // Welcome current user socket.emit('message', formatMessage(botName, 'Welcome to ChatCord!')); // Broadcast when a user connects socket.broadcast .to(user.room) .emit( 'message', formatMessage(botName, `${user.username}has joined the chat`) ); // Send users and room info io.to(user.room).emit('roomUsers', { room: user.room, users: getRoomUsers(user.room) }); }); // Listen for chatMessage socket.on('chatMessage', msg =\u003e { const user = getCurrentUser(socket.id); io.to(user.room).emit('message', formatMessage(user.username, msg)); }); // Runs when client disconnects socket.on('disconnect', () =\u003e { const user = userLeave(socket.id); if (user) { io.to(user.room).emit( 'message', formatMessage(botName, `${user.username}has left the chat`) ); // Send users and room info io.to(user.room).emit('roomUsers', { room: user.room, users: getRoomUsers(user.room) }); } }); }); const PORT = process.env.PORT || 3000; server.listen(PORT, () =\u003e console.log(`Server running on port ${PORT}`)); ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:2:0","tags":["Network"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"客户端实现 需要先在 html 中引入 socket.io-client，才能使用 io \u003c!-- public/chat.html --\u003e \u003cscript src=\"/socket.io/socket.io.js\"\u003e\u003c/script\u003e \u003cscript src=\"js/main.js\"\u003e\u003c/script\u003e 这里的静态资源文件是由 express 加载的，没有跨域，可省略 io 括号里的地址 // public/js/main.js const chatForm = document.getElementById('chat-form'); const chatMessages = document.querySelector('.chat-messages'); const roomName = document.getElementById('room-name'); const userList = document.getElementById('users'); // Get username and room from URL const { username, room } = Qs.parse(location.search, { ignoreQueryPrefix: true }); const socket = io(); // Join chatroom socket.emit('joinRoom', { username, room }); // Get room and users socket.on('roomUsers', ({ room, users }) =\u003e { outputRoomName(room); outputUsers(users); }); // Message from server socket.on('message', message =\u003e { console.log(message); outputMessage(message); // Scroll down chatMessages.scrollTop = chatMessages.scrollHeight; }); // Message submit chatForm.addEventListener('submit', e =\u003e { e.preventDefault(); // Get message text const msg = e.target.elements.msg.value; // Emit message to server socket.emit('chatMessage', msg); // Clear input e.target.elements.msg.value = ''; e.target.elements.msg.focus(); }); // Output message to DOM function outputMessage(message) { const div = document.createElement('div'); div.classList.add('message'); div.innerHTML = `\u003cp class=\"meta\"\u003e${message.username}\u003cspan\u003e${message.time}\u003c/span\u003e\u003c/p\u003e \u003cp class=\"text\"\u003e ${message.text}\u003c/p\u003e`; document.querySelector('.chat-messages').appendChild(div); } // Add room name to DOM function outputRoomName(room) { roomName.innerText = room; } // Add users to DOM function outputUsers(users) { userList.innerHTML = ` ${users.map(user =\u003e `\u003cli\u003e${user.username}\u003c/li\u003e`).join('')}`; } 更多内容请看源码。 附：源码地址 参考资料 WebSocket 教程 Socket.IO 官方文档 ChatCord 源码 ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:3:0","tags":["Network"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"最近，Facebook 官方开源了一个状态管理库 Recoil，我们来学习一下。Recoil 是基于 Immutable 的数据流管理方案，这是它值得学习的重要原因。Recoil非常易于学习，它的 API 简单强大，对于已经习惯使用 hooks 的人来说很自然。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:0:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"核心概念 Recoil 中的核心概念只有 Atom(原子状态) 和 Selector(派生状态)。 \r","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"Atom Atom 是状态的单位。它们可更新也可订阅。当 atom 被更新，每个被订阅的组件都将使用新值进行重渲染。如果多个组件使用相同的 atom，则这些组件共享 atom 的状态。可以使用 atom 替代组件内部的 state。atom 也可以在运行时创建。 Atom 是使用 atom 函数创建的： function atom\u003cT\u003e({ key: string, default: T | Promise\u003cT\u003e | RecoilValue\u003cT\u003e, dangerouslyAllowMutability?: boolean, }): RecoilState\u003cT\u003e key：标识 atom 的字符串，必须相对于其他 atom/selector 是唯一值 default：atom 的初始值，可以是静态值，Promise，或返回值类型相同的另一个 atom/seletor 最后一个参数是允许 Mutable，由于 Recoil 默认的 Immutable 特性带来的可预测性更利于调试和维护，一般不设置这个值 定义一个 atom，用来获取输入字符: const textState = atom({ key: 'textState', // unique ID (with respect to other atoms/selectors) default: '', // default value (aka initial value) }); ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:1","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"Selector selector 是一个纯函数，入参为 atom 或其他 selector。selector 被用于计算基于 atom 的派生数据，这使得我们避免了冗余 state，将最小粒度的状态存储在 atom 中，而其它所有内容根据最小粒度的状态进行有效计算。当上游 atom/selector 更新时，将重新执行 selector 函数。组件可以像 atom 一样订阅 selector，当 selector 发生变化时，重新渲染相关组件。 Selector 是使用 selector 函数创建的： function selector\u003cT\u003e({ key: string, get: ({ get: GetRecoilValue }) =\u003e T | Promise\u003cT\u003e | RecoilValue\u003cT\u003e, set?: ( { get: GetRecoilValue, set: SetRecoilState, reset: ResetRecoilState, }, newValue: T | DefaultValue, ) =\u003e void, dangerouslyAllowMutability?: boolean, }): RecoilValueReadOnly\u003cT\u003e | RecoilState\u003cT\u003e type ValueOrUpdater\u003cT\u003e = T | DefaultValue | ((prevValue: T) =\u003e T | DefaultValue); type GetRecoilValue = \u003cT\u003e(RecoilValue\u003cT\u003e) =\u003e T; type SetRecoilState = \u003cT\u003e(RecoilState\u003cT\u003e, ValueOrUpdater\u003cT\u003e) =\u003e void; type ResetRecoilState = \u003cT\u003e(RecoilState\u003cT\u003e) =\u003e void; key：标识 selector 的字符串，必须相对于其他 atom/selector 是唯一值 get：get 参数中 get，可以从其他 atom/selector 取值，从而利用依赖关系计算 seletor，传递给此函数的 atom/selector 隐式添加到这个 seletor 的依赖项列表中 set?：设置了该属性，selector 才会返回可写的 state 定义一个 selector，依赖的 atom 是我们上面定义的 textState，用来获取输入字符长度 : const charCountState = selector({ key: 'charCountState', // unique ID (with respect to other atoms/selectors) get: ({get}) =\u003e { const text = get(textState); return text.length; }, }); 测试 atom 和 selector 示例 demo 从组件的角度来看，selector 和 atom 具有相同的功能，因此可以交替使用。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:2","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"订阅或更新状态 前面讲述如何用 atom 和 selector 定义 state，下面是 state 的取值和更新函数： useRecoilState：返回 atom/selector 的值和 set 函数，类似 useState。 useRecoilValue：仅返回 atom/selector 的值。 useSetRecoilState：仅返回 atom/seletor 的 set 函数。 useResetRecoilState：重置 atom/selector 到默认值并读取。 在组件中使用这些 hooks 与使用其他 hooks 的方式基本相同： import React from 'react'; import { atom, useRecoilState, selector, useRecoilValue } from 'recoil'; const textState = atom({ key: 'textState', // unique ID (with respect to other atoms/selectors) default: '', // default value (aka initial value) }); const charCountState = selector({ key: 'charCountState', // unique ID (with respect to other atoms/selectors) get: ({ get }) =\u003e { const text = get(textState); return text.length; }, }); export const CharacterCounter = () =\u003e { const [char, setChar] = useRecoilState(textState); // selector 没有定义 set，用 useRecoilValue 取值 const charCount = useRecoilValue(charCountState); return ( \u003cdiv\u003e \u003cinput type=\"text\" value={char} onChange={(e) =\u003e setChar(e.target.value)} /\u003e \u003cdiv\u003eEcho: {char}\u003c/div\u003e \u003cdiv\u003eCharacter Count: {charCount} \u003c/div\u003e \u003c/div\u003e ); }; export default CharacterCounter; atom，selector 的 state 的取值和更新函数是相同的，selector 未定义 set 只能用 useRecoilValue 取值，定义 set 之后也能用 useRecoilState，因此 atom 应该是基于 selector 的一个特定封装，帮我们封装好了 set，get，而无须自定义。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:2:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"异步支持 在 selector 的数据流图中, Recoil 可以让你随意的混合使用同步和异步函数。只需从 selector get 回调中返回一个 Promise，接口完全一样。因为这些只是 selector，其他的 selector 也可以依赖它们来进一步变更数据。selector 是纯函数，是对只读数据库查询进行建模的好方法，其中重复查询可提供一致的数据。 import React from 'react'; import {selector, useRecoilValue} from 'recoil'; const myQuery = selector({ key: 'MyDBQuery', get: async () =\u003e { const response = await fetch(getMyRequestUrl()); return response.json(); }, }); function QueryResults() { const queryResults = useRecoilValue(myQuery); return ( \u003cdiv\u003e {queryResults.foo} \u003c/div\u003e ); } function ResultsSection() { return ( \u003cReact.Suspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e \u003cQueryResults /\u003e \u003c/React.Suspense\u003e ); } atom 是基于 selector 封装，也支持 Promise 做默认 state。不过官方的建议是当其从其他状态或异步请求时派生的 state，应该使用 selector。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:3:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"参数查询 有时我们希望通过传递参数动态定义 state，你可以使用 atomFamily 或 selectorFamily 实现这类需求， atom 与 atomFamily，selector 与 selectorFamily 的区别仅仅是定义 state 的时候是否需要参数： const myDataQuery = selectorFamily({ key: 'MyDataQuery', get: (queryParameters) =\u003e async ({get}) =\u003e { const response = await asyncDataRequest(queryParameters); if (response.error) { throw response.error; } return response.data; }, }); function MyComponent() { const data = useRecoilValue(myDataQuery({userID: 132})); return \u003cdiv\u003e...\u003c/div\u003e; } 目前 Recoil 还属于实验阶段，能确定的是 Recoil 将兼容 React 并发模式。 我们可以在 Recoil 中学到 React Hook 时代的状态管理的基本模式： state 的读与写分离，做到最优按需渲染。 原子存储的数据相互无关联，关联的数据使用派生值的方式推导。 派生的值必须严格缓存，并在命中缓存时引用保证严格相等。 参考资料 Recoil 官方文档 精读《recoil》 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:4:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"权限管理是所有后台系统的都会涉及的一个重要组成部分，主要目的是对不同的人访问资源进行权限的控制，避免因权限控制缺失或操作不当引发的风险问题，如操作错误，隐私数据泄露等问题。 迄今为止最为普及的权限设计模型是RBAC模型,基于角色的访问控制（Role-Based Access Control)，而 RBAC 模型又可以细分为 RBAC0，RBAC1，RBAC2，RBAC3。 本文介绍 RBAC0, 这是权限最基础也是最核心的模型，其他复杂模型也是建立在 RBAC0 之上的。关于 RBAC 还有很多重要理论，具体可参考知乎上的这篇 权限系统设计 和这篇 RBAC理念。本文将带领读者体会 RBAC0 的实践运用，实现 RBAC0 的关键在建立 用户-角色-权限 之间的多对多关系。 \r","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:0:0","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"实例 请注意，本文不涉及具体代码讲解。如需具体代码的讲解，请移步到 后端代码讲解 和 前端代码讲解，在这两篇文章末尾附有源码地址。作者的讲解逻辑严密，注重细节，非常优秀，无需我再赘述。本文只演示实例程序，带领读者理解 RBAC0 权限设计模型。 实例程序将网站用户分为三个角色: Admin(管理员), Moderator(版主), User(普通用户)。 所有页面路由：home, rigister, login, profile, user, mod, admin ","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:0","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"正常访问截图 对所有未登录用户开放的页面(访客页面): home, register, login \r对网站用户开放的页面： 对 User 开放的页面(用户页面)：访客页面, profile, user \r 对 Moderator 开放的页面：用户页面, mod(导航栏中增加 Moderator Board) 对 Admin 开放的页面：用户页面, admin(导航栏中增加 Admin Board) 正常访问其他页面的更多截图看 这里，或者自己运行前后端代码，修改用户角色需用 postman 向后端接口发送 http 请求或者直接修改数据表。 ","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:1","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"越权访问截图 未登录用户访问 user 页面： \rUser 访问 admin 页面： \rUser, Admin 访问 mod 页面, Moderator 访问 admin 页面的显示结果同理。 当一个用户同时具有 User, Moderator, Admin 角色时，就有了所有页面的访问权力。 \r根据用户角色来决定页面的数据，这样就实现了 RBAC0 的基本模型。 参考资料 可能是史上最全的权限系统设计 RBAC理念 实例程序讲解 --","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:2","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"这次使用 antd 和 TypeScript 实践一个简单 todolist, 为什么又是 todolist？这个问题好比问为什么写代码第一句是 hello world 一样。只是简单的练手，写什么不重要。这次的代码中暂时还没有实现数据持久化，状态管理等，只是把页面上能够看到的功能实现了。后续我将尝试其他的数据流管理方案。 页面长这样，响应 pc 端，移动端: \r页面上有一个搜索框，过滤列表项。点击添加按钮，弹出会话框，添加列表数据。下面是三个标签选项，点击不同的标签显示不同的列表内容。列表中每一项中的三个图标分别实现的是编辑数据，修改完成状态和删除这一项的功能。 这个 todolist 实例只实现了 Todo，ModalForm(对话框)，TodoList(标签选项下的列表) 组件。ModalForm，TodoList 是 Todo 的子组件。这三个组件就足够完成上述的功能了。 ","date":"2020-06-30","objectID":"/2020-06-30-antd/:0:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"定义数据模型 export interface ITodo { id: number; text: string; done: boolean; } ","date":"2020-06-30","objectID":"/2020-06-30-antd/:1:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"状态提升 由于没有引入 redux 状态管理库，为了方便组件间的数据传递，一个比较好的做法是将多个组件需要共享的状态提升到它们最近的父组件上(状态提升)。这里的父组件是 Todo 组件。 需要共享的状态有： 1.编辑 TodoList 组件中的 todo 时，需要让对话框显示(showModal) 2.编辑 TodoList 组件中的 todo 时，弹出的对话框需要获得 todo.id(todoId) 3.根据弹出对话框的位置，决定对话框的标题(modalTitle) 先在 Todo 组件中定义需要共享的数据字段： // Todo.ts const [showModal, setShowModal] = useState(false); const [todoId, setTodoId] = useState(1); const [modalTitle, setModalTitle] = useState(''); 弹出的对话框可能是添加或编辑 todo： export enum ModalType { Edit = 'EDIT', Add = 'ADD', } 根据弹出对话框的位置决定对话框标题: // Todo.ts const onShowModal = (type: ModalType, id?: number) =\u003e { if (type === ModalType.Add) { setModalTitle('添加任务'); } if (type === ModalType.Edit) { setModalTitle('编辑任务'); setTodoId(id!); //记录 TodoList 组件传递的 todoId } setShowModal(true); }; 如果是在 Todo 组件的添加按钮: //Todo.ts \u003cButton type=\"primary\" className={styles.newTodo} onClick={() =\u003e onShowModal(ModalType.Add)}\u003e 添加 \u003c/Button\u003e 在 Todo 组件点击添加按钮时，显示对话框组件，提交表单时用内部实现的 itemId 作为 todo.id： // ModalForm.ts const ModalForm: FC\u003cIModalFormProps\u003e = (props) =\u003e { const { visible, onClose, addTodo, modalTitle } = props; const [itemId, setItemId] = useState(1); const [form] = Form.useForm(); const onFinish = () =\u003e { const text: string = form.getFieldValue('content').trim(); if (modalTitle === '添加任务') { addTodo(itemId, text, false); setItemId(itemId =\u003e itemId + 1); } form.setFieldsValue({ content: '' }); onClose(); }; 在 ts 中需要用 interface 声明父组件传过来的 props 的类型。 // ModalForm.ts interface IModalFormProps { visible: boolean; modalTitle: string; onClose: () =\u003e void; addTodo: (id: number, text: string, flag: boolean) =\u003e void; } 如果是在 TodoList 中的编辑按钮：Todo 组件将 onShowModal 方法传递给 TodoList 子组件，TodoList 就能让对话框组件显示并传递 todoId 给 Todo 组件： // TodoList.ts \u003cEditOutlined className={styles.icon} onClick={() =\u003e onShowModal(ModalType.Edit, todo.id)} /\u003e 在弹出编辑对话框之前，Todo 组件将已经获取到 todoId 传递给对话框组件: // Todo.ts \u003cModalForm modalTitle={modalTitle} todoId={todoId} visible={showModal} onClose={onClose} addTodo={addTodo} updateText={updateText} /\u003e 得到 todoId 就能在对话框提交时更新 todo 了，对话框组件中完善提交表单方法: // ModalForm.ts const { visible, onClose, addTodo, modalTitle, todoId, updateText } = props; const onFinish = () =\u003e { const text: string = form.getFieldValue('content').trim(); if (modalTitle === '添加任务') { addTodo(itemId, text, false); setItemId(itemId =\u003e itemId + 1); } if (modalTitle === '编辑任务') { updateText(todoId, text); } form.setFieldsValue({ content: '' }); onClose(); }; ","date":"2020-06-30","objectID":"/2020-06-30-antd/:2:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"列表的增删改查 先在 Todo 组件中定义列表数据状态： //Todo.ts const [lists, setlists] = useState\u003cITodo[]\u003e([]); 接下来实现列表的增删改查： // Todo.ts const addTodo = (id: number, text: string, done: boolean) =\u003e { const Item = { id, text, done }; setlists([Item, ...lists]); message.success('新增成功'); }; const deleteTodo = (id: number) =\u003e { const newlists = lists.filter(i =\u003e i.id !== id) setlists([...newlists]); message.success('删除成功'); }; const toggleDone = (id: number) =\u003e { const newlists = lists.map(i =\u003e i.id === id ? { ...i, done: !i.done } : i ) setlists([...newlists]); } const updateText = (id: number, text: string) =\u003e { const newlists = lists.map(i =\u003e i.id === id ? { ...i, text } : i ) setlists([...newlists]); message.success('编辑成功'); } 代办项，已完成，清单三个标签过滤列表： // Todo.ts const todoList = lists.filter(item =\u003e !item.done); const doneList = lists.filter(item =\u003e item.done); ","date":"2020-06-30","objectID":"/2020-06-30-antd/:3:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"实现搜索功能 先在 Todo 组件中定义搜索数据状态： //Todo.ts const [searchText, setSearchText] = useState(''); 实现按搜索字段过滤数据的方法： // Todo.ts const getFilter = (lists: ITodo[], searchText: string) =\u003e { if (searchText.trim() !== '') { return lists.filter(todo =\u003e todo.text.toLowerCase().includes(searchText.toLowerCase())); } return lists; }; Todo 组件将列表数据先用 getFilter 方法过滤再传递给 TodoList 子组件： //Todo.ts \u003cTabs defaultActiveKey=\"1\" size={\"large\"}\u003e \u003cTabPane tab={\u003cBadge status=\"warning\" text=\"待办项\" /\u003e} key=\"1\"\u003e \u003cTodoList lists={getFilter(todoList, searchText)} updateText={updateText} toggleDone={toggleDone} deleteTodo={deleteTodo} onShowModal={onShowModal}/\u003e \u003c/TabPane\u003e \u003c/Tabs\u003e 上面是待办项列表的数据传递，如果是已完成或清单组件，只需将 getFilter 的第一个参数替换为 doneList 或 lists，所有功能就完成了。 续：发现了一个状态管理库 Easy Peasy, 个人感觉比 redux 简洁。这里有一个 todolist 例子。 附：源码地址 ","date":"2020-06-30","objectID":"/2020-06-30-antd/:4:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"数据分页获取 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"引入依赖，连接数据库 在 spring-boot 项目的根目录 pom.xml 添加依赖，相关依赖有 lombok, mybatis-plus, druid, swagger, mysql 驱动等。 \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.9\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.8.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.8.0\u003c/version\u003e \u003c/dependency\u003e 然后在 src/main/resources 文件夹下添加 application.properties 或 application.yml 文件配置数据库连接。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:1","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建数据表 本地连接数据库，然后导入脚本，创建数据表。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:2","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建 entity 及 mapper 创建文章实体(entity) @Data @EqualsAndHashCode(callSuper = false) @Accessors(chain = true) @ApiModel(value = \"Article对象\", description = \"\") public class Article implements Serializable { private static final long serialVersionUID = 1L; @TableId(value = \"id\", type = IdType.AUTO) private Integer id; @ApiModelProperty(value = \"标题\") private String title; @ApiModelProperty(value = \"内容\") private String content; @ApiModelProperty(value = \"用户主键\") private Integer uId; @ApiModelProperty(value = \"热度\") private Integer score; @ApiModelProperty(value = \"版块主键/为0时表示未设置\") private Integer bId; @JsonFormat(pattern = \"yyyy-MM-dd\", timezone = \"GMT+8\") private Date createDate; @JsonFormat(pattern = \"yyyy-MM-dd\", timezone = \"GMT+8\") private Date updateDate; @TableField(exist = false) private User user; @TableField(exist = false) private Block block; } lombok 的注解： @Data 相当于 @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode 这5个注解的合集。 存在继承,编译时有警提示，加上@EqualsAndHashCode(callSuper=false), 只比较当前的类字段。 @Accessors(chain = true)链式调用为真, setter方法返回当前对象的序列化对象，便于存储，便于传输。 mybatis-plus 的注解： @TableId 主键的映射,主键的生成策略,自动生成。 @TableField(exist = false) 不映射数据表字段。 swagger 的注解： @Api 开头的是 swagger 的注解。 对应的 Mapper 只需继承 BaseMapper，基本的 crud 方法 mybatis-plus 已经封装好了。 @Mapper @Component public interface ArticleMapper extends BaseMapper\u003cArticle\u003e { } @Component 注解代表需要被 Spring IoC 容器管理，才能实现依赖注入。 然后在启动类中加入 @MapperScan(\"\") 就可以完成 spring-boot 到数据表的映射。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:3","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建 service 创建 service，我们想要分页获取数据，先配置 mybatis-plus 分页插件： @Configuration @MapperScan(\"com.forum.buge_server.mapper*\") public class MybatisPlusConfig { /** * 加载分页插件 * * @return */ @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } } 定义 service 接口 public interface ArticleService extends IService\u003cArticle\u003e { IPage\u003cArticle\u003e getArticlePageing(IPage\u003cArticle\u003e iPage, LambdaQueryWrapper\u003cArticle\u003e wrapper); } service 实现类 在实现类里注入 mapper, 完成分页获取数据。selectPage 方法接收两个参数，第一个是 IPage 对象，第二个参数是条件构造器 QueryWrapper。我们需要在 controller 中传递这两个参数。 @Service public class ArticleServiceImpl extends ServiceImpl\u003cArticleMapper, Article\u003e implements ArticleService { @Autowired ArticleMapper articleMapper; @Override public IPage\u003cArticle\u003e getArticlePageing(IPage\u003cArticle\u003e iPage, LambdaQueryWrapper\u003cArticle\u003e wrapper) { IPage\u003cArticle\u003e articleIPage = articleMapper.selectPage(iPage, wrapper); return articleIPage; } } ","date":"2020-06-18","objectID":"/2020-06-18-forum/:2:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建 controller 我们需要传递 IPage 对象，QueryWrapper 对象给 service，然后从返回的 IPage 对象中取得查询到的数据。 @RestController @RequestMapping(\"/open\") public class OpenController { @Autowired ArticleService articleService; @ApiOperation(\"分页查询文章，时间排序\") @PostMapping(\"/article/new\") public Object getArticleNew(Integer current, Integer size) { // 分页条件 IPage\u003cArticle\u003e page = new Page\u003c\u003e(current, size); // 查询条件 LambdaQueryWrapper\u003cArticle\u003e wrapper = new LambdaQueryWrapper\u003c\u003e(); // 根据时间顺序查询 wrapper.orderByDesc(Article::getCreateDate); IPage\u003cArticle\u003e articlePageing = articleService.getArticlePageing(page, wrapper); // 当前页数 long atCurrent = articlePageing.getCurrent(); // 当前页的数据 List\u003cArticle\u003e records = articlePageing.getRecords(); for (Article article : records) { article.setContent(\"\"); article.setUser(userService.getById(article.getUId())); article.setBlock(blockService.getById(article.getBId())); } // 组装Dto PageResult pageResult = new PageResult(); pageResult.setCurrent(atCurrent); pageResult.setList(records); return new JsonResult(200, \"查询成功\", pageResult); } } 这样就实现了数据时间排序的分页获取。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:3:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"JWT 登录验证 添加依赖 \u003cdependency\u003e \u003cgroupId\u003eio.jsonwebtoken\u003c/groupId\u003e \u003cartifactId\u003ejjwt\u003c/artifactId\u003e \u003cversion\u003e0.7.0\u003c/version\u003e \u003c/dependency\u003e 写一个 jwt 工具类 @Component @Data public class JwtConfig { private String secret = \"abcdefg1234567\"; private long expire = 3600 * 60 * 60; private String header = \"token\"; /** * 生成token * * @param subject * @return */ public String createToken(String subject) { Date nowDate = new Date(); Date expireDate = new Date(nowDate.getTime() + expire * 1000);// 过期时间 return Jwts.builder().setHeaderParam(\"typ\", \"JWT\").setSubject(subject).setIssuedAt(nowDate) .setExpiration(expireDate).signWith(SignatureAlgorithm.HS512, secret).compact(); } /** * 获取token中注册信息 * * @param token * @return */ public Claims getTokenClaim(String token) { try { return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody(); } catch (Exception e) { // e.printStackTrace(); return null; } } /** * 验证token是否过期失效 * * @param expirationTime * @return */ public boolean isTokenExpired(Date expirationTime) { return expirationTime.before(new Date()); } } 里面写了 token 的生成和解密的方法。 添加 jwt 拦截器, 除了注册，登录和 get 请求的 uri 地址，都需要验证 token。 @Component public class TokenInterceptor extends HandlerInterceptorAdapter { JwtConfig jwtConfig = new JwtConfig(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (request.getMethod().equals(\"OPTIONS\")) { return true; } /** 地址过滤 */ String uri = request.getRequestURI(); if (uri.contains(\"/api/login\") || uri.contains(\"/api/reg\") || uri.contains(\"/sys/login\") || uri.contains(\"/api/get\")) { return true; } /** Token 验证是否存在 */ String token = request.getHeader(jwtConfig.getHeader()); if (StringUtils.isEmpty(token)) { token = request.getParameter(jwtConfig.getHeader()); } if (StringUtils.isEmpty(token)) { throw new SignatureException(jwtConfig.getHeader() + \"不能为空\"); } Claims claims = null; // 判断是否有效 try { claims = jwtConfig.getTokenClaim(token); if (claims == null || jwtConfig.isTokenExpired(claims.getExpiration())) { throw new SignatureException(jwtConfig.getHeader() + \"失效，请重新登录。\"); } } catch (Exception e) { throw new SignatureException(jwtConfig.getHeader() + \"失效，请重新登录。\"); } /** 设置 identityId 用户身份ID */ request.setAttribute(\"identityId\", claims.getSubject()); return true; } } ","date":"2020-06-18","objectID":"/2020-06-18-forum/:4:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"点赞关注收藏评论 点赞，关注，收藏，评论功能都可以用单表实现。点赞，收藏，评论功能就是在分别在likes, collection, comment 表中记录 uid(用户),aid(文章) 实现关联，而关注则是在 follow 表中记录两个 uid 实现关联，下面给出点赞功能的逻辑实现，关注，收藏，评论功能的逻辑同点赞功能。 @PostMapping(\"/add/like\") public Object setLike(Integer aid, HttpServletRequest request) { Claims token = jwtConfig.getTokenClaim(request.getHeader(\"token\")); String subject = token.getSubject(); LambdaQueryWrapper\u003cLikes\u003e queryWrapper = new LambdaQueryWrapper\u003c\u003e(); queryWrapper.eq(Likes::getUid, Integer.valueOf(subject)); queryWrapper.eq(Likes::getAId, aid); Likes one = likeService.getOne(queryWrapper); if (one == null) { boolean save = likeService.save(new Likes().setAId(aid).setUid(Integer.valueOf(subject))); return new JsonResult(200, \"点赞成功!\"); } else { boolean b = likeService.removeById(one.getId()); return new JsonResult(200, \"已取消点赞!\"); } } ","date":"2020-06-18","objectID":"/2020-06-18-forum/:5:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"搜索和浏览记录 搜索使用 mysql 的模糊查询实现。 @PostMapping(\"/search/article\") public Object searchArticle(String title) { LambdaQueryWrapper\u003cArticle\u003e articleWrapper = new LambdaQueryWrapper\u003c\u003e(); articleWrapper.like(Article::getTitle, title); List\u003cArticle\u003e list = articleService.list(articleWrapper); for (Article article : list) { article.setContent(\"\"); article.setUser(userService.getById(article.getUId())); article.setBlock(blockService.getById(article.getBId())); } return new JsonResult(200, \"\", list); } 浏览记录，进入文章详情页面后，如果用户是登录状态，就加入 History 表。 History 表有三个字段，uid(用户), aid(文章), time(访问时间)。如果已经在 History 表中存在记录，则更新时间。 @GetMapping(\"/article/{id}\") public Object getArticleById(@PathVariable(\"id\") Integer id, HttpServletRequest request) { Claims token = jwtConfig.getTokenClaim(request.getHeader(\"token\")); // 在登陆状态下保存到历史表中 if (token != null) { String subject = token.getSubject(); LambdaQueryWrapper\u003cHistory\u003e queryWrapper = new LambdaQueryWrapper\u003c\u003e(); queryWrapper.eq(History::getAid, id); queryWrapper.eq(History::getUid, Integer.valueOf(subject)); History one = historyService.getOne(queryWrapper); // 如果已存在记录，则更新时间 History history = new History().setAid(id).setTime(new Date()).setUid(Integer.valueOf(subject)); if (one == null) { historyService.save(history); } else { one.setTime(new Date()); historyService.updateById(one); } } Article byId = articleService.getById(id); byId.setUser(userService.getById(byId.getUId())); byId.setBlock(blockService.getById(byId.getBId())); // 每次访问热度加1 articleService.updateById(new Article().setId(id).setScore(byId.getScore() + 1)); return new JsonResult(200, \"查询成功\", byId); } 每次访问文章详情页，文章热度发生变化，首页热度排序的内容将重新排序。 项目启动主类 @SpringBootApplication public class BugeServerApplication { public static void main(String[] args) { SpringApplication.run(BugeServerApplication.class, args); } } spring boot提供了一个统一的注解@SpringBootApplication。 代表了@Configuration, @EnableAutoConfiguration, @ComponentScan。 @Configuration 和 @Bean。使用这两个注解就可以创建一个简单的spring配置类，可以用来替代相应的xml配置文件。@Configuration的注解类标识这个类可以使用Spring IoC容器作为bean定义的来源。@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。 @EnableAutoConfiguration：能够自动配置spring的上下文，试图猜测和配置你想要的bean类，通常会自动根据你的类路径和你的bean定义自动配置。 @ComponentScan：会自动扫描指定包下的全部标有@Component的类，并注册成bean，当然包括@Component下的子注解@Service, @Repository, @Controller。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:6:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"本文记录 react-beautiful-dnd 这个拖拽库的使用，我们将完成一个类似 trello 的看板应用。最终实现的效果如下：List 是一个可横向拖放的列表，Card 可在不同的 List 列表之间拖放。左上方的搜索框能够搜索筛选卡片，右上方的按钮能够实现撤销重做功能。 \r","date":"2020-05-18","objectID":"/2020-05-18-trello/:0:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"拖拽库的使用 react-beautiful-dnd 这个库使用 render-props 完成组件逻辑复用。react-beautiful-dnd 有 3 个主要组件：DragDropContext，Droppable和Draggable。这三者的关系如下： \rDragDropContext 表示一个全局拖拽上下文。Droppable 表示可以被拖入的容器，Draggable 是可被拖放的组件。 DragDropContext 提供了以下三个钩子： onDragStart 拖动开始时执行。 onDragUpdate 拖动过程中的执行。 onDragEnd 拖拽结束时执行，且 onDragEnd 必须设定。 我们需要在 Board 组件内建立可拖动范围，则需要这样写： // components/Board.js const Board = () =\u003e { // onDragEnd 需实现 const onDragEnd = result =\u003e {}; return ( \u003cDragDropContext onDragEnd={onDragEnd}\u003e ... \u003c/DragDropContext\u003e ); } Droppable： Droppable 必须设定 droppableId Droppable 使用 render-props 意味着内部须使用一个函数，该函数接收参数 provided 对象, 然后将参数 provided 的属性传递给封装后的可拖放的容器组件 将 Board 组件建立成可拖放的容器组件，像这样写： // components/Board.js // 需嵌套在 DragDropContext 内 // 包裹 List 的容器，List 在 Board 容器内横向拖动 \u003cDroppable droppableId='all-lists' direction='horizontal' type='list'\u003e { provided =\u003e ( // 封装后的可拖放的容器组件 \u003cListContainer ref={provided.innerRef} {...provided.droppableProps}\u003e // 遍历所有的列表，将列表数据传递给每个列表 {Object.keys(lists).map((key, index) =\u003e { const list = lists[key]; const listCards = list.cards.length \u003e 0 ? list.cards : []; return ( \u003cList key={list.id} id={list.id} title={list.title} cards={listCards} index={index} /\u003e ); })} {provided.placeholder} \u003c/ListContainer\u003e )} \u003c/Droppable\u003e Draggable： Draggable 必须设定 draggableId，index(由父组件传入) Draggable 与 Droppable 一样是 render-props，接收 provided 对象，返回值是封装后的可拖放组件 将 List 组件建立成可拖放组件，像这样写： // components/List.js // 设置每个 List 都是可拖动的 const List = ({ id, title, cards = [], index }) =\u003e { ... return ( \u003cDraggable draggableId={id} index={index}\u003e { provided =\u003e ( // 封装后的可拖放组件 \u003cListContainer ref={provided.innerRef} {...provided.draggableProps} // dragHandleProps 绑定的组件 ListContainer 可拖动 {...provided.dragHandleProps}\u003e ... \u003c/ListContainer\u003e )} \u003c/Draggable\u003e ); } 同理设置 Card 组件可在 List 组件内部拖动，先要将 List 内部封装成可拖放的容器，像这样写: // components/List.js // 需嵌套在 List 组件返回的 ListContainer 内 // 包裹 Card 的容器，Card 在 List 容器内可拖放 \u003cDroppable droppableId={id} type=\"card\"\u003e {provided =\u003e ( \u003cCardContainer ref={provided.innerRef} {...provided.droppableProps}\u003e // 遍历每个 List 中所有的卡片，将卡片数据传给每张卡片 {cards.map((card, index) =\u003e ( \u003cCard key={card.id} id={card.id} text={card.text} listId={id} index={index} /\u003e ))} {provided.placeholder} \u003c/CardContainer\u003e )} \u003c/Droppable\u003e 将 Card 组件封装成可拖放组件，像这样写: // components/Card.js const Card = ({ id, text, index, listId }) =\u003e { ... return ( \u003cDraggable draggableId={id} index={index}\u003e {provided =\u003e ( \u003cCardContainer className='card' ref={provided.innerRef} {...provided.draggableProps} // dragHandleProps 绑定的组件 CardContainer 可拖动 {...provided.dragHandleProps}\u003e \u003c/CardContainer\u003e )} \u003c/Draggable\u003e ); } ","date":"2020-05-18","objectID":"/2020-05-18-trello/:1:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"状态管理 初始化列表数据: // morkData.js import { uuid } from 'uuidv4'; const getCard = text =\u003e ({ id: uuid(), text }); export const ListState = [ { id: uuid(), title: 'To Do', cards: [ getCard('To do task'), getCard('TO FILTER: To do task'), ] }, { id: uuid(), title: 'Doing', cards: [ getCard('Doing task'), getCard('TO FILTER: Doing task'), ] }, { id: uuid(), title: 'Done', cards: [ getCard('Done task'), getCard('TO FILTER: Done task'), ] }, ]; 记录状态变更用 DragDropContext 上的钩子函数 onDragEnd，onDragEnd 接收一个 result 对象，result 记录了拖拽过程中的状态变化，result 结构如下： const result = { draggableId: 1, // 移动的组件 id type: 'list', source: { droppableId: 1, // 移动前所在的容器 id index: 2, // 组件在移动前的容器内的位置 }, destination: { droppableId: 3, // 移动后所在的容器 id index: 1, // 组件在移动后的容器内的位置 } } 我们需要写拖放组件后的状态变化逻辑，因为我们的列表数据中的 cards 数组发生了变化，但我们还没有把新的状态渲染到 list 组件中，拖放组件后需要重新排序，现在去实现在 Board 组件中定义的 onDragEnd 钩子函数： // components/Board.js const onDragEnd = ({ draggableId, type, source, destination }) =\u003e { if (destination) { dispatch( sort( source.droppableId, destination.droppableId, source.index, destination.index, draggableId, type ) ); } }; action 用 payload 传递接收到的数据： // actions/listActions.js import { CONSTANTS } from '.'; ... export const sort = ( droppableIdStart, droppableIdEnd, droppableIndexStart, droppableIndexEnd, draggableId, type ) =\u003e { return { type: CONSTANTS.DRAGGED, // 动作是拖放，可能是列表，也可能是卡片 payload: { droppableIdStart, //开始时所在的 container id droppableIdEnd, //结束时所在的 container id droppableIndexStart, //开始所在 container 里的索引 droppableIndexEnd, //结束时所在的 container 里的索引 draggableId, // 移动的组件 id type } }; }; reducer 实现状态变化逻辑并返回新状态，始终用新状态替换原来的状态，不要直接在原来的对象上操作，因为我们将会对每个状态做记录，这有利于我们实现撤销重做功能。 // reducers/listReducer.js case CONSTANTS.DRAGGED: { // 当完成拖放动作时 const { droppableIdStart, droppableIdEnd, droppableIndexStart, droppableIndexEnd, type } = action.payload; const newState = [...state]; //深拷贝不改变原列表 if (type === 'list') { const moveList = newState.splice(droppableIndexStart, 1); newState.splice(droppableIndexEnd, 0, ...moveList); console.log('Drag list', newState); return newState; } const sourceListIndex = newState.findIndex(list =\u003e droppableIdStart === list.id); const sourceList = newState[sourceListIndex]; const sourceCards = [...sourceList.cards]; //深拷贝不改变原数组 const moveCard = sourceCards.splice(droppableIndexStart, 1); if (droppableIdStart !== droppableIdEnd) { //不同列之间移动卡片 const destinationListIndex = newState.findIndex(list =\u003e droppableIdEnd === list.id); const destinationList = newState[destinationListIndex]; const destinationCards = [...destinationList.cards]; destinationCards.splice(droppableIndexEnd, 0, ...moveCard); newState[destinationListIndex] = { ...newState[destinationListIndex], cards: destinationCards }; } else { //同列中改变卡片次序 sourceCards.splice(droppableIndexEnd, 0, ...moveCard); } newState[sourceListIndex] = { ...newState[sourceListIndex], cards: sourceCards }; console.log('Drag card', newState); return newState; } 这样就实现了移动列表和移动卡片的状态变化逻辑，剩下的列表和卡片的增删改查的状态变化逻辑的实现就比较容易了。 ","date":"2020-05-18","objectID":"/2020-05-18-trello/:2:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"搜索卡片 在界面上实现卡片的搜索功能，实际上就是实现筛选卡片功能。我们已经在每个 List 组件中遍历其中的 Card，筛选功能就是每个 List 组件根据搜索框的输入内容选择性的遍历 Card，修改 List 组件如下： // components/List.js ... \u003cDroppable droppableId={String(id)} type=\"card\"\u003e {(provided, snapshot) =\u003e ( \u003cCardListContainer ref={provided.innerRef} isDraggingOver={snapshot.isDraggingOver} {...provided.droppableProps}\u003e // 筛选出每个 List 中符合搜索条件的 cards {getFilteredCards(cards, searchText).map((card, index) =\u003e ( \u003cCard key={card.id} id={card.id} text={card.text} listId={id} index={index} /\u003e ))} {provided.placeholder} \u003c/CardListContainer\u003e )} \u003c/Droppable\u003e 实现其中的 getFilteredCards 方法： const getFilteredCards = (cards, searchText) =\u003e { if (searchText) { console.log(searchText); return cards.filter(card =\u003e card.text.toLowerCase().includes(searchText.toLowerCase())); } return cards; }; ","date":"2020-05-18","objectID":"/2020-05-18-trello/:3:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"撤销重做功能 实现撤销重做功能可用 redux-undo 这个库，自己实现也不复杂，下面就自己实现: 实现方法是自定义一个接收 reducer 为参数，返回新 reducer 的函数(reducer enhancer)，监听 listReducer 的变化并做记录。实现思路来自 redux 官方文档。原本创建 store 时需要导出的 reducer 如下： // reducers/index.js const rootReducer = combineReducers({ lists: listReducer, ... }); export default rootReducer; combineReducers 接收值为 reducer 的函数作为参数，我们只要实现一个返回值为 reducer 的函数(reducer enhancer)就行： const rootReducer = combineReducers({ board: stateEnhancer(listReducer), ... }); export default rootReducer; board 对应的值是将 listReducer 封装后的新 reducer，这样每次调用 listReducer 时也会调用 stateEnhancer，因为函数的参数发生了变化，函数就会重新执行。 // reducers/stateEnhancer.js import { CONSTANTS } from '../actions'; const stateEnhancer = reducer =\u003e { const initialState = { previousStates: [], currentState: reducer(undefined, {}), // currentState 取 reducer 的返回值 futureStates: [] }; // 调用 reducer 时就会调用 stateEnhancer, 并返回封装后的 reducer return (state = initialState, action) =\u003e { // console.log(state.currentState); const { previousStates, currentState, futureStates } = state; switch (action.type) { case CONSTANTS.UNDO_ACTION: const previous = previousStates[previousStates.length - 1]; const newPreviousStates = previousStates.slice(0, previousStates.length - 1); return { previousStates: newPreviousStates, currentState: previous, futureStates: [currentState, ...futureStates] }; case CONSTANTS.REDO_ACTION: const next = futureStates[0]; const newFutureStates = futureStates.slice(1); return { previousStates: [...previousStates, currentState], currentState: next, futureStates: newFutureStates }; default: const newCurrentState = reducer(currentState, action); if (currentState === newCurrentState) { //初始化列表 console.log('init'); return state; } console.log('list change'); // 列表变化时 return { previousStates: [...(previousStates || []), currentState], currentState: newCurrentState, futureStates: [] }; } }; }; export default stateEnhancer; 我们用了三个数组记录 listReducer 的变化，按下撤销或者重做功能按钮时，就能在不同的 listReducer 之间切换。并且我们可以根据 previousStates， futureStates 是否为空来判断撤销，重做按钮是否可用： \u003cDoBtn onClick={undo} disabled={previousStates.length === 0} className='btn'\u003e \u003ci className=\"fas fa-undo\"\u003e\u003c/i\u003e \u003c/DoBtn\u003e \u003cDoBtn onClick={redo} disabled={futureStates.length === 0} className='btn' \u003e \u003ci className=\"fas fa-redo\"\u003e\u003c/i\u003e \u003c/DoBtn\u003e 附：源码地址 参考资料 React Beautiful Dnd 快速使用筆記 redux 文档 - 实现撤销历史 ","date":"2020-05-18","objectID":"/2020-05-18-trello/:4:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"React 组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。 React 组件分为两类，class 组件和函数组件。hooks 的出现让函数组件拥有了状态(state), 因此让自定义 hook 成为了继 render-props 和高阶组件(HOC)之后的第三种状态共享方案。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:0:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"class 组件的状态共享 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:1:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"render-props 具有 render prop 的组件接受一个函数，该函数返回一个 React 元素并调用它(回调函数)而不是实现自己的渲染逻辑。 react官网示例： class Cat extends React.Component { render() { const mouse = this.props.mouse; return ( \u003cimg src=\"/cat.jpg\" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /\u003e ); } } class Mouse extends React.Component { constructor(props) { super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = { x: 0, y: 0 }; } handleMouseMove(event) { this.setState({ x: event.clientX, y: event.clientY }); } render() { return ( \u003cdiv style={{ height: '100vh' }} onMouseMove={this.handleMouseMove}\u003e {/*使用`render`属性来动态确定要渲染的内容。*/} {this.props.render(this.state)} \u003c/div\u003e ); } } class MouseTracker extends React.Component { render() { return ( \u003cdiv\u003e \u003ch1\u003e移动鼠标!\u003c/h1\u003e {/*将 Mouse 组件中的 state 传递给 Cat 组件*/} \u003cMouse render={mouse =\u003e ( \u003cCat mouse={mouse} /\u003e )}/\u003e \u003c/div\u003e ); } } 注意 Mouse 组件中的 this.props.render 是绑定在标签模板上的render(外部传入)。这样就实现了鼠标位置状态的共享, Cat 组件能够根据鼠标位置动态移动 cat 图片。这个示例实现了 react 组件的理想状态：有状态的组件无渲染，有渲染的组件无状态。 因为 Cat 组件只是一个渲染模板，它也可以替换成如下的函数组件: const Cat = (props) =\u003e { const mouse = this.props.mouse; return ( \u003cimg src=\"/cat.jpg\" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /\u003e ); } } UI与状态分离，便于逻辑的复用。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:1:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"高阶组件(HOC) 高阶组件是参数为组件，返回值为新组件的函数，高阶组件是函数。 const EnhancedComponent = higherOrderComponent(WrappedComponent); 示例： function high(WrappedComponent){ return class extends React.Component{ constructor(){ this.state={ open:false } } componentDidMount(){ console.log('haha') } change=()=\u003e{ this.setState((state)=\u003e{//用到state需要使用回调函数修改state的值 return {open:!state.open} }) } render(){ //使用新数据渲染被包装的组件 return \u003cWrappedComponent open={this.state.open} change={this.change} /\u003e } } } class ToggleButton extends Component{//不带有自身的状态能够实现组件的复用 constructor(props){ super(props) } render(){ let {open,change}=this.props; // 来自 high 的数据 return \u003cFragment\u003e \u003cbutton type=\"primary\" onClick={change}\u003e toggle Modal \u003c/button\u003e \u003cdiv\u003e{open}\u003c/div\u003e //拿到open值 \u003c/Fragment\u003e } } // high 是一个高阶组件，传入组件作为参数，组件就能接收 high 的数据 export default high(ToggleButton)； 每个经过高阶组件处理过的组件都会复用高阶组件里边的所有逻辑，原则上高阶组件是一个纯函数，不会修改传入的组件，只是返回包装好的新组件。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:1:2","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"函数组件的状态共享 Hooks 可以让你在函数组件中使用状态(state)以及其他的 React 特性。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:2:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"自定义 hook Hook 是 React 中的一类特殊的 JavaScript 函数。自定义名为 useFriendStatus 的 hook，它通过调用 useState 和 useEffect 来订阅一个好友的在线状态。 import React, { useState, useEffect } from 'react'; function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) { setIsOnline(status.isOnline); } useEffect(() =\u003e { ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =\u003e { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; } 自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。 现在我们可以在下面两个组件中使用它： function FriendStatus(props) { const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) { return 'Loading...'; } return isOnline ? 'Online' : 'Offline'; } function FriendListItem(props) { const isOnline = useFriendStatus(props.friend.id); return ( \u003cli style={{ color: isOnline ? 'green' : 'black' }}\u003e {props.friend.name} \u003c/li\u003e ); } 这两个组件的 state 是完全独立的，Hook 是一种复用状态逻辑的方式，它不复用 state 本身。传入不同的 props，得到的 state 也不同。同样是实现了 UI 与状态分离，便于逻辑的复用。 但是使用 Hook 会有几个额外的规则： 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用 不要在普通 Javascript 函数中调用 在 React 的函数组件调用 Hook 在自定义的 Hook 中调用 Hook 自定义的 hook 必须以 “use” 开头 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:2:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"状态管理 实现状态管理的前提是能够状态共享，这就是为什么前面会先说状态共享。不同类型的组件实现状态共享的方法不同，状态管理的方案也不同。下面是一个计数器的状态管理的不同实现方案。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:3:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"class 组件的状态管理 class 组件的状态管理，通常方案是使用第三方库 Redux，结合 React-Redux 使用： $ npm i redux react-redux -S Redux 流程图 \r当 UI 的 state 变化时，组件 dispatch 发送 action 信号, reducer 接收来自 action 的信号更新 state, 然后 store 将新的 state 传递给组件，重新渲染 UI。 先创建 store，接收 reducer 为参数: import { createStore } from 'redux' import reducer from './reducer' //创建store const store = createStore(reducer) export default store; 再写 action，写 action 之前先了解一下 connect 函数 // React Redux 的 `connect` 函数 const connect(mapStateToProps, mapDispatchToProps)(Component); 可能看起来有些怪, 这样写你就明白了： //先传递两个参数将 connect 封装成高阶函数 const higherOrderComponent = connect(mapStateToProps, mapDispatchToProps); //再得到新包装的组件 EnhancedComponent const EnhancedComponent = higherOrderComponent(Component); action 就是 dispatch 中的参数。 // connect.js import { connect } from 'react-redux' const mapStateToProps = (state) =\u003e { return { count: state.count, message: state.message } } const mapDispatchToProps = (dispatch) =\u003e { return { increment: (data) =\u003e { dispatch({ type: \"INCREMENT\", num: data, message: \"Incremented\" }) }, decrement: (data) =\u003e { dispatch({ type: \"DECREMENT\", num: data, message: \"Decremented\" }) }, reset: () =\u003e { dispatch({ type: \"RESET\", message: \"Reset\" }) } } } //封装了一个高阶组件，注意高阶组件是函数 export default connect(mapStateToProps, mapDispatchToProps) 最后写 reducer，接收 action 更新 state: const initialState = { count: 0, message: \"\" } const reducer = (state = initialState, action) =\u003e { switch (action.type) { case \"INCREMENT\": return { count: state.count + action.num, message: action.message } case \"DECREMENT\": return { count: state.count - action.num, message: action.message } case \"RESET\": return { count: 0, message: action.message } default: return state; } } export default reducer; 创建一个组件测试计数器: import React, { Component } from 'react' import connect from './connect' class Count extends Component { render() { let { count, message, increment, decrement, reset } = this.props; //来自 connect return ( \u003cdiv\u003e {count} \u003cbutton onClick={() =\u003e increment(1)}\u003e+1\u003c/button\u003e \u003cbutton onClick={() =\u003e decrement(3)}\u003e-3\u003c/button\u003e \u003cbutton onClick={() =\u003e reset()}\u003ereset\u003c/button\u003e {message} \u003c/div\u003e ) } } // 导入的 './connect' 是高阶组件，传入 Count 组件, Count就能接收 store 中的数据 export default connect(Count) 根组件注册 store，并导入 count 组件： import React from 'react' import ReactDOM from 'react-dom'; import { Provider } from 'react-redux' import store from './store' import Count from './count' function App() { return ( \u003cProvider store={store}\u003e \u003cCount /\u003e \u003c/Provider\u003e ); } const rootElement = document.getElementById(\"root\"); ReactDOM.render(\u003cApp /\u003e, rootElement) 此时启动项目你发现已经能够计数了，但是我们并没有直接操作 store 啊，其实是 connect 帮我们做了这件事，可以看一下精简版的 connect 源码： import React, { Component } from 'react'; import PropTypes from 'prop-types'; const connect = (mapStateToProps, mapDispatchToProps) =\u003e (WrappedComponent) =\u003e { class Connect extends Component { static contextTypes = { store: PropTypes.object, }; constructor() { super(); this.state = { allProps: {} } } componentWillMount() { const { store } = this.context; this._updateProps(); store.subscribe(this._updateProps); } _updateProps = () =\u003e { const { store } = this.context; let stateProps = mapStateToProps(store.getState()); let dispatchProps = mapDispatchToProps(store.dispatch); this.setState({ allProps: { ...stateProps, ...dispatchProps, ...this.props, } }); }; render () { return \u003cWrappedComponent {...this.state.allProps} /\u003e } } return Connect; }; export default connect; 你会发现 store 实际上是通过 Context 创建的，Context 是 React 中的 API 方法: Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。 有了状态共享方法(高阶组件)和数据传递的方法(Context), 就能让在整个组件树中的各个组件都很方便的读取状态修改状态, 就实现了 React-Redux，下面我会用 hooks 实现类似的全局状态管理。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:3:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"函数组件的状态管理 实际上 React 已经为我们实现了相应的 hooks, 我们需要做的只是将这些 hooks 灵活的组合在一起。就能够实现状态管理了，还是以实现计数器的为例。 实现一个 React-redux 中的 store 只需以下代码： //store.js import React, { createContext, useContext, useReducer } from 'react'; import reducer from './reducer'; const StoreContext = createContext(); const initialState = { count: 0, message: \"\" }; export const StoreProvider = ({ children }) =\u003e { const [state, dispatch] = useReducer(reducer, initialState); return ( \u003cStoreContext.Provider value={{ state, dispatch }}\u003e {children} \u003c/StoreContext.Provider\u003e ) } export const useStore = () =\u003e useContext(StoreContext); useReducer 是 useState 的替代方案。它接收一个形如 (state, action) =\u003e newState 的 reducer，以及初始状态 initialState，返回值是当前的 state 以及与其配套的 dispatch 方法。 useContext 的参数必须是 context 对象，让你能够读取 context 的值以及订阅 context 的变化。调用了 useContext 的组件会在 context 值变化时重新渲染。你仍然需要在上层组件树中使用 \u003cMyContext.Provider\u003e 来为下层组件提供 context。 OK, 我们的简版 React-redux 就做好了。 写 action, 我们的状态数据从 useCounter 里获取: //storeApi.js import { useStore } from \"./store\"; export const useCounter = () =\u003e { const { state, dispatch } = useStore(); return { count: state.count, message: state.message, increment: (data) =\u003e dispatch({ type: \"INCREMENT\", num: data, message: \"Incremented\" }), decrement: (data) =\u003e dispatch({ type: \"DECREMENT\", num: data, message: \"Decremented\" }), reset: () =\u003e dispatch({ type: \"RESET\", message: \"Reset\" }) } } 写reducer, 去掉 initialState, 我们已经写在了 useReducer 里, 原因是： 注意 React 不使用 state = initialState 这一由 Redux 推广开来的参数约定。有时候初始值依赖于 props，因此需要在调用 Hook 时指定。 // reducer.js const reducer = (state, action) =\u003e { switch (action.type) { case \"INCREMENT\": return { count: state.count + action.num, message: action.message } case \"DECREMENT\": return { count: state.count - action.num, message: action.message } case \"RESET\": return { count: 0, message: action.message } default: return state; } } export default reducer; 写个组件，测试一下: //Count.js import React from \"react\"; import { useCounter } from \"./storeApi\"; export const Count = () =\u003e { const { count, message, increment, decrement, reset } = useCounter(); return ( \u003cdiv\u003e {count} \u003cbutton onClick={() =\u003e increment(1)}\u003e+1\u003c/button\u003e \u003cbutton onClick={() =\u003e decrement(3)}\u003e-3\u003c/button\u003e \u003cbutton onClick={() =\u003e reset()}\u003e Reset\u003c/button\u003e {message} \u003c/div\u003e ) } 修改根组件如下： import React from \"react\"; import ReactDOM from \"react-dom\"; import { StoreProvider } from \"./store\"; import { Count } from \"./Count\"; function App() { return ( \u003cStoreProvider\u003e \u003cCount /\u003e \u003c/StoreProvider\u003e ); } const rootElement = document.getElementById(\"root\"); ReactDOM.render(\u003cApp /\u003e, rootElement); 启动服务，发现能够计数成功，我们的状态管理方案成功了。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:3:2","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"本次实践我将使用 Angular 和 Nest.js 写一个带有状态管理，登录验证的全栈 todolist 应用。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:0:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"后端开发 后端开发使用 Nest.js 框架，本次实践是重前端的，因此后端会做得简单一些。后端是在上一次鉴权认证的代码做部分修改。如果有不懂的代码，可以参考之前的文章。此部分的讲解略过。这是后端部分生成的 swagger 接口文档: \r","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:1:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"前端开发 前端使用 Angular 框架。为什么使用 Angular? 以下几点是我选择它的原因： 1.它是前端真正意义上的框架。 2.它的一些理念是相当超前。 3.Nest.js 和 Angular 非常像。 4.前后端开发同构语言。 不过它的缺点也很显著，或者说是我的缺点： 1.学习到会用有较长的时间周期。 2.HMR(hot module replacement) 体验太差。 3.报错信息简直了。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"组件开发 导入 UI 组件库 在样式开发方面，我们使用 angular 官方提供的 Material UI。用一个 MaterialModule，导出我们需要用到的所有样式组件。 @NgModule({ exports: [ MatButtonModule, MatCardModule, MatDialogModule, MatIconModule, MatInputModule, MatListModule, MatToolbarModule, MatMenuModule, ], }) export class MaterialModule { } 这样在我们需要用到样式组件时，直接导入 MaterialModule 就好。 顶部导航 在 AppModule 中导入 MaterialModule， 然后在 app.component.html 中写入顶部 header 导航组件。 \u003cheader\u003e \u003cmat-toolbar color=\"primary\" class=\"expanded-toolbar\"\u003e \u003cdiv\u003e \u003cspan\u003e{{title}}\u003c/span\u003e \u003cbutton mat-button routerLink=\"/todos\"\u003e \u003cmat-icon\u003eview_lists\u003c/mat-icon\u003e Todo \u003c/button\u003e \u003c/div\u003e \u003cdiv\u003e \u003cbutton mat-button routerLink=\"/login\" *ngIf=\"authService.token.length == 0\"\u003e \u003cmat-icon\u003eaccount_box\u003c/mat-icon\u003e Login \u003c/button\u003e \u003cbutton mat-button routerLink=\"/login\" *ngIf=\"authService.token.length \u003e 0\" (click)=\"logout()\"\u003e \u003cmat-icon\u003eexit_to_app\u003c/mat-icon\u003e Logout \u003c/button\u003e \u003c/div\u003e \u003c/mat-toolbar\u003e \u003c/header\u003e \u003cmain\u003e \u003crouter-outlet\u003e\u003c/router-outlet\u003e \u003c/main\u003e \u003c!-- \u003cfooter\u003e\u003c/footer\u003e --\u003e 顶部导航写在 header 标签中，router-outlet 是路由插座，当路由跳转时，我们导入的组件会替换掉 router-outlet 标签。登录成功后显示 Logout button，未登录或登出用户后显示 Login button。在 css 中做些样式调整，接下来是路由注册模块。新建一个 app-routing.module.ts 组件： import { NgModule } from '@angular/core'; import { Routes, RouterModule } from '@angular/router'; const routes: Routes = [ { path: 'login', loadChildren: () =\u003e import('./features/auth/auth.module').then((m) =\u003e m.AuthModule), }, { path: 'todos', loadChildren: () =\u003e import('./features/todo/todo.module').then((m) =\u003e m.TodoModule), }, ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule], }) export class AppRoutingModule { } 我们注册了路由，因为我们会在导入的模块中进行状态管理，因此这里会用 Angular 中的 Lazy-loading 方式导入模块。这样，当路由匹配 login 时 auth.module.ts 中的 component 成为 main，当路由匹配 todos 时 todo.module.ts 中的 component 成为 main。 登录表单 在 auth.module.ts 只用一个登录组件，导入一些我们需要用到的表单模块。 @NgModule({ imports: [ CommonModule, FormsModule, ReactiveFormsModule, MaterialModule, AuthRoutingModule, ], declarations: [ LoginComponent ], }) export class AuthModule { } 先创建出 login 组件，可以用 cli 的方式生成：$ nest g component login，也可以手动新建文件：login.component.html，“error$ | async” 是因为我们传递的是 obeservable 对象，我们先不说 login.component.ts, 这一部分在后面的状态管理中再说。 \u003cmat-card\u003e \u003cmat-card-content\u003e \u003cform [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\"\u003e \u003ch2\u003eLogin\u003c/h2\u003e \u003cmat-error *ngIf=\"error$ | async\"\u003e The username and password were not recognised \u003c/mat-error\u003e \u003cmat-form-field class=\"full-width-input\"\u003e \u003cinput matInput placeholder=\"Username\" formControlName=\"username\" required\u003e \u003cmat-error\u003e Please provide a valid email address \u003c/mat-error\u003e \u003c/mat-form-field\u003e \u003cmat-form-field class=\"full-width-input\"\u003e \u003cinput matInput type=\"password\" placeholder=\"Password\" formControlName=\"password\" required\u003e \u003cmat-error\u003e Please provide a valid password \u003c/mat-error\u003e \u003c/mat-form-field\u003e \u003cbutton mat-raised-button color=\"primary\"\u003eLogin\u003c/button\u003e \u003c/form\u003e \u003c/mat-card-content\u003e \u003c/mat-card\u003e 然后注册路由 auth-routing.module.ts： import { NgModule } from '@angular/core'; import { Routes, RouterModule } from '@angular/router'; import { LoginComponent } from './login/login.component'; const routes: Routes = [ { path: '', component: LoginComponent, }, ]; @NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule], }) export class AuthRoutingModule { } todolist列表 创建 todo.component.html, 捕获 todolist 对应的增删改查事件： \u003cmat-card\u003e \u003cng-container *ngIf=\"vm$ | async as vm\"\u003e \u003ch2\u003eTodo Lists\u003c/h2\u003e \u003cmat-action-list role=\"list\"\u003e \u003capp-todo-list-item *ngFor=\"let todo of vm.todos\" [todo]=\"todo\" [loading]=\"vm.loading\" (update)=\"showEditDialog($event)\" (remove)=\"showRemoveDialog($event)\"\u003e\u003c/app-todo-list-item\u003e \u003c/mat-action-list\u003e \u003c/ng-container\u003e \u003c/mat-card\u003e \u003cdiv class=\"fab-bottom-right\"\u003e \u003cbutton mat-fab color=\"accent\" aria-label=\"Add\" (click)=\"showCreateDialog()\"\u003e \u003cmat-icon\u003eadd\u003c/mat-icon\u003e \u003c/button\u003e \u003c/div\u003e todo 单项 todolist 模板中的 remove, update 不是 js 原生事件, 我们需要注册对应的 EventEmitter，它是自定义事件触发与事件监听器功能的封装。todolist 列表是父组件，todo 单项是子组件。父子组件通讯需要用到 @Input() 和 @Output() 装饰器， @Input() 是父传子，@Output() 是子传父。todo-list-item.ts: @Component({ selector: 'app-todo-","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:1","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"登录验证 新建一个 services 文件夹，在其中新建 auth.service.ts 文件： @Injectable({ providedIn: 'root' }) export class AuthService { private api: string = environment.apiUrl + '/auth'; constructor(private http: HttpClient, private router: Router, private store: Store) { } login(user: Partial\u003cUser\u003e) { return this.http.post\u003cUser\u003e(`${this.api}/signIn`, user).pipe( mergeMap((user: User) =\u003e { this.token = user.access_token || ''; this.router.navigate(['todos']); return of(user); }) ); } get token() { return localStorage.getItem('access_token') || ''; } set token(val: string) { if (val.length \u003e 0) { localStorage.setItem('access_token', val); } } logout() { this.store.dispatch(UserActions.logout()); localStorage.clear(); } } 为 token 创建一个setter, getter 方法，登录成功后，为 token 赋值，登出后，将 token 置空。providedIn: ‘root’ 表示我们的 service 是根级作用域。客服端判断用户是否登录成功的方法就是判断我们的 token 是否为空。而服务端将 token 作为验证用户的凭据。用户登录成功后，每次需要用户验证的请求都要求验证 token。我们可以使用拦截器(Interceptor) 对网络请求重新封装。 @Injectable() export class AuthInterceptor implements HttpInterceptor { constructor(public authService: AuthService) { } intercept(req: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e { const authToken = this.authService.token; const authReq = req.clone({ headers: req.headers.set(\"Authorization\", \"Bearer \" + authToken), }); return next.handle(authReq); } } 当我们设置拦截器后，我们需要注册在根模块 app.module.ts 中。 providers: [ { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true } ], 添加了全局拦截器后我们就不必在每个请求接口都手动添加 header 的 bear 参数了。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:2","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"状态管理 状态管理是为了组件之间的数据共享。组件数据发生变化后，不通过不同组件传值这样的方式，而通过一个叫 store 的东西统一管理状态数据，监听状态数据变化。 打印日志 新建一个store文件夹，里面新建 app.state.ts 文件，将路由变化 router 加入到 AppState 中。 import { RouterReducerState } from '@ngrx/router-store'; export interface AppState { router: RouterReducerState; } 创建一个 reducers 文件夹, 里面新建 logger.reducer.ts: import { ActionReducer } from '@ngrx/store'; import { AppState } from '../app.state'; export function logger(reducer: ActionReducer\u003cAppState\u003e): ActionReducer\u003cAppState\u003e { return (state, action) =\u003e { const result = reducer(state, action); console.groupCollapsed(action.type); console.log('prev state', state); console.log('action', action); console.log('next state', result); console.groupEnd(); return result; }; } 这是参考了 NgRx 在 github 上的官方示例 的做法，实现一个控制台的日志打印，当然我们也可以在浏览器安装 redux 扩展程序。新建 index.ts，开发环境下就有日志打印: import { ActionReducerMap, MetaReducer } from '@ngrx/store'; import * as fromRouter from '@ngrx/router-store'; import { environment } from '../../../environments/environment'; import { logger } from './logger.reducer'; import { AppState } from '../app.state'; export const reducers: ActionReducerMap\u003cAppState\u003e = { router: fromRouter.routerReducer, }; export const metaReducers: MetaReducer\u003cAppState\u003e[] = !environment.production ? [logger] : []; 理解状态管理 写本篇文章的目的之一是将状态管理实践验证。之前我有说前端的状态管理相当于后端的数据库。接下来我将一步一步的验证这个说法。下面以用户状态来讲解。 定义初始状态类似于数据库的创建，action 是 store 数据的来源入口，从NgRx官网示意图中我们可以看到它可以来自用户操作(component)，也可以来自网络请求(effects)，reducer 类似于数据表，那 adapter, selector, effects 又分别是什么呢？ \r按照 Redux 的约定，reducer 必须是纯函数，接收旧状态，返回新状态。adapter 是 reducer 数据表的一行(记录)，selector 类似于 sql 中的 select 语句。而 effects 负责传递数据，和一些 DOM 操作，使用 NgRx 这套流程时，component 唯一能做的是 dispatch action, 额外的事情(副作用)就交给 effects 来做。 下面给出代码实例，可以结合代码来理解这段话。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:3","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"代码实例 初始化 reducer 表 初始状态(initialState)是定义在 reducer 中的，user.state.ts: import { EntityState, createEntityAdapter } from '@ngrx/entity'; import { User } from 'src/app/models/user.model'; export const featureName = 'user'; export interface State extends EntityState\u003cUser\u003e { needAuth: boolean; selectedId?: string; error?: any; } export const adapter = createEntityAdapter\u003cUser\u003e(); export const initialState: State = adapter.getInitialState({ needAuth: false, }); 注册 reducer 表 featureName 是我们的 reducer 表名，根模块注册时，StoreModule.forRoot(featureName, reducer)。 其他模块注册时，StoreModule.forFeature(featureName, reducer), 当在其他模块注册时，仍然需要在根模块配置 StoreModule.forRoot({})。 action 数据源 定义 Action 作为 store 数据来源，props 接收数据参数。 import { createAction, props } from '@ngrx/store'; import { User } from 'src/app/models/user.model'; export const login = createAction( '[Auth Page] User Login', props\u003c{ user: Partial\u003cUser\u003e }\u003e() ); export const loginSuccess = createAction( '[Auth Page] Login Success', props\u003c{ user: User }\u003e() ); export const loginFailure = createAction( '[Auth Page] Login Failure', props\u003c{ error: any }\u003e() ); export const logout = createAction('[Auth Page] User Logut'); effects 钩子 effects 钩取相应 action(login) 后，发送网络请求，并触发新的 action(loginSuccess 或者 loginFailure)。effects 与 action 数据交互是双向的。 @Injectable() export class UserEffects { constructor( private actions$: Actions, private authService: AuthService ) { } login$ = createEffect(() =\u003e this.actions$.pipe( ofType(UserActions.login), concatMap(({ user }) =\u003e this.authService.login(user).pipe( map((result) =\u003e UserActions.loginSuccess({ user: result })), catchError((error) =\u003e of(UserActions.loginFailure({ error }))) ) ) ), ); } adapter 记录 action 传递数据给 reducer 表, reducer 表在 loginSuccess 时就增加一行记录。 export const reducer = createReducer( initialState, on(UserActions.login, (state) =\u003e { return { ...state, needAuth: true }; }), on(UserActions.loginSuccess, (state, { user }) =\u003e { return adapter.addOne(user, { ...state, needAuth: false }); }), on(UserActions.loginFailure, (state, { error }) =\u003e { return { ...state, needAuth: true, error }; }), on(UserActions.logout, (state) =\u003e { return { ...state, needAuth: true }; }), ); selector 状态切片 我们要将新的状态作用到 component 上，这个时候就需要 selector 在 reducer 中查询，创建 user.selector.ts: const getUserState = createFeatureSelector\u003cState\u003e(featureName); const { selectEntities } = adapter.getSelectors(); export const getLogin = createSelector( getUserState, (state) =\u003e state.needAuth ); export const getError = createSelector(getUserState, (state) =\u003e state.error); export const getSelectedId = createSelector( getUserState, (state) =\u003e state.selectedId ); export const getUserEntities = createSelector(getUserState, selectEntities); export const getUser = createSelector( getSelectedId, getUserEntities, (id, entities) =\u003e (id ? entities[id] : undefined) ); 在 login.component.ts 中得到新的状态： error$ = this.store.pipe(select(UserSelectors.getError)); needAuth$ = this.store.pipe(select(UserSelectors.getLogin)); 变量中的 $ 表示得到的数据是 Observable 对象。我们可以直接将 Observable 渲染在html 中： \u003cmat-error *ngIf=\"error$ | async\"\u003e The username and password were not recognised \u003c/mat-error\u003e 也可以取订阅后的布尔值 error$.subscribe(data =\u003e data)。 在 component 中填写完登录表单后, 只需 dispatch action: this.store.dispatch(UserActions.login({ user })); 状态数据就在 component, store 之间来回传递。最后的程序如图： \r","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:4","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"思考 看到这里，你会发现，我们绕了一圈做了一件简单的事。但你可以想象，前端框架的组件化开发方式，组件之间的通信基本都是单向数据流，要是没有状态管理，父子组件还好，相隔很远的组件，只能通过一级一级向上传，再一级一级向下传，会更加麻烦。 如果需要共享的状态较少，可以直接定义在 service 中，通过 DI(依赖注入) 的方式能够很方便地传递到不同的 component 中，并不需要状态管理。 附：源码地址 参考资料 NgRx 官方文档 Angular 真的需要状态管理么？ ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:5","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"本文主要讲述如何用 typeorm 建表，建立一对一，一对多，多对多的关系，建立表的外连接。 以及在 typeorm 做查询操作的两种常用方式：Find 选项 和 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:0:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"建表 typeorm 建表时，将 @Entity() 装饰的 class 映射为数据表，entity 中 @PrimaryColumn() 装饰的属性作为表的主键, @PrimaryGeneratedColumn() 表示自动生成主键, @Column() 装饰属性作为表的属性。 @Entity() export class Photo { @PrimaryGeneratedColumn() id: number; @Column({length: 100}) name: string; @Column(\"text\") description: string; @Column() views: number; @Column() isPublished: boolean; } 数据库中的列类型是根据你使用的属性类型推断的，例如: number 将被转换为 integer，string 将转换为 varchar，boolean 转换为 bool 等。下面我们从实际的例子出发探索如何用 typeorm 建一对一、一对多、多对多的关系。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:1:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"一对一 用户 user 和用户档案 profile 是一对一关系，一个用户只有一份档案。 @Entity('users') export class UserEntity { @PrimaryGeneratedColumn() id: number; @Column() username: string; @OneToOne(type =\u003e ProfileEntity, profile =\u003e profile.user) @JoinColumn() profile: ProfileEntity; } 注意 profile 是 ProfileEntity 类型的，在数据库中存储的类型却是 profile.id 的类型。 @OneToOne 中需要指明对方 entity 的类型，指明对方 entity 的外键。@JoinColumn 必须在且只在关系的一侧的外键上。 @Entity('profiles') export class ProfileEntity { @PrimaryGeneratedColumn() id: number; @Column() gender: string; @Column() photo: string; @OneToOne(type =\u003e UserEntity, user =\u003e user.profile) user: UserEntity; } 这将生成以下数据表： +-------------+--------------+----------------------------+ | users | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | username | varchar(255) | | | profileId | int(11) | FOREIGN KEY | +-------------+--------------+----------------------------+ +-------------+--------------+----------------------------+ | profiles | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | gender | varchar(255) | | | photo | varchar(255) | | +-------------+--------------+----------------------------+ ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:2:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"一对多 用户 user 与用户发布的文章 article 是一对多关系，一个用户可发布多篇文章。 @Entity('users') export class UserEntity { @PrimaryGeneratedColumn() id: number; @Column() username: string; @OneToMany(type =\u003e ArticleEntity, article =\u003e article.author) articles: ArticleEntity[]; } @OneToMany，@ManyToOne 中需要指明对方的 entity 类型，指明对方 entity 的外键。 @Entity('articles') export class ArticleEntity { @PrimaryGeneratedColumn() id: number; @Column() title: string; @ManyToOne(type =\u003e UserEntity, user =\u003e user.articles) author: UserEntity; } typeorm 在处理 “一对多”关系时将“一”的主键作为“多”的外键 (即 @ManyToOne 装饰的属性)，建表时有最少的数据表操作代价，避免数据冗余，提高效率。这会生成以下表： +-------------+--------------+----------------------------+ | articles | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | title | varchar(255) | | | authorId | int(11) | | +-------------+--------------+----------------------------+ +-------------+--------------+----------------------------+ | users | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | username | varchar(255) | | +-------------+--------------+----------------------------+ ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:3:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"多对多 用户 user 对文章 article 的喜欢 favorite 是多对多关系。一个用户可对多篇文章标记喜欢，一篇文章可被多个用户标记喜欢。 @Entity('users') export class UserEntity { @PrimaryGeneratedColumn() id: number; @Column() username: string; @ManyToMany(type =\u003e ArticleEntity, article =\u003e article.favoritedBy) favorites: ArticleEntity[]; } @OneToMany 中需要指明对方的 entity 类型，指明对方 entity 的外键。@JoinTable 必须在且只在关系的一侧的外键上。 @Entity('articles') export class ArticleEntity { @PrimaryGeneratedColumn() id: number; @Column() title: string; @ManyToMany(type =\u003e UserEntity, user =\u003e user.favorites) @JoinTable() favoritedBy: UserEntity[]; } typeorm 的处理方式是将多对多关系转化为两个一对多关系: 用户 user 与 喜欢 favorites 一对多。 文章 article 与被喜欢 favoritedBy 一对多。 多对多关系需要采用中间表的方式处理，这是为了避免笛卡尔积的出现。这会生成以下表： +-------------+--------------+----------------------------+ | users | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | username | varchar(255) | | +-------------+--------------+----------------------------+ +-------------+--------------+----------------------------+ | articles | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | title | varchar(255) | | +-------------+--------------+----------------------------+ +-------------+--------------+----------------------------+ | articles_favorited_by_users | +-------------+--------------+----------------------------+ | articlesId | int(11) | PRIMARY KEY FOREIGN KEY | | usersId | int(11) | PRIMARY KEY FOREIGN KEY | +-------------+--------------+----------------------------+ ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:4:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"增删改查 创建好一对一，一对多，多对多的实体 entity 后，我们如何做增删改查呢？单个实体的 crud 可参考我的这一篇文章。而关联后的实体对象会作为该实体对象的一个属性, 直接对属性进行操作即可。如下是文章被用户喜欢的实现: async favoriteArticle(slug: string, user: UserEntity) { const article = await this.articleRepo.findOne({ where: { slug }}); article.favoritedBy.push(user); await article.save(); return article; } crud 操作中查询操作是我们最常遇到的，下面讲如何查询，typeorm 支持两种查询方式：Find 选项 和 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"Find 选项 在 Nest.JS 中，对具体实体的管理（insert, update, delete, load 等)我们使用的是 Repository。对应的查找方法是：Repository.find(FindOptions)。 使用 find 查询只能获得一种类型的结果：entities。 find 选项的完整例子如下： userRepository.find({ select: [\"username\"], relations: [\"profile\", \"article\"，\"article.favoritedBy\"], where: { username: \"Timber\", }, order: { id: \"DESC\" }, skip: 5, take: 10, cache: true }); 直接使用 find 是不会查出关联的对象的，要查询的关联对象需要添加到 relations 数组中。 除了 relations 以外，其他选项等同于原生 sql 操作, order 等同于 order by, skip 等同于 offset, take 等同于 limit, cache 是查询缓存。细节请参考 Find 选项。 这种查询有个局限就是只能查询到关联对象的整个实体或主键。而不能 select 关联实体的其他属性。因此更复杂的查询我们需要使用 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:1","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"QueryBuilder 使用QueryBuilder 查询可以获得两种类型的结果：entities 或原始数据。 要获取entities，请使用getOne和getMany。 要获取原始数据，请使用getRawOne和getRawMany。 它能够很方便的帮我们构造出 sql 语句，addSelect() 可以获取关联对象上的其他属性。 if (query.author) { const article = await getRepository(ArticleEntity) .createQueryBuilder('article') .select(\"article.id\", 'id') .addSelect('favoritedBy.username', 'name') .leftJoin('article.favoritedBy', 'favoritedBy') .where(\"favoritedBy.username = :name\", { name: query.author }) .getRawMany(); } 获取生成的 sql 语句可以在 getRawMany() 前获取 getSql() 或打印 printSql() 生成的sql语句。细节请参考 Query Builder。 参考资料 Typeorm 官方文档 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:2","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"鉴权(authentication)是指验证用户是否拥有访问系统的权利。传统的鉴权是通过密码来验证的。这种方式的前提是，每个获得密码的用户都已经被授权。 ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:0:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"建立用户表，密码散列 要实现鉴权认证，首先需要一张 user 表。上一次我们用 NestJS 和 Typeorm 做了最基本的 crud 操作, 这次我们用 NestJS 和 node 中最流行的身份验证库 Passport 来完成鉴权认证。为了方便，我们直接沿用上次的代码库。 创建 user module: $ nest g mo user 然后在 user 文件夹新建 user.entity.ts, 其中我们做了密码散列: import { BeforeInsert, Column, Entity, PrimaryGeneratedColumn } from 'typeorm' import * as bcrypt from 'bcryptjs'; @Entity('user') export class UserEntity { @PrimaryGeneratedColumn() id: number @Column({ length: 20 }) username: string @Column({ length: 255 }) password: string @BeforeInsert() async hashPassword() { this.password = await bcrypt.hash(this.password, 10); } } 在 user.module.ts 中注册 user 表：TypeOrmModule.forFeature([UserEntity]) 上一次我们直接在 module 中写了数据库连接配置，其实更常见的做法是写一个数据库配置文件。可以用环境变量设置数据库连接，这是 typeorm 数据库连接配置的参考地址。在文件夹建立一个 .env 文件： # App JWT_SECRET = 'ThisIsASecretKey' # Database TYPEORM_CONNECTION = mysql TYPEORM_HOST = localhost TYPEORM_USERNAME = root TYPEORM_PASSWORD = 123456 TYPEORM_DATABASE = test TYPEORM_PORT = 3306 TYPEORM_SYNCHRONIZE = true TYPEORM_LOGGING = true TYPEORM_ENTITIES = dist/**/*.entity.js 其中写了数据库配置和自定义的 jwt 密匙，关于如何生成 jwt 格式的字符串, 可以看这篇文章, 本文只讲如何使用它来做用户登录验证。 在 app.module.ts 的imports数组中修改数据库为注册：TypeOrmModule.forRoot()，然后写入 UserModule。测试一下我们的数据库连接情况：$ npm run start, 控制台打印了 sql 语句，说明我们的连接配置是对的。查看数据库会发现新增加了 user 表。 在 user 文件夹新建 user.dto.ts： import { IsString } from 'class-validator' import { ApiProperty } from '@nestjs/swagger'; export class UserDto { @ApiProperty() @IsString() readonly username: string; @ApiProperty() @IsString() readonly password: string; } 然后创建 user service：$ nest g s user，注意在 createUser 方法中一定要先 实例化 user, 再返回创建的对象。否则 user.entity.ts 中的 @BeforeInsert() 装饰的方法不会执行，密码就不会取散列后的值。 import { Injectable } from '@nestjs/common' import { InjectRepository } from '@nestjs/typeorm' import { UserEntity } from './user.entity' import { Repository } from 'typeorm' import { UserDto } from './user.dto' @Injectable() export class UserService { constructor( @InjectRepository(UserEntity) private readonly userRepository: Repository\u003cUserEntity\u003e, ) { } async createUser(userDto: UserDto) { // const user = Object.assign(new UserEntity(), userDto) const user = this.userRepository.create(userDto); return await this.userRepository.save(user); } async findUsername(username: string) { return this.userRepository.findOne({ where: { username } }) } async findAll(): Promise\u003cUserEntity[]\u003e { return await this.userRepository.find(); } } ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:1:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"实现本地认证策略 实现本地认证策略需要先安装以下依赖： yarn add @nestjs/passport passport passport-local yarn add -D @types/passport-local 说明一下，这一步不是必须的。其实本地认证就是做用户名和密码的核对，我们自己去实现也不算麻烦。但是为了和 NestJS 官网教程保持一致，我们也这样做。 创建 auth module: $ nest g mo auth，在 auth 目录下创建一个 local.strategy.ts 文件： import { Injectable, UnauthorizedException } from '@nestjs/common' import { PassportStrategy } from '@nestjs/passport' import { Strategy } from 'passport-local' import { AuthService } from './auth.service' @Injectable() export class LocalStrategy extends PassportStrategy(Strategy) { constructor(private readonly authService: AuthService) { super() } async validate(username: string, password: string) { const user = await this.authService.validateUser(username, password) if (!user) { throw new UnauthorizedException() } return user } } 使用 @nestjs/passport ，你需要继承 PassportStrategy 类来配置 passport 策略。通过调用子类中的 super() 方法传递策略选项，通过在子类中实现 validate() 方法，可以提供verify回调。Passport 定义的 所有策略 都是将validate() 方法执行的结果作为 user 属性存储在当前 HTTP Request 对象 上,你也可以自定义此属性的名称。上面文件中的 validateUser 方法需要在 auth.service.ts 自己实现，因为框架不清楚你定义的密码散列方式。 //auth.service.ts ... async validateUser(username: string, pass: string): Promise\u003cany\u003e { const user = await this.userService.findUsername(username); console.log('-----------Login-----------') if (user \u0026\u0026 bcrypt.compareSync(pass, user.password)) { return user; } return null; } ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:2:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"实现注册登录功能 创建 auth controller: $ nest g co auth，路由功能： import { UserDto } from './../user/user.dto'; import { Body, Controller, Get, Post, UseGuards, Res, Request } from '@nestjs/common' import { AuthGuard } from '@nestjs/passport' import { ApiTags, ApiBearerAuth } from '@nestjs/swagger' import { AuthService } from 'src/auth/auth.service' @ApiBearerAuth() @ApiTags('Auth') @Controller('auth') export class AuthController { constructor( private readonly authService: AuthService, ) { } @UseGuards(AuthGuard('jwt')) @Get('users') async findAll(@Request() req): Promise\u003cany[]\u003e { console.log('--------------Auth--Success---------------') console.log(req.user); return await this.authService.findAll(); } @Post('signUp') async register(@Body() req: UserDto, @Res() res) { const result = await this.authService.register(req); res.status(result.statusCode).send(result); } @UseGuards(AuthGuard('local')) @Post('signIn') async login(@Body() @Request() req: UserDto, @Res() res) { console.log('----------Login--Success-----------') console.log(req); const result = await this.authService.login(req); res.status(result.statusCode).send(result); } } 注意其中的 @UseGuards(AuthGuard(‘local’)) 装饰器，因为我们写了 local.strategy.ts文件，其中继承了 PassportStrategy 类，并实现了 validate 方法。@nestjs/passport 就会为我们实现一个 AuthGuard，我们直接在需要验证的路由前使用就好。@UseGuards(AuthGuard(‘jwt’)) 是我们接下来要讲的 JWT 认证策略。 再补充完整 auth.service.ts 文件： // auth.service.ts import { BadRequestException, Injectable, Body, Request } from '@nestjs/common' import { UserService } from '../user/user.service' import { JwtService } from '@nestjs/jwt' import * as bcrypt from 'bcryptjs'; @Injectable() export class AuthService { constructor( private readonly userService: UserService, private readonly jwtService: JwtService, ) { } async findAll(): Promise\u003cany[]\u003e { return await this.userService.findAll(); } async validateUser(username: string, pass: string): Promise\u003cany\u003e { const user = await this.userService.findUsername(username); console.log('-----------Login-----------') if (user \u0026\u0026 bcrypt.compareSync(pass, user.password)) { return user; } return null; } async register(user: any) { let userData: any; userData = await this.userService.findUsername(user.username); if (userData) { return { statusCode: 400, message: 'This username aleady exists' }; } await this.userService.createUser(user); userData = await this.userService.findUsername(user.username); return { username: userData.username, statusCode: 201 }; } async login(user: any) { return this.userService.findUsername(user.username).then((userData) =\u003e { const Token = this.createToken(userData); return { username: userData.username, access_token: Token, statusCode: 200 } }); } createToken(user: any) { const payload = { username: user.username, sub: user.id }; return this.jwtService.sign(payload); } } ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:3:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"实现 JWT 认证策略 实现了用户注册登录后，我们需要保护 API，限制有的路由地址需要用户登录后才能访问，有的路由地址需要管理员登录后才能访问。我们这里只实现需要普通用户登录后才能访问的路由。 什么是Token？ 前后端分离模式下，Token 是我们验证用户登录的常用方式。Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器会生成一个Token并将此Token，返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。 为什么要使用Token？ 在很多项目案例中，需要实现账户的功能，客户端所有的功能都基于用户已登陆的前提下才可以使用。这就要求每次客户端向服务器请求数据时都要验证账户是否正确，如果正确则按正常方式返回数据，如果错误则进行拦截并返回错误信息。但是当客户端频繁向服务器请求数据的话，每次服务器都要频繁地查询数据库。而Token正是为了 减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。并取代传统使用session的方法来进行验证。 在 Nest.js 中使用 jwt(json web token), 我们需要安装以下依赖： yarn add @nestjs/jwt passport-jwt yarn add -D @types/passport-jwt 我们在 auth.service.ts 中已经实现了生成 jwt 字符串的方法，在用户登录路由中就会调用，并返回 jwt 字符串： createToken(user: any) { const payload = { username: user.username, sub: user.id }; return this.jwtService.sign(payload); } 注意 上面 sign 的参数 payload 是可逆加密的，拿到 token 后是可以解密成明文内容的，所以这部分不要放敏感信息。 我们已经创建了 jwt 字符串作为请求令牌，那么服务端如何根据 jwt 字符串的内容，找到用户信息？ 我们就需要实现 jwt 认证策略，在 auth 文件夹下新建 jwt.strategy.ts 文件： import { Injectable } from '@nestjs/common' import { PassportStrategy } from '@nestjs/passport' import { ExtractJwt, Strategy } from 'passport-jwt' import { JWT_SECRET } from 'config' @Injectable() export class JwtStrategy extends PassportStrategy(Strategy) { constructor() { super({ jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), ignoreExpiration: false, secretOrKey: JWT_SECRET, }) } async validate(payload: any) { return { userId: payload.sub, username: payload.username }; } } 解释一下，对于 JWT 策略，Passport 首先验证 JWT 的签名并解码为 JSON 格式内容。仅在 @nestjs/passport 模块验证令牌有效后，才调用 validate() 方法。该方法将解码后的 JSON 作为其单个参数继续传递。否则。将阻止请求，抛出 401 Unauthorized 的异常。 现在来看我们的auth.controller.ts，可以将 validate() 返回值输出到控制台： // auth.controller.ts @UseGuards(AuthGuard('jwt')) @Get('users') async findAll(@Request() req): Promise\u003cany[]\u003e { console.log('--------------Auth--Success---------------') console.log(req.user); return await this.authService.findAll(); } 最后这是我们的 auth.module.ts，其中注册了 jwt 字符串过期时间，我们在 auth.service.ts 中注入了 UserService，记得导入 UserModule。 // auth.module.ts @Module({ imports: [ PassportModule, JwtModule.register({ secret: JWT_SECRET, signOptions: { expiresIn: '3600s' }, }), UserModule, ], controllers: [AuthController], providers: [AuthService, LocalStrategy, JwtStrategy], exports: [AuthService], }) export class AuthModule { } 启动项目：$ npm run start:dev，打开 http://localhost:3000/docs 在 swagger 文档模型中测试我们的 api。先 signUp, 然后 signIn, 登录成功返回 access_token，点击那个锁符号，将 access_token 的值粘贴过去，就能通过认证了。 附：源码地址 参考资料 Nest.JS 官方文档 Typeorm 官方文档 Node.js JWT 范例 ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:4:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"本篇文章将介绍如何用 Spring boot 与 Vue.js 创建一个具有基本 crud 功能的全栈 web 应用，我们将使用 bootstrap 作为项目的 UI 库，适合 web 开发初学者阅读。 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:0:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"后端接口 到 https://start.spring.io/ 去生成和下载 spring 应用，Group 填写 com.jpa，Artifact 填写 spring-jpa-demo， 其他默认选择就好，点击 Generate 就会生成并下载名压缩包，将压缩包解压，并在编辑器中打开。 我们使用 jpa 作为我们的 orm, 连接 mysql 数据库，因此在 pom.xml 中加入以下依赖。 \u003c!-- jpa driver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- spring web driver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- MySQL database driver --\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- Skip test plugin --\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cversion\u003e2.22.2\u003c/version\u003e \u003cconfiguration\u003e \u003cskipTests\u003etrue\u003c/skipTests\u003e \u003c/configuration\u003e \u003c/plugin\u003e ","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"I. 数据库连接 编写数据库连接文件 application.properties，它在 resources 文件夹中。 ## use create when running the app for the first time ## then change to \"update\" which just updates the schema when necessary spring.datasource.url=jdbc:mysql://localhost:3306/notesapi?createDatabaseIfNotExist=true\u0026useSSL=false\u0026serverTimezone=UTC spring.datasource.username=root spring.datasource.password=root spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver ## this shows the sql actions in the terminal logs spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true spring.jpa.properties.hibernate.format_sql=true ##optional, but just in case another application is listening on your default port (8080) server.port = 8034 这是我们的 src 文件夹结构，接下来的文件都会在 src 中编写。 \r在 entity文件夹中新建文件 Notes.java，这是我们的数据表映射。 package com.jpa.springjpademo.entity; import javax.persistence.*; import org.hibernate.annotations.CreationTimestamp; import org.hibernate.annotations.GenericGenerator; import org.hibernate.annotations.UpdateTimestamp; import java.util.Date; @Entity @Table(name = \"notes_table\") @GenericGenerator(name = \"jpa-uuid\", strategy = \"uuid\") // 这个是hibernate的注解/生成32位UUID public class Notes { @Id @GeneratedValue(generator = \"jpa-uuid\") @Column(name = \"notes_id\", nullable = false, length = 32) private String notes_id; // 默认创建时间 @Column(name = \"create_time\") @Temporal(TemporalType.TIMESTAMP) @CreationTimestamp private Date time; // 默认更新时间 @Column(name = \"update_time\") @Temporal(TemporalType.TIMESTAMP) @UpdateTimestamp private Date update_time; @Column(name = \"title\", nullable = true, length = 100) private String title; @Column(name = \"description\", nullable = true, length = 255) private String description; @Column(name = \"content\", nullable = true) @Lob @Basic(fetch = FetchType.LAZY) private String content; @Column(name = \"author\", nullable = true, length = 50) private String author; public String getId() { return notes_id; } public void setId(String notes_id) { this.notes_id = notes_id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public void setUpdateTime(Date update_time) { this.update_time = update_time; } public Date getUpdateTime() { return update_time; } } 在 dao 文件夹中新建文件 NotesDao.java, 只需实现 JpaRepository 接口，我们就能够连接到数据库。 package com.jpa.springjpademo.dao; import com.jpa.springjpademo.entity.Notes; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; @Repository public interface NotesDao extends JpaRepository\u003cNotes, String\u003e { } 接下来终端执行 $ mvn clean package 下载依赖，编译代码。然后 $ mvn spring-boot:run 运行项目。项目运行起来后刷新数据库，可以看到新生成名为 notesapi 的数据库，其中有一个名为 notes_table 的数据表。表示我们的数据库连接成功。 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:1","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"II. 增删改查 五步实现完整的数据增删改查和接口测试： 1.实现 Conctroller 路由处理 2.实现 Service 数据库操作 3.实现 Exception 异常捕获 4.实现 Cors 跨域配置 5.实现 Swagger 文档配置 下面是详细步骤和代码示例： 实现 Conctroller 路由处理： package com.jpa.springjpademo.controller; import com.jpa.springjpademo.entity.Notes; import com.jpa.springjpademo.service.NotesService; import org.springframework.http.ResponseEntity; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(\"/api/notes\") public class NotesController { @Autowired NotesService notesService; @RequestMapping(value = \"/all\", method = RequestMethod.GET) public List\u003cNotes\u003e getAllNotes() { return notesService.getAllNotes(); } @RequestMapping(value = \"/create\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public Notes addNotes(@RequestBody Notes notes) { return notesService.addNotes(notes); } @RequestMapping(value = \"/update\", method = RequestMethod.PUT, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public Notes updateNotes(@RequestParam(\"notes_id\") String id, @RequestBody Notes notes) { return notesService.updateNotes(id, notes); } @RequestMapping(value = \"/{id}\", method = RequestMethod.GET) public Notes getNotes(@PathVariable(\"id\") String id) { return notesService.getNotesById(id); } @RequestMapping(value = \"/delete/all\", method = RequestMethod.DELETE) public void deleteAllNotes() { notesService.deleteAllNotes(); } @RequestMapping(value = \"/delete\", method = RequestMethod.DELETE) public ResponseEntity\u003c?\u003e deleteNotes(@RequestParam(\"notes_id\") String id) { return notesService.deleteNotesById(id); } } 实现 Service 数据库操作： package com.jpa.springjpademo.service; import com.jpa.springjpademo.dao.NotesDao; import com.jpa.springjpademo.entity.Notes; import com.jpa.springjpademo.exception.ResourceNotFoundException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Service; import java.util.List; @Service public class NotesService { @Autowired NotesDao notesDao; public List\u003cNotes\u003e getAllNotes() { return notesDao.findAll(); } public Notes addNotes(Notes notes) { return notesDao.save(notes); } public Notes getNotesById(String id) { return notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id)); } public Notes updateNotes(String id, Notes notes) { Notes tnotes = notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id)); tnotes.setTitle(notes.getTitle()); tnotes.setDescription(notes.getDescription()); tnotes.setContent(notes.getContent()); tnotes.setAuthor(notes.getAuthor()); return notesDao.save(tnotes); } public ResponseEntity\u003c?\u003e deleteNotesById(String id) { Notes notes = notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id)); notesDao.delete(notes); return ResponseEntity.ok().build(); } public void deleteAllNotes() { notesDao.deleteAll(); } } 实现 Exception 异常捕获： package com.jpa.springjpademo.exception; import org.springframework.http.HttpStatus; import org.springframework.web.bind.annotation.ResponseStatus; @ResponseStatus(value = HttpStatus.NOT_FOUND) public class ResourceNotFoundException extends RuntimeException { private static final long serialVersionUID = 1L; private String resourceName; private String fieldName; private Object fieldValue; public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) { super(String.format(\"%s not found with %s : '%s'\", resourceName, fieldName, fieldValue)); this.resourceName = resourceName; this.fieldName = fieldName; this.fieldValue = fieldValue; } public String getResourceName() { return resourceName; } public String getFieldName() { return fieldName; } public Object getFieldValue() { return fieldValue; } } 实现 Cors 跨域配置： packag","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:2","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"前端界面 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"I. 初始化配置 先安装好 Vue/cli 工具: $ npm install -g @vue/cli 安装完成后生成 Vue 项目: $ vue create blog-frontend 输入此命令后，我们将看到一个简短的提示。选择 manually select features 选项（手动选择特性）。然后按空格表示选择，我们选择Babel、Router 和 Linter/Formatter。后面选项一路回车就好。 我们使用 bootstrap 库定义基本的 css 样式。在 public 文件夹的 index.html 中加入以下代码： \u003clink rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css\"\u003e \u003cscript src=\"https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js\"\u003e\u003c/script\u003e 安装 axios 处理 http 请求，这是一种基于 Promise 的浏览器 HTTP 客户端： $ yarn add axios 在 src 目录中新建文件夹 utils, 新建文件 helper.js, 对接后端接口: export const server = { baseURL: 'http://localhost:8034/api/notes' } ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:1","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"II. 创建页面组件 在 component 中新建文件夹 post, 新建三个文件：Create.vue, Edit.vue, Post.vue 新增帖子组件 Create.vue \u003ctemplate\u003e \u003cdiv\u003e \u003cdiv class=\"col-md-12 form-wrapper\"\u003e \u003ch2\u003eCreate Post\u003c/h2\u003e \u003cform id=\"create-post-form\" @submit.prevent=\"createPost\"\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"title\"\u003eTitle\u003c/label\u003e \u003cinput type=\"text\" id=\"title\" v-model=\"title\" name=\"title\" class=\"form-control\" placeholder=\"Enter title\"/\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"description\"\u003eDescription\u003c/label\u003e \u003cinput type=\"text\" id=\"description\" v-model=\"description\" name=\"description\" class=\"form-control\" placeholder=\"Enter Description\"/\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"content\"\u003eWrite Content\u003c/label\u003e \u003ctextarea id=\"content\" cols=\"30\" rows=\"5\" v-model=\"content\" class=\"form-control\"\u003e\u003c/textarea\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"author\"\u003eAuthor\u003c/label\u003e \u003cinput type=\"text\" id=\"author\" v-model=\"author\" name=\"author\" class=\"form-control\" /\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003cbutton class=\"btn btn-success\" type=\"submit\"\u003eCreate Post\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e 这是 Create.vue 组件 script 标签中的内容 import axios from \"axios\"; import { server } from \"../../utils/helper\"; import router from \"../../router\"; export default { data() { return { title: \"\", description: \"\", content: \"\", author: \"111hunter\" }; }, methods: { createPost() { let postData = { title: this.title, description: this.description, content: this.content, author: this.author }; this.__submitToServer(postData); }, __submitToServer(data) { axios.post(`${server.baseURL}/create`, data).then(data =\u003e { router.push({ name: \"home\" }); }); } } }; 修改帖子组件 Edit.vue \u003ctemplate\u003e \u003cdiv\u003e \u003ch4 class=\"text-center mt-20\"\u003e \u003csmall\u003e \u003cbutton class=\"btn btn-info\" v-on:click=\"navigate()\"\u003eView All Posts\u003c/button\u003e \u003c/small\u003e \u003c/h4\u003e \u003cdiv class=\"col-md-12 form-wrapper\"\u003e \u003ch2\u003eEdit Post\u003c/h2\u003e \u003cform id=\"edit-post-form\" @submit.prevent=\"editPost\"\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"title\"\u003eTitle\u003c/label\u003e \u003cinput type=\"text\" id=\"title\" v-model=\"post.title\" name=\"title\" class=\"form-control\" placeholder=\"Enter title\"/\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"description\"\u003eDescription\u003c/label\u003e \u003cinput type=\"text\" id=\"description\" v-model=\"post.description\" name=\"description\" class=\"form-control\"placeholder=\"Enter Description\"/\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"content\"\u003eWrite Content\u003c/label\u003e \u003ctextarea id=\"content\" cols=\"30\" rows=\"5\" v-model=\"post.content\" class=\"form-control\"\u003e\u003c/textarea\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"author\"\u003eAuthor\u003c/label\u003e \u003cinput type=\"text\" id=\"author\" v-model=\"post.author\" name=\"author\" class=\"form-control\" /\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003cbutton class=\"btn btn-warning\" type=\"submit\"\u003eEdit Post\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e 这是 Edit.vue 组件 script 标签中的内容 import { server } from \"../../utils/helper\"; import axios from \"axios\"; import router from \"../../router\"; export default { data() { return { id: 0, post: {} }; }, created() { this.id = this.$route.params.id; this.getPost(); }, methods: { editPost() { let postData = { title: this.post.title, description: this.post.description, content: this.post.content, author: this.post.author }; axios .put(`${server.baseURL}/update/?notes_id=${this.id}`, postData) .then(data =\u003e { router.push({ name: \"home\" }); }); }, getPost() { axios .get(`${server.baseURL}/${this.id}`) .then(data =\u003e (this.post = data.data)); }, navigate() { router.go(-1); } } }; 帖子详情组件 Post.vue \u003ctemplate\u003e \u003cdiv class=\"text-center\"\u003e \u003cdiv class=\"col-sm-12\"\u003e \u003ch4 style=\"margin-top: 30px;\"\u003e \u003csmall\u003e \u003cbutton class=\"btn btn-info\" v-on:click=\"navigate()\"\u003eView All Posts\u003c/button\u003e \u003c/small\u003e \u003c/h4\u003e \u003chr /\u003e \u003ch2\u003e{{ post.title }}\u003c/h2\u003e \u003ch5\u003e \u003cspan class=\"glyphicon glyphicon-time\"\u003e\u003c/span\u003e Post by {{post.author}}, {{new Date(post.updateTime).toLocaleDateString()}}. \u003c/h5\u003e \u003cp\u003e{{ post.content }}\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e 这是 Post.vue 组件 script 标签中的内容 import { server } from \"../../utils/helper","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:2","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"III. 搭建路由 在根组件 App.vue 中修改链接: \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e 将 about 改为 create, 链接到 Create 组件: \u003crouter-link to=\"/Create\"\u003eCreate\u003c/router-link\u003e 最后将 router/index.js 改为以下代码： import Vue from 'vue' import Router from 'vue-router' import HomeComponent from '@/views/Home'; import EditComponent from '@/components/post/Edit'; import CreateComponent from '@/components/post/Create'; import PostComponent from '@/components/post/Post'; Vue.use(Router) export default new Router({ mode: 'history', base: process.env.BASE_URL, routes: [ { path: '/', redirect: { name: 'home' } }, { path: '/home', name: 'home', component: HomeComponent }, { path: '/create', name: 'Create', component: CreateComponent }, { path: '/edit/:id', name: 'Edit', component: EditComponent }, { path: '/post/:id', name: 'Post', component: PostComponent } ] }); 编写完前端代码，启动服务： $ npm run serve 浏览器打开 http://localhost:8080 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:3","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"成果展示 pc端展示： \r移动端展示：\r\r附：源码地址 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:3:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":" ReactiveX 结合了 观察者模式、迭代器模式 和 使用集合的函数式编程，以满足以一种理想方式来管理事件序列所需要的一切。 在 RxJS 中用来解决异步事件管理的的基本概念是： Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。 Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。 Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。 Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。 Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。 Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。 以上文字来自 RxJS 中文文档，是 RxJS 的核心概念。 下面来学习创建 Observable 对象以加深对一些概念的理解。 本文将生成 observable 的操作符分为以下四类： 转换操作符：from，fromEvent，fromPromise，of 创建操作符：create, range 时间操作符：interval, timer 特殊操作符：empty, never, throw ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:0:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"项目初始化 我们使用 webpack 作为项目构建工具。使用 Babel 编译我们的代码。这是我们的项目依赖： \"devDependencies\": { \"@babel/core\": \"^7.8.7\", \"@babel/preset-env\": \"^7.8.7\", \"babel-loader\": \"^8.0.6\", \"webpack\": \"^4.42.0\" }, \"dependencies\": { \"jquery\": \"^3.1.0\", \"rxjs\": \"^5.0.0-beta.12\" } webpack 配置文件 webpack.config.js: module.exports = { entry: './src/app.js', output: { path: __dirname + '/dist', filename: 'app.bundle.js' }, module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } ] } } 新建文件夹src, 在里面新建文件 app.js, 我们在 app.js 中引入 jquery 和 RxJS。 import $ from 'jquery'; import Rx from 'rxjs/Rx'; console.log('Code Running...'); 在 html 文件中引入编译后的 js 文件。 \u003cbody\u003e \u003cinput type=\"text\" id=\"input\"\u003e \u003cdiv id=\"output\"\u003e\u003c/div\u003e \u003cul\u003e \u003cli id=\"name\"\u003e\u003c/li\u003e \u003cli id=\"artist\"\u003e\u003c/li\u003e \u003c/ul\u003e \u003cscript src=\"./dist/app.bundle.js\"\u003e\u003c/script\u003e \u003c/body\u003e 执行 webpack --watch --mode development，实时监视文件变化，并重新编译代码。 打开浏览器控制台没有任何报错，并输出 “Code Running…” 说明我们的项目构建成功。 高版本的 chrome 可能出现 DevTools failed to parse SourceMap，在控制台的setting中取消 Enable JavaScript source maps 这一项即可。 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:1:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"转换操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.from() Observable.from() 将 可迭代对象 转化为 observables 序列, 传入数据集合。 // from array const numbers = [1, 2, 3, 4, 5]; const numbers$ = Rx.Observable.from(numbers); numbers$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), () =\u003e console.log('complete') ); // from string const str = 'hello world' const str$ = Rx.Observable.from(str); str$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), () =\u003e console.log('complete') ); // from array of objects const posts = [ { title: 'post 1', body: 'body 1' }, { title: 'post 2', body: 'body 2' }, { title: 'post 3', body: 'body 3' } ]; const posts$ = Rx.Observable.from(posts); posts$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), () =\u003e console.log('complete') ); // from set const set = new Set(['hello', 123, { title: 'my title' }]) const set$ = Rx.Observable.from(set); set$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), () =\u003e console.log('complete') ); // from map const map = new Map([[1, 2], [3, 4], [5, 6]]) const map$ = Rx.Observable.from(map); map$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), () =\u003e console.log('complete') ); ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.fromEvent() Observable.fromEvent() 将 事件 转化为 observables 序列, 传入两个参数：页面元素 和 事件名称。从事件中创建的 observable 对象是持续不断产生的，不会输出 “completed”。 转化键盘事件: const input = $('#input'); const output = $('#output'); const inputStream$ = Rx.Observable.fromEvent(input, 'keyup'); inputStream$.subscribe( e =\u003e { console.log(e.target.value); output.text(e.target.value); }, err =\u003e console.log(err), () =\u003e console.log('completed') ); 转化鼠标事件: const moveStream$ = Rx.Observable.fromEvent(document, 'mousemove'); moveStream$.subscribe( e =\u003e { console.log(e.type); output.html('\u003ch1\u003eX: ' + e.clientX + ' Y: ' + e.clientY + '\u003c/h1\u003e'); }, err =\u003e console.log('err'), () =\u003e console.log('completed') ); ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:2","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.fromPromise() Observable.fromPromise() 将 promise 转化为 observables 序列, 传入 promise。 const myPromise = new Promise((resolve, reject) =\u003e { console.log('creating promise'); setTimeout(() =\u003e { resolve('hello from promise'); }, 500); }); const myPromiseSource$ = Rx.Observable.fromPromise(myPromise); myPromiseSource$.subscribe(x =\u003e console.log(x)); 结合之前定义的 inputStream$ 嵌套使用： function getSong(username) { return $.ajax({ type: 'GET', url: `https://autumnfish.cn/search?keywords=` + username, }).promise(); } const song = $('#input') const inputStream$ = Rx.Observable.fromEvent(song, 'keyup') inputStream$.subscribe(e =\u003e { Rx.Observable.fromPromise(getSong(e.target.value)) .subscribe(x =\u003e { $('#name').text('Song: ' + x.result.songs[0].name) console.log(x.result.songs[0].name) $('#artist').text('Artist: ' + x.result.songs[0].artists[0].name) }); } ); ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:3","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.of() of 操作符接收1个或多个参数。转换为 Observable 对象。 const stream$ = Rx.Observable.of(1, 2, 3, 'hello'); stream$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), complete =\u003e console.log('complete') ); ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:4","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"创建操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.create() Rx.Observable.create 是 Observable 构造函数 的别名，它接收一个以 observer 作为参数的回调函数。这个回调函数会定义 observable 将会如何发送值给 observer。observer是什么？observer就是我们之前传入 subscribe() 的参数，是一个有三个回调函数的对象。 const source$ = new Rx.Observable.create( observer =\u003e { observer.next('hello') observer.next('another hello') setTimeout(() =\u003e { observer.next('next hello') observer.complete(); }, 2000); } ); const observer1 = { next: v =\u003e console.log(v + '1'), error: err =\u003e console.log(err), complete: () =\u003e console.log('complete') } source$.subscribe(observer1); observable 是数据流的生产者，决定数据怎么给。observer 是数据流的消费者，决定数据怎么用。observable 是老板，observer 是顾客。 observable.subscribe()会实例化一个Subscription对象。Subscription表示Observable 的执行，可以被清理。这个对象最常用的方法是unsubscribe方法。 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.range() 接收两个数字参数产生有序序列，一个是开始序列数字。一个是序列个数。 const rangeSource$ = Rx.Observable.range(6, 5) rangeSource$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), complete =\u003e console.log('complete') ) ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:2","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"时间操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:4:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.interval 和 Observable.timer 从零开始产生数字，interval的参数是数字产生的间隔时间，timer 多了个开始延迟时间作为第一个参数。 const intervalSource$ = Rx.Observable.interval(1000).take(5) intervalSource$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), complete =\u003e console.log('complete') ) const timerSource$ = Rx.Observable.timer(2000, 1000).take(5) timerSource$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), complete =\u003e console.log('complete') ) ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:4:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"特殊操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:5:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.empty(), Observable.never() 和 Observable.throw() Observable.empty 创建的 Observable 开始就结束，Observable.never 创建的 Observable 不会结束，Observable.throw 抛出异常不会结束。 const emptySource$ = Rx.Observable.empty() emptySource$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), complete =\u003e console.log('complete') ) const neverSource$ = Rx.Observable.never() neverSource$.subscribe( v =\u003e console.log(v), err =\u003e console.log(err), complete =\u003e console.log('complete') ) const errorSource$ = Rx.Observable.throw('err') errorSource$.subscribe( v =\u003e console.log(v), err =\u003e console.log('Throw Error: ' + err), complete =\u003e console.log('complete') ) 附：源码地址 参考资料 RxJS Ultimate 中文版 30 天精通 RxJS RxJS 中文文档 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:5:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"随着代码量的增长传统的 MVC 模式中 Modal 和 Controller 会变得含糊不清，导致难于维护。 传统 MVC 与 NestJS 架构对比： \rNest(Nest.js) 的分层借鉴自 Spring，更细化。我们应该要了解整个 Nest 框架的三层结构，Nest 和传统的 MVC 框架的区别在于它更注重于后端部分（控制器、服务与数据）的架构，视图层相对比较独立，完全可以由用户自定义配置。 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:0:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"创建 Nest 项目 $ npm install -g @nest/cli 全局安装 nest 脚手架 $ nest new nest-crud 新建 nest.js 项目, 选择 yarn 作为开发工具 $ nest g mo photo 建立 PhotoModule $ nest g co photo 建立 PhotoController $ nest g s photo 建立 PhotoService $ yarn add @nestjs/typeorm typeorm mysql 需要使用 typeorm, mysql 需要安装这些库 在 TypeORM 中数据库的表对应的就是一个类，通过定义一个类来创建实体。实体（Entity）是一个映射到数据库表的类 (类似于 mongoose 中的 Schema 映射到 MongoDB 的 collection)，通过@Entity()来标记。在photo文件夹中新建 photo.entity.ts: // photo.entity.ts import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm'; @Entity('photo') export class PhotoEntity { @PrimaryGeneratedColumn() id: number; @Column({ length: 500 }) name: string; @Column('text') description: string; @Column() filename: string; @Column('int') views: number; @Column() isPublished: boolean; } 在 app.module.ts 中的 import 数组中配置数据库连接，可以配置多个数据库连接。 TypeOrmModule.forRoot({ type: 'mysql', host: 'localhost', port: 3306, username: 'root', password: '123456', database: 'test', entities: [PhotoEntity], synchronize: true, }) 然后在 photo.mudule.ts 中 import 数组中注册要本模块使用的数据库。这样，我们就可以使用 @InjectRepository() 装饰器将 PhotoRepository 注入到 PhotoService 中 imports: [TypeOrmModule.forFeature([PhotoEntity])] 数据传输对象简称 DTO(Data Transfer Object)，是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。class-validator 可以很方便地验证前端传过来的参数。 // photo.dto.ts import { IsString, IsInt, IsBoolean } from 'class-validator'; export class PhotoDto { @IsInt() readonly id: number; @IsString() readonly name: string; @IsString() readonly description: string; @IsString() readonly filename: string; @IsInt() readonly views: number; @IsBoolean() readonly isPublished: boolean; } ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:1:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"三层结构 将 PhotoRepository 注入到 PhotoService 中, 写数据库操作的 crud 代码: @Injectable() export class PhotoService { constructor( @InjectRepository(PhotoEntity) private readonly photoRepository: Repository\u003cPhotoEntity\u003e, ) { } async findAll(): Promise\u003cPhotoEntity[]\u003e { return this.photoRepository.find(); } async create(photoDto: PhotoDto): Promise\u003cPhotoEntity\u003e { return await this.photoRepository.save(photoDto) } async delete(id: number) { return await this.photoRepository.delete(id) } async update(photoDto: PhotoDto) { return await this.photoRepository.update(photoDto.id, photoDto) } async findOne(id: number): Promise\u003cPhotoEntity\u003e { return await this.photoRepository.findOne(id) } } 将 PhotoService 注入到 PhotoController 中, 写 api 路由: @Controller('photo') export class PhotoController { constructor(private readonly photoService: PhotoService) { } @Get() findAll(): Promise\u003cPhotoEntity[]\u003e { return this.photoService.findAll(); } @Post('create') create(@Body() PhotoDto: PhotoDto): Promise\u003cPhotoEntity\u003e { return this.photoService.create(PhotoDto) } @Delete('delete/:id') delete(@Param('id') id: number) { return this.photoService.delete(id) } @Put('update/:id') update(@Param('id') id: number, @Body() PhotoDto: PhotoDto) { return this.photoService.update(PhotoDto) } @Get(':id') findOne(@Param('id') id: number): Promise\u003cPhotoEntity\u003e { return this.photoService.findOne(id) } } 接下来在 main.ts 中配置 swagger, 方便我们测试 api const app = await NestFactory.create(AppModule); const options = new DocumentBuilder() .setTitle('photo example') .setDescription('The photo API description') .setVersion('0.0.1') .build(); const document = SwaggerModule.createDocument(app, options); SwaggerModule.setup('docs', app, document); await app.listen(3000); $ npm run start 启动 nest 项目, 访问 http://localhost:3000/docs ，到这里基本的 crud 操作已经实现，此时，NestJS框架的三层结构已有体现。接下来再完善项目。 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:2:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"AOP 的思想 我们在 PhotoController 的路由请求参数中传入了 DTO, 做了直接的参数校验。传入类型不符合要求时，会直接报错。DTO 中的class-validator 还需要配合 pipe 才能完成校验功能。新建一个 pipe 捕获异常。$ nest g pi section/validation @Injectable() export class ValidationPipe implements PipeTransform\u003cany\u003e { async transform(value, metadata: ArgumentMetadata) { const { metatype } = metadata if (!metatype || !this.toValidate(metatype)) { return value } const object = plainToClass(metatype, value) const errors = await validate(object) if (errors.length \u003e 0) { const errorMessage = _.values(errors[0].constraints)[0] throw new BadRequestException(errorMessage) } return value } private toValidate(metatype): boolean { const types = [String, Boolean, Number, Array, Object] return !types.find(type =\u003e metatype === type) } } 有了这一层 pipe 帮助我们校验参数，有效地降低了类的复杂度，提高了可读性和可维护性。我们还可以对正确的请求，异常的请求进行包装，假设返回的格式是这样的： # 请求失败 { status: 1, message: string, } # 请求成功 { status: 0, message: '请求成功', data: any } 可以利用 AOP 的思想去做这件事。全局捕获错误的切片层去处理所有的 exception，如果是一个成功的请求，需要把这个返回结果通过一个切片层包装一下。 在 NestJs 中，Exception Filter 是最后捕获 exception的机会。我们把它作为处理全局错误的切片层。$ nest g f section/errors @Catch() export class ExceptionsFilter implements ExceptionFilter { async catch(exception, host: ArgumentsHost) { const ctx = host.switchToHttp() const response = ctx.getResponse() const request = ctx.getRequest() let message = exception.message let isDeepestMessage = false while (!isDeepestMessage) { isDeepestMessage = !message.message message = isDeepestMessage ? message : message.message } const errorResponse = { message: message || '请求失败', status: 1, } const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR response.status(status) response.header('Content-Type', 'application/json; charset=utf-8') response.send(errorResponse) } } 而 Interceptor 则负责对成功请求结果进行包装：$ new g in section/transform interface Response\u003cT\u003e { data: T } @Injectable() export class TransformInterceptor\u003cT\u003e implements NestInterceptor\u003cT, Response\u003cT\u003e\u003e { intercept( context: ExecutionContext, next: CallHandler, ): Observable\u003cResponse\u003cT\u003e\u003e { return next.handle().pipe( map(rawData =\u003e { return { data: rawData, status: 0, message: '请求成功', } } ) ) } } 将 Interceptor, Exception Filter 和 Pipe 定义在全局范围内: app.useGlobalFilters(new ExceptionsFilter()); app.useGlobalInterceptors(new TransformInterceptor()); app.useGlobalPipes(new ValidationPipe()); $ npm run start 打开 http://localhost:3000/docs, 测试 api 结果正如我们预期的那样。 附：源码地址 参考资料 DI(依赖注入) NestJS 官方文档 TypeORM 官方文档 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:3:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"本文实践较多，建议跟着文章的步骤敲一遍代码以加深理解。 \r","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:0:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"1. 使用帮助 $ git help 可以查看 git 常用命令 $ git help -a 可以查看 git 所有命令，F 或者 空格 向下查看命令，B 向上查看命令，Q 退出 git-cli $ git help add help后接一个指令可以查看该指令的详细用法 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:1:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"2. git 配置范围 git 配置分为三个范围 system, global 和 项目范围 一般选择global进行配置 $ git config --global user.name '111hunter' $ git config --list 查看当前配置信息 $ git config --unset --global user.name 取消 user.name 配置 配置文件是当前用户主目录 $ cat ~/.gitconfig ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:2:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"3. git 项目文件 $ mkdir movietalk \u0026\u0026 cd movietalk 新建文件夹 $ git init 初始化项目 $ cd .git \u0026\u0026 ls -a config 目录就是项目级别的配置 $ cd .. \u0026\u0026 touch index.html 新建文件 $ vim index.html 编辑文件后保存 $ git add . 提交所有文件到暂存区 $ git commit -m \"first commit\" 暂存区文件提交仓库区 $ git log 查看提交日志信息 $ vim index.html 将index.html中 charset=“UTF-8” 改为 charset=“GBK” $ git status 查看文件状态 $ git diff index.html 查看暂存区文件与本地工作区的对比 $ git diff --staged 查看仓库区与暂存区对比，此时一致 $ git add . 然后 $ git diff index.html 此时没有区别了，因为已将文件提交暂存区 $ vim index.html 再次修改，在文件中新增适应移动端的 meta 标签 $ git diff --staged 查看仓库区与暂存区对比 $ git commit -m \"修改了charset属性\" 暂存区提交仓库 $ git diff --staged 此时暂存区与仓库一致 $ git log 查看提交日志信息, 此时有两条提交信息 $ git status 查看文件状态 $ git add . \u0026\u0026 git commit -m \"新增meta标签\" 工作区文件提交到仓库 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"重命名 git 已跟踪文件 $ touch style.css \u0026\u0026 vim style.css 新建css文件 $ mv style.css theme.css 修改文件名 $ git status 查看文件状态 $ git rm style.css \u0026\u0026 git add theme.css 就能修改文件名字 $ git commit -m \"mv style.css theme.css\" 上传仓库区 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:1","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"git 移动文件 $ git mv theme.css aha.css 移动文件，重命名 $ mkdir css \u0026\u0026 git status git 不会跟踪空文件 $ git mv aha.css /css 移动文件 $ git commit -m \"move aha.css\" 上传仓库区 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:2","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"git 删除文件与恢复 $ git rm index.html 从工作区与暂存区中删除index.html $ git checkout HEAD -- index.html HEAD 指针指向最近一次提交， – 表示当前分支，将index.html恢复到当前 commit 的状态 $ git rm index.html \u0026\u0026 git commit -m \"删除了index.html\" 从工作区与暂存区中删除index.html, 并提交仓库 $ git checkout \"HEAD^\" -- index.html 恢复到上一次提交，windows cmd 中 ^ 会被当做换行处理，需要加上引号 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:3","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"git 恢复某个操作状态 在 css 文件夹引入 bootstrap vim index.html 在 index.html 中引入 bootstrap git commit -am \"增加了bootstrap\" 提交仓库 新建 js 文件夹并引入 jquery vim index.html 在 index.html 中引入 jquery git commit -am \"增加了jquery\" 提交仓库 git log --oneline 查看提交日志 id, 添加 bootstrap 的 id 为 981eb52 git revert 981eb52 撤销对 bootstrap 的提交，查看工作区文件夹发现 index.html 对 bootstrap 的引入消失了 每次 git commit 后 HEAD 都会指向最后一次提交，用 git reset 可以帮助回到某次提交时的状态，有 3 个可选配置参数: –mixed, –soft, –hard –soft 软重置，不会修改任何文件状态。该参数用于git commit后，又要恢复还没commit的场景，重新审查代码，然后再推上去覆盖之后的提交。 $ git log --oneline 查看添加 jquery 的 id 为 e9ae8b5，Revert “添加了bootstrap\"的 id 为 3e3da01 $ git reset --soft e9ae8b5 回到提交 jquey 的 commit，但是不会对文件做任何操作 $ git status 会提示 撤销 bootstrap 时的消息 默认是 –mixed, 只影响暂存区文件状态 $ git reset --mixed e9ae8b5 \u0026\u0026 git status 发现 bootstrap 已经不在暂存区了 –hard 会直接重置暂存区和工作区文件到指定 id 状态，用 git reset –hard 可直接在不同提交状态切换。 $ git reset --hard e9ae8b5 \u0026\u0026 git log --oneline 查看工作区文件发现 bootstrap又回来了 $ git reset --hard 3e3da01 \u0026\u0026 git log --oneline 文件又到了最后一次提交时的状态 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:4","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"4. git 项目分支 $ git branch testing \u0026\u0026 git checkout testing 新建并切换分支，此时对文件的修改只影响 branch 分支 $ vim index.html 在 index.html 中引入 link 标签 $ git commit -am \"添加link标签\" 提交仓库区 $ git checkout master 切换回 master 分支，查看工作区文件发现对文件的修改没有了 $ git diff master..testing index.html 查看分支间的文件对比 $ git merge testing 分支合并 $ git diff master..testing 没有不同，已经合并了分支 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"解决分支合并冲突 $ vim index.html 修改 document 为 Movietalk $ git commit -am \"修改标题为Movietalk\" 提交仓库区 $ git checkout testing \u0026\u0026 vim index.html 切换分支，修改 document 为 Movie-talk $ git commit -am \"修改标题为Movie-talk\" 提交仓库区 $ git merge master 产生冲突。git 发现冲突，查看文件会有提示，编辑保留其中一个 document 修改 $ git commit -am \"解决冲突\" 提交 $ git log --oneline --all -10 --graph 查看所有分支提交信息 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:1","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"保存当前工作状态 git stash 指令能够保存当前工作状态到 git 栈 $ touch human.txt \u0026\u0026 git commit -am \"add human.txt\" 新建空文件 $ vim human.txt 加入任意内容 $ git status 查看修改，不提交 $ git stash save \"修改了human.txt\" 保存工作进度，查看文件 human.txt 又变成了空文件 $ git stash list 查看工作进度 $ git stash show -p stash@{0} 以补丁的方式查看工作进度与工作目录的区别 $ git stash apply stash@{0} 切换到之前的工作进度，发现对 human.txt 的修改又生效了 $ git stash pop 切换栈顶工作状态 $ git stash drop stash@{0} 删除工作状态 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:2","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"5. git 远程仓库 新建远程仓库后请清空仓库，不要保留任何文件 $ git remote add origin https://gitee.com/hunter_111/movietalk.git 关联远程仓库 $ git remote -v 查看是否关联, fetch 远程用来提取，push 远程用来推送 $ git push -u origin master 推送到远程分支，并跟踪远程分支变化 $ git push origin testing 推送远程分支，不跟踪变化 参考资料 廖雪峰的 git 教程 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:5:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"扫雷是一款大众类的益智小游戏,于1992年发行。游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子,同时避免踩雷,踩到一个雷即全盘皆输。 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:0:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"游戏规则 \r在写扫雷之前，我们先了解下它的游戏规则： 扫雷是一个矩阵，地雷随机分布在其中的方格里。 方格上的数字代表着这个方格所在的九宫格内有多少个地雷。 游戏玩家用鼠标左键打开方格，用鼠标右键标记地雷。 踩到地雷，游戏失败。打开所有非雷方格，游戏胜利。 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:1:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"功能实现 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"矩阵的生成 用 html 中的表格 table，span 生成矩阵方格。把矩阵方格放入二维数组中，然后对单个方格添加鼠标事件。 //初始化矩阵 (row-行数 col-列数) function init_grid() { //生成矩阵html \u003ctr\u003e--行标签 \u003ctd\u003e--列标签 let gridHtml = ''; for (let i = 0; i \u003c row; i++) { gridHtml += '\u003ctr\u003e' for (let j = 0; j \u003c col; j++) { gridHtml += '\u003ctd\u003e\u003cspan class=\"blocks\" onmousedown=\"block_click(' + i + ',' + j + ',event)\"\u003e\u003c/span\u003e\u003c/td\u003e'; } gridHtml += '\u003ctr\u003e' } //写入html document.getElementById('grid').innerHTML = gridHtml; //返回矩阵二维数组 let blocks = document.getElementsByClassName('blocks'); let grid = new Array(); for (let i = 0; i \u003c blocks.length; i++) { if (i % col === 0) { grid.push(new Array()); } //初始化计雷数 blocks[i].count = 0; grid[parseInt(i / col)].push(blocks[i]); } return grid; } ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:1","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"方格打开与标记 通过 onmousedown 事件，传入点击的方格的坐标及event，判断event为左键还是右键。左键打开方格，右键标记方格。 //方格点击事件 _i：坐标i _j:坐标j e:鼠标事件 function block_click(_i, _j, e) { //跳过已打开的方格 if (grid[_i][_j].isOpen) { return; } //鼠标左键打开方格 if (e.button === 0) { ... //执行递归打开方格函数 block_open(_i, _j); } //鼠标右键标记方格 else if (e.button === 2) { let block = grid[_i][_j]; if (block.innerHTML !== '▲') { block.innerHTML = '▲'; } else { block.innerHTML = ''; } } } ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:2","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"地雷随机分布 第一次打开的方格不能为地雷，把生成地雷的函数放在第一次点击方格后。 通过循环用 Math.random() 函数来随机生成地雷的二维坐标。 判断坐标是否不为第一次点击方格的坐标以及该坐标没有雷存在。 是则将方格设置为地雷，当前地雷数+1，将该方格所在九宫格内的方格的计雷数+1。 否则跳过进入下个循环，直到地雷的数量达到设定的最大雷数，结束循环。 //方格点击事件 _i：坐标i _j:坐标j e:鼠标事件 function block_click(_i, _j, e) { //跳过已打开的方格 if (grid[_i][_j].isOpen) { return; } //鼠标左键打开方格 if (e.button === 0) { //第一次打开 if (isFirstOpen) { isFirstOpen = false; let count = 0; //当前地雷数 //生成地雷 while (count \u003c maxCount) { //生成随机坐标 let ri = Math.floor(Math.random() * row); let rj = Math.floor(Math.random() * col); //坐标不等于第一次点击方格的坐标 \u0026\u0026 非雷方格 if (! (ri === _i \u0026\u0026 rj === _j) \u0026\u0026 !grid[ri][rj].isMine) { grid[ri][rj].isMine = true; //自定义属性isMine代表方格为地雷 count++; //当前地雷数+1 //更新九宫格内非雷方格的计雷数 for (let i = ri - 1; i \u003c ri + 2; i++) { for (let j = rj - 1; j \u003c rj + 2; j++) { //判断坐标防越界 if (i \u003e -1 \u0026\u0026 j \u003e -1 \u0026\u0026 i \u003c row \u0026\u0026 j \u003c col) { //计雷数+1 grid[i][j].count++; } } } } } } //执行打开方格函数 block_open(_i, _j); } } ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:3","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"递归打开方格 当打开的方格为计雷数为0的方格，自动打开九宫格内的非雷方格。如果打开的非雷方格九宫格内仍有非雷方格，用递归继续打开九宫格内的非雷方格，直到没有为止。 //递归打开方格函数 function block_open(_i, _j) { let block = grid[_i][_j]; op(block); //设定打开方格的状态与样式 function op(block) { block.isOpen = true; //isOpen为自定义属性，设置为true代表已打开 block.style.background = '#ccc'; //将背景设置为灰色 block.style.cursor = 'default'; //将鼠标停留样式设置为默认 } //打开计雷数为0的方格 if (block.count === 0) { //遍历九宫格内的方格 for (let i = _i - 1; i \u003c _i + 2; i++) { for (let j = _j - 1; j \u003c _j + 2; j++) { //判断是否越界\u0026\u0026跳过已打开的方格\u0026\u0026非雷 if (i \u003e -1 \u0026\u0026 j \u003e -1 \u0026\u0026 i \u003c row \u0026\u0026 j \u003c col \u0026\u0026 !grid[i][j].isOpen \u0026\u0026 !grid[i][j].ismine) { //递归打开方格函数 block_open(i, j); } } } } // 踩雷 else if (block.isMine) { ... } //打开计雷数不为0的方格 else { block.innerHTML = block.count; //显示计雷数 } } ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:4","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"踩雷游戏结束 打开方格为地雷时，提示游戏结束。通过遍历矩阵打开所有埋地雷位置。 else if (block.isMine) { block.innerHTML = '雷'; //显示为 '雷' //遍历矩阵打开所有埋地雷的方格 for (let i = 0; i \u003c row; i++) { for (let j = 0; j \u003c col; j++) { //找到地雷 block = grid[i][j]; if (!block.isOpen \u0026\u0026 block.isMine) { op(block); //设置打开状态和样式 block.innerHTML = '雷'; //显示为 '雷' } } } clearInterval(timer); //游戏结束停止计时，清除定时器 //提示游戏结束 alert(\"你踩到雷了！游戏结束\"); } ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:5","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"游戏胜利条件 当所有非雷方格被打开即为游戏胜利。在每次打开方格函数中都遍历一遍矩阵，当找到有未打开的非雷方格时则退出遍历，遍历完所有方格均未找到未打开的非雷方格时则游戏胜利。 //方块点击事件 _i：坐标i _j:坐标j e:鼠标事件 function block_click(_i, _j, e) { //跳过已打开的方块 if (grid[_i][_j].isOpen) { //... } //鼠标左键打开方块 if (e.button === 0) { //... } //鼠标右键标记方块 else if (e.button === 2) { //... } //遍历矩阵 let isWin = true; for (let i = 0; i \u003c row; i++) { for (let j = 0; j \u003c col; j++) { let block = grid[i][j]; //如果有未打开的非雷方块 if (!block.isMine \u0026\u0026 !block.isOpen) { isWin = false; } } } if (isWin) { alert(\"游戏胜利\"); } } 游戏逻辑部分到这里就结束了，剩余雷数和计时可用全局变量实现。 附：源码地址 参考资料 原生 JS 实现扫雷 (分析+代码实现) ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:6","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"ECMAScript 6(以下简称ES6)是 JavaScript 语言的下一代标准,已经在2015年6月正式发布了。Mozilla公司将在这个标准的基础上,推出 JavaScript 2.0。ECMAScript 和 JavaScript 是什么关系？简单来说，ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:0:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"let和const var 函数作用域function scope,不在函数内时作用域是全局的 用let和const声明变量, let, const 块级作用域block scope,作用域是{}内 eg.执行以下语句判断区别： for (var i = 0; i \u003c 10; i++) { console.log(i); setTimeout(function () { console.log(`i:${i}`); }, 1000) } for (let i = 0; i \u003c 10; i++) { console.log(i); setTimeout(function () { console.log(`i:${i}`); }, 1000) } let, const不能重复声明变量值 let声明的变量是可以重新赋值的, const声明的变量只能修改引用类型的属性值 变量提升：let, count有变量提升,未声明先使用存在临时性死区(Temporal dead zone),详见mdn ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:1:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"箭头函数 特点：简明的语法,隐式返回(省去return关键字),匿名函数 this:普通函数this是动态绑定的 const Jelly = { name: 'Jelly', hobbies: ['Coding', 'Sleeping', 'Reading'], printHobbies: function () { // console.log(this); this.hobbies.map(function (hobby) { // console.log(this); console.log(`${this.name}loves ${hobby}`); }) } } Jelly.printHobbies(); map中的回调函数是一个独立的函数,不作为对象的方法,并且没有通过call bind apply 来改变里面的this，this指向window,严格模式下指向undefined const Jelly = { name: 'Jelly', hobbies: ['Coding', 'Sleeping', 'Reading'], printHobbies: function () { // console.log(this); var self = this; this.hobbies.map(function (hobby) { // console.log(this); console.log(`${self.name}loves ${hobby}`); }) } } Jelly.printHobbies(); 箭头函数的this值继承父作用域,是词法作用域,定义的时候就指向明确,且不会绑定this： const Jelly = { name: 'Jelly', hobbies: ['Coding', 'Sleeping', 'Reading'], printHobbies: function () { // console.log(this); this.hobbies.map(hobby =\u003e { // console.log(this); console.log(`${this.name}loves ${hobby}`); }) } } Jelly.printHobbies(); 命名函数在递归,事件绑定时有用,在箭头函数中使用： const greet = name =\u003e {alert(`Hello ${name}`)}; 箭头函数不适用的情况： 需要使用this慎用 需要使用arguments(箭头函数没有arguments) ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:2:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"模板字符串 模板字符串中的换行和空格都是会被保留的。 模板字符串可嵌套,支持三元表达式。 标签模板字符串,是一个函数的调用。 alert`Hello world!`; // 等价于alert('Hello world!'); ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:3:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"解构赋值 针对数组或者对象进行模式匹配,然后对其中的变量进行赋值。 是对赋值运算符的扩展,方便提取对象属性值,可嵌套可忽略。 let [a, b, c, d, e] = 'hello'; let obj = {p: ['hello', {y: 'world'}] }; let {p: [x, { y }] } = obj; // x = 'hello' // y = 'world' let obj = {p: ['hello', {y: 'world'}] }; let {p: [x, { }] } = obj; // x = 'hello' ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:4:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"计算属性 对象字面定义属性名位置的 [ ] 中可以放置任意合法表达式。 const keys = ['name', 'age', 'birthday'] const values = ['jelly', 18, '2016-01'] const Laravist = { [keys.shift()]: values.shift(), [keys.shift()]: values.shift(), [keys.shift()]: values.shift(), } console.log(Laravist); ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:5:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Symbol ES6引入了一种新的原始数据类型表示独一无二的值,最大的用法是用来定义对象的唯一属性名。 用于生成唯一标识符避免命名冲突,可作为私有属性在对象内部使用,不能for循环遍历 const classRoom = { [Symbol('lily')]: { grade: 60, gender: 'female' }, [Symbol('nina')]: { grade: 70, gender: 'female' }, [Symbol('nina')]: { grade: 90, gender: 'female' }, } const syms = Object.getOwnPropertySymbols(classRoom).map(sym =\u003e classRoom[sym]); console.log(syms); ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:6:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"剩余参数 const player = ['jelly', 123, 2.4, 3.6, 1.7] const [name, id, ...scores] = player; console.log(name, id, scores); 扩展运算符可以将可遍历对象元素扩展成新的参数序列,而不用改变原来的对象 const younger = ['aaa', 'bbb', 'ccc']; const older = ['xxx', 'yyy', 'zzz']; const members = [...younger, 'ddd', ...older]; const newmembers = members; ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:7:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Promise Promise用于避免回调地狱 const p = new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { reject(Error('Laravist isn\\'t awesome!')); }, 2000); }) p.then(data =\u003e { console.log(data) }) .catch(err =\u003e { console.error(err) }); await操作符用于等待一个Promise对象,它只能在异步函数async function内部使用。 await针对所跟不同表达式的处理方式： Promise对象：await 会暂停执行,等待Promise对象resolve,然后恢复async函数的执行并返回解析值。 非Promise对象：直接返回对应的值。 function testAwait(x) { return new Promise(resolve =\u003e { setTimeout(() =\u003e { resolve(x); }, 2000); }); } async function helloAsync() { var x = await testAwait(\"hello world\"); console.log(x); } helloAsync(); ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:8:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Class class是语法糖,本质是funciton,没有变量提升 一个继承的例子: function MyArray() { Array.apply(this, arguments); } const colors = new MyArray(); colors[0] = 'red'; console.log(colors.length); //undefined colors.length = 0; console.log(colors[0]); //red ES5 是先新建子类的实例对象this, 再将父类的属性添加到子类上,原生构造函数会忽略apply方法传入的this, 父类的内部属性无法获取,导致无法继承原生的构造函数。 class MyArray extends Array { constructor() { super(); console.log(this); } } const colors = new MyArray(); colors[0] = 'red'; console.log(colors.length); // 1 colors.length = 0; console.log(colors[0]); // undefined ES6 允许继承原生构造函数定义的子类,因为ES6是先新建父类的实例对象this, 然后再用子类的构造函数修饰this,使得父类的素有行为都可以继承。 ES6 可以自定义原生数据结构的子类，这是 ES5 无法做到的。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:9:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"一些补充 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"新增for…of循环： 先回顾js中for循环的几种写法 const fruits = ['apple', 'banana', 'orange', 'mango']; for (let i = 0; i \u003c fruits.length; i++) { console.log(fruits[i]); } 可读性不是很好 fruits.forEach(fruit =\u003e { console.log(fruit); }) 不能在循环中break或continue for (let index in fruits) { console.log(fruits[index]); } 会遍历对象上所有可枚举属性 for (let fruit of fruits) { console.log(fruit); } 不会遍历数组中非数字属性,能够break或continue 应用数组解构语法 for (let [index, fruit] of fruits.entries()) { console.log(`${fruit}rank in ${index + 1}in my favorite fruits`); } for…of可以应用于可迭代对象(部署了iterator接口或提供Symbol.iterator方法的数据结构) 数组,字符串,arguments,NodeList,map.set等,但不支持对象 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:1","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Array.from()和Array.of() es6新增数组方法Array.from()和Array.of()： 注意是数组原型对象上的静态方法 Array.from()用于把可迭代对象转化成数组,Array.of()传入参数生成数组 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:2","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Proxy与Reflect Proxy与Reflect是ES6为了操作对象引入的 API 。 Proxy 可以对目标对象的读取、函数调用等操作进行拦截,然后进行操作处理。它不直接操作对象,而是像代理模式,通过对象的代理对象进行操作。 ES6中将Object的一些明显属于语言内部的方法移植到了Reflect对象上。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:3","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"迭代器与生成器 Iterator是ES6引入的一种新的遍历机制,通过一个键为Symbol.iterator的方法来实现。 Generator函数:在function后面,函数名之前有个*,函数内部有yield表达式。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:4","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Map与Set Object的键只能是字符串或者Symbols, Map的键可以是任意值,Map中的键值是有序的(FIFO原则),Map的键值对个数可以从size属性获取。 Set对象允许你存储任何类型的唯一值,NaN与NaN是不恒等的,但是在Set中只能存一个。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:5","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"闭包就是能够读取其他函数内部变量的函数。在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成\"定义在一个函数内部的函数\"。闭包是将函数内部和函数外部连接起来的桥梁，实现了变量的私有化问题。 有如下例子，我们想要用一个counter记录add函数的执行次数。 function add() { var counter = 0; //局部变量 counter++; console.log(\"counter = \" + counter); } add(); // counter = 1 add(); // counter = 1 由于counter是局部变量，每次我们执行add()函数，都是输出 counter = 1; 我们想要执行函数时改变counter的值，一种可行的办法是： var counter = 0; //全局变量，谁都可以访问，修改 function add() { counter++; console.log(\"counter = \" + counter); } add(); // counter = 1 add(); // counter = 2 但是这样会带来问题，由于counter是全局变量，我们可能会在函数外不小心改变了counter的值， 比如在函数外写了一句counter = -100；就打乱了我们原来的计数，显然我们并不希望在函数外任意地改变counter的值。 我们可以这样写： function add() { var counter = 1; //局部变量 console.log(\"counter = \" + counter); plus = function() { //全局函数 counter++; console.log(\"counter = \" + counter); } } add(); //counter = 1 counter初始化 plus(); //counter = 2 这样我们就无法在函数外任意改变counter了，进一步的写法是： function add() { var counter = 1; //局部变量 console.log(\"counter = \" + counter); var plus = function() { //局部函数 counter++; console.log(\"counter = \" + counter); }; return plus; } var plus1 = add(); // counter = 1 plus1(); // counter = 2 plus函数名有些多余，add可以简化为立即执行函数。 var plus1 = (function add() { var counter = 0; //局部变量 return function() { //全局函数 counter++; console.log(\"counter = \" + counter); }; })(); plus1(); // counter = 1 plus1(); // counter = 2 发现add函数名也可以去掉了，简化为匿名函数，如下就是闭包的一般写法： var plus1 = (function() { var counter = 0; //局部变量 return function() { counter++; console.log(\"counter = \" + counter); }; })(); plus1(); // counter = 1 plus1(); // counter = 2 闭包实现了变量私有化，局部变量的本质，全局变量的生命周期。闭包本质是利用作用域链，即当前环境中存在指向父级作用域的引用。 ","date":"2019-10-07","objectID":"/2019-10-17-js-basis/:0:0","tags":["JavaScript"],"title":"JS 闭包写法的演变过程","uri":"/2019-10-17-js-basis/"},{"categories":null,"content":"关于网站 个人博客，记录所学所思。 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于我 无无明，亦无无明尽，乃至无老死，亦无老死尽。 无苦集灭道，无智亦无得，以无所得故。 一沙一世界，一花一天堂。无限掌中置，刹那成永恒。 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于版权 本站所有原创文章均受 创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0 保护。 任何个人及媒体在转载本站原创内容 (包含文字、图像、摄影作品等) 时请遵守以下版权要求： 注明转载； 注明来源为本站首页网址，或所转内容在本站的完整网址。 ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"}]