[{"categories":["Thinking"],"content":" 从上学开始，你一生都在重复别人的话。因此你是二手的人。 — 克里希那穆提 你必须不断质疑，纯真地看待事实，抛开你在质疑过程中可能会出现的各种恐惧，永不追随任何人。然后从那种纯真之中，从那种探询之中，你就会发现真理是什么。 思考是从一个结论开始的吗？思考是不是从一个结论到另一个结论的运动？如果思考是肯定的，思考会存在吗？最高形式的思考不是否定的吗？所有的知识不是一个定义、结论和肯定性声明的集合吗？肯定的思想是以经验为基础的，它总是过去的结果，这样的思想永远不能发现新事物。 有没有一种智慧的行动？在这些问题上，你必须始终或多或少地保持一种质疑的态度，质疑是净化头脑和心灵的一个非同寻常的因素。质疑，精心地思量，会带来非凡的清晰和自由。 如果你确实认真，如果你真的想过没有任何冲突的生活，那就必须搞清楚怎样立即结束人类的问题，马上就结束。这意味着你要对问题投入全身心的关注，并且意味着你不是在寻找答案。因为如果你想找答案，就会在问题之外找，然而你要是全身心关注问题，答案就在问题之中，而不在问题之外。 如果你能只是观察自己头脑的运转过程，而不去进行任何判断、评价、批判或者比较，仅仅只是观察，就像观察一颗星星那样，冷静地、安静地观察，没有任何焦虑感——那么你将发现，自我认识并不是一个时间问题。 什么是事实，什么不是事实？当只有事实时，事实中没有二元性，没有对立面。你是什么比你应该是什么重要得多。你能够领悟“是”，但你无法领悟“应该是”。没有对幻想的领悟，只有对其形成方式的领悟。虚构、臆想、理想没有真实性，它是一种结果、一个目标，重要的是领悟其产生的过程。 领悟你“是”什么，愉快或不愉快，虚构、理想和自我投射的将来式必须彻底终止。那时，你才能够抓住“是”。要领 悟“是”，就必须摆脱一切游离。游离是对“是”的谴责或辩解。游离是比较。是对真实的对抗和约束。游离对于领悟来说是刻意和强迫。 所有游离都是对直接领悟“是”的阻碍。“是” 并不静止，而是处于不断地运动之中，要跟上它，头脑必须不被任何信仰、任何成功的希望和失败的恐惧所束缚。只有在无为和警醒的觉知中，“是”才得以显现，这种显现与时间无关。 如果我们能领悟“是”，或许所有这些问题都会终止。我们对待问题的方法是逃避它，我们想对它做些什么。那种“做”阻止了我们与它的直接联系，这种方式阻止了对问题的领悟。头脑忙于寻找一种对付问题的方法，而其实是对问题的逃避。因此问题永远没有被领悟，它依然存在。 问题即“是”，要它打开，完整地述说自己的故事，头脑必须快速紧跟。如果我们通过逃避，通过了解如何对付问题，或者寻找解释和起因（那只是个口头结论）来麻醉头脑，那么头脑就被弄得迟钝，无法紧跟问题，即“是”展开的故事。 看清这一真实，头脑是灵敏的。而只有那时，它才能接纳。头脑围绕问题的一切活动只能令它迟钝，从而无法紧跟和倾听问题。当头脑灵敏而不是被迫灵敏(那只是令其迟钝的另一种方式)时，那么存在、空，就有了全然不同的含义。 头脑和“是”的关系是什么呢？迄今为止，“是”被赋予一个名字、一种说法、一种联系的符号，这种命名阻止了直接联系，令头脑迟钝、呆滞。头脑和“是”不是两个分离的过程，但命名分裂了它们。只有当这种命名停止，オ会有直接联系：头脑与“是”合而为一。 那时头脑就处于体悟的状态，其中，经历者和经验都没有了。那时就会有不可估量的深度，因为估量者没有了。那种深远是安静、宁和，在这宁和之中就是无穷无尽的源泉。头脑的骚动是词语的运用。没有了词语，就有了无限。 参阅资料 节选自 《Commentaries On Living》 ","date":"2024-05-12","objectID":"/2024-05-12-second-hand-human-being/:0:0","tags":["Time"],"title":"二手人类","uri":"/2024-05-12-second-hand-human-being/"},{"categories":["Thinking"],"content":" 重要的不是定义存在的目的、重要性和意义，而是找出头脑为什么会问这个问题。 — 克里希那穆提 我们都有这种感受：自己好似核心，孤立于所有经验之外，孤立于世界之外。 如果我们仔细观察“在这儿的自己”以及“在那儿的世界”，不难发觉它们实际是同样一种知觉。 也就是说，我对主体之我的知觉和我对客体的世界的知觉，是同样的知觉，经验界与经验者之间根本没有界限，…… 乍听之下，实在荒谬，因为我们一向认为有界限的：我是听见声音的听者，感觉的承受者，看见风景的观众。 可是为什么我会把自己当作听众或观众呢？ 我们的知觉真的如此复杂，必须包含观者，观看，所观三种互不相属的存在吗？ 它们当然不可能是三种不同的存在。 世上有既不在看，也没有观看对象的观者？有既无观者，也无所观的观看？观者、观看以及所观对象不过是一个行动的不同角度罢了。缺一不可。 可是我们却用观者、观察以及对象三个不同的词来形容观看这么简单的一个行为。那么，我们何不称水流为“水流所流的流水”呢？ 我们非假定有观者，观看的过程以及所获得的观看结果不可；而且很自然地认定了自己是观者，和所观各据一方。我们的世界原本只是一个，如今一分为二，“观者在这边”虎视眈眈地与“那的东西”对峙着。 让我们反过来注意一下经验产生的那一刻，观者是否真的与被观之对象有所不同？ 就从听开始吧！ 闭起眼睛来，仔细注意听的过程。注意四周所飘动的奇怪声音：鸟鸣车嚣声、蟋蟀声、孩子们的嬉笑声，电视的刺耳音乐。 可是不论你怎么仔细去听，有一种声音绝对听不到，就是听者。你无法在声音之外，听出那个听见声音的听者来。 正因为听者根本不存在，你才听不到听者，只有听的经验而已。在真实世界中只有一连串的声音，没有主客之别，没有界限。 如果你肯让你脑子里自命为听者的那个知觉化入聆听之内，你会发现你那个“自我”渐渐融入整个音界中。 有一位禅师有过这种悟道经验：“当我听到寺里的钟声响起时，突然钟与我消失了，只有钟声响着。” 观音菩萨就是透过听潮音而悟道的，他全神贯注于声音里，终于发现在在听的过程中，并没有一个对立的听者。 不论你多么努力想听出那个听者来，你所得到的仍只是外在的声音而已。因此我们可以说，你并不是听到声音，你就是那声音。听者只是所听到的种种声音而已，背后并没有一个独立的个体听见声音。 看，也是同样的情形。 当我仔细注视眼前的景色，它好像就悬在虚无的空间，充满了层层光谱，形色；这儿是山，那儿是云，下面是溪水。所有的景色中，你就是看不见那正在欣赏的景色的观者。 我愈努力去看，愈惊讶地发现，那个观者根本不在。 多年来，我很自然地认定我是那观看景色的观者，可是我怎么也找不到它的踪影，我所看到的都是被看到的东西而已。 因此，我们可以说，并不是我这“观者”在看景色，而是此刻，我这观者和所有景色一样临在而已。所谓的观者，和所有被观之物并无分别。 例如当我看到一棵树，并非两种经验，一种叫做“树”的经验。一种叫做“看树”的经验。它只是一个单纯的“看-见-树”的经验。我看不到这个“看”，我也闻不到“闻”，尝不出“尝”的滋味。 每当我们想找出和经验对立的主体时，最后总是消失在经验之内；我们想找出经验者，所找到的只是另一种经验罢了，主体与客体总是归为一个。 这种思考过程可能令你愈来愈迷惘了，那么我们不妨再追究下去，当你在思考这一切时，你能找出正在思考的思考吗？ 当我们想：“我越来越迷糊了”，究竟有没有正在想的一个思考者，还是只有这个想法：“我越来越迷糊了？” 当然只有当下这个想法。不然的话，你会想这个主体正在想这个思想。于是我们不难看出，以前我们所认定的思想主体，是无法与当前的思想分开的。 当“我越来越迷糊了”这想法出现时，你并没有同时想到那是一个思想者在想“我越来越迷糊了”。那时，只有一个思想，就是“我越来越迷糊了”。当你开始去追踪那个思想的主体时，你只找到另一个思想：“我想我越来越糊涂了。”你永远无法在当前的思想之外，找到另一个思想的主体。最后，我们只能说：它们本来就是一个。 因此，许多修行人常提醒我们，不用打倒自我，只需深入观察，你会发现它根本不存在。 然而，即使我们已经逐渐了解，根本没有一个对立的听者、尝者、观者、想者，我们却发现自己仍然不由自主地感到有个孤立而不同的自我，还是感到自己和外在的世界是分开的两回事，里面就是有一种“我”的感觉，即使我看不见，尝不到，听不见这个我，我却实实在在感到这个自我。 然而，除了当前这个你称为自我的感觉之外，你能够找到产生这感觉的另一个主体吗？ 其实，主体的那个感觉，也只不过是另一个感觉罢了。 感觉者原来只是当下的一种感觉，就好像思想者只是一个思想，只是一种尝受。同样的，在当前一连串的感受外，并没有另一个感受的主体，从来没有过。 那么，我们便不难引申出这一结论：在这具体经验世界之外，并没有另一个对立的自我存在。虽然你一向认定自己是一个分开的经验主体，可是你认真地去找它时，它却销声匿迹了。 亚伦·华特说：“这单纯的经验，并没有另一个东西或一个人在经验这一经验。你不会感到某种感觉，想出某个思想，觉出某个知觉来，就好像你不会听到听觉，看到视觉或嗅到嗅觉一样。 “我觉得很好”只是显示此刻很好的感觉而已，并不是你把一个叫做“我”的东西和另一个“感觉”凑合在一起，变成我感觉到这个好的感觉。 这个当前的感觉就是“我”，并非两个东西。没有人能在当下的感觉以外找出另一个我来，或是在我之外，找到某种感觉，它们两个其实是同一回事。” 如今，你已经明白了，在你与你的经验之间并没有隔阂。那么你大概就不难了解，在你与你所经验的世界之间，有没有隔阂。 如果你就是你的经验，你也就是你所经验的世界了。你并没有对于鸟的某种感觉，你就是感觉到鸟而已；你并不是有种对桌子的经验，你就是那个桌子的经验；你不会听到雷声，你就是那个雷声。内在所谓的你与外在所谓的世界本是同一个知觉经验，不同的名称而已。 并没有人强迫你应该这样去感觉，这实在是你唯一能感觉得到的感觉。 不论你意识到与否，这种意识境界就是一体意识，此刻你就是宇宙，你就是当前经验的总合。因为阻碍一体意识的那个对立的我，只不过是一种错觉罢了。 因此我们可以说，你当下一刻的心境，始终就是一体意识。根本不必费心去销毁那个不存在的自我。你只需加以观察，在你遍寻不得的那一刹那，你就已经身处于一体意识中了。 这种“无我”或“无自性”的慧见，不论听起来多玄，一直是古圣贤哲和“常青哲学”的精髓。佛经就有一段精彩扼要的开示： 只有苦，而无受苦者； 只有一连串的造作在行，却无造作之人； 道在眼前，终无行者。 从正面来讲，当人意识到自己原是那个整体，那么就没有任何外物能带来痛苦，也没有东西能伤及宇宙。从反面来讲，这个慧见本身即是解脱，因为它认出了连受苦的自我本身都不存在。 受苦的只是有缺的部分，而非圆满的整体。 这种觉悟，修行者以“消极”的语气来说，便是“一旦你恍悟到那有缺的一部分只是幻觉，你便由痛苦中解脱了”。以“积极”的语气来说，便是：“你一直是圆满的整体，它是纯粹的自由，解脱，光明之境。一旦悟入那圆满的整体，便自然由痛苦及死亡中解脱出来。” 当我们识破部分的虚妄，便证入整体；当我们悟入“无自性”的当儿，我们的真我便成了大我。就在无界限的光明觉照之下，孤立的自我错觉，立刻融入宇宙整体中。不论你由哪个角度去看，面面都是本来面目。 历史上各宗教及玄学，曾采用各种不同的名字来称它：圣子，圣神，如来，宇宙人，婆罗门，大我等等。它们和另一座专有名词：法界，空性，如来，神圣本体，都是象征那无界限的真实世界，只是角度有所不同罢了。 目前许多人喜欢用”真我”来称呼它，显示出它是人的核心所在，人类最内的现实。 宗教家们不断强调：“天国就在我们内”。只要我们深入心灵深处，便不难发现与一切存有同在的”真我”。我们好像都染上了忘失身份的重病，真正的大我只能静静地潜伏在那里，等待着我们去发掘。 古今圣贤所望的只是我们能醒悟过来藏在假我之下的本来面目，因此不断警告我们，凡是我们能推想出或觉察到的我，决不是真我。我的心识，身体，思想，希望，其实和树木，星星，云彩，高山一般，都是我的认知对象，故不可能构成真我。 如此追问下去，我变的越来越透明，而且体会到，我远远超出这孤立的有机生命之外；我愈深入这个我，我变的离它愈远。 观到究竟，我们的意识会突然灵光一现，发现我们愈追求那大智慧，愈明白它不是一种可以执着的个体。原因很简单，因为它是每一样东西。我无法感觉到它，因为它是每一个感觉。我无法经验到它，因为它是每一个经验。 正因为我看到的所有东西都是这个大智慧，所以我看到的某一”个体”，便不是大智慧。于是我向内寻找自我时，我找到了整个世界。 这真是奇妙的发现，内在的自我原来就是外在的真实世界，反之亦然。主体与客体，内在与外在，竟是同一回事，并没有什么根本界限。这世界就是我的身体，能观也就是所观。 参阅资料 节选自 Ken Wilber《No boundary》 推荐阅读 深度睡眠时，意识在哪里？- 鲁珀特·斯派拉 ","date":"2024-05-06","objectID":"/2024-05-06-the-last-question/:0:0","tags":["Advaita"],"title":"最后的问题","uri":"/2024-05-06-the-last-question/"},{"categories":["Thinking"],"content":" 当你告诉一个孩子什么是鸟时，如果他们相信了，那么他们就再也看不到鸟了。他们只看到了自己的想法。— 克里希那穆提 问: 不命名、不贴标签的话，我们怎么能觉察到一种情绪？如果我意识到一种感觉，似乎在它一出现，我就立即知道那是什么感觉了。或者你所说的“不要命名”有其他的意思? 克: 我们为什么要给事物命名？我们为什么要给一朵花、一个人、一种感觉贴上标签？要么是为了交流我们的感觉，为了描述那朵花，诸如此类；要么就是为了认同那种感觉。不是那样吗？我为了交流而命名一种感觉，如“我生气了”。或者我认同那种感觉，就为了加强它或消除它，或对它采取行动。比如一朵玫瑰，为了与别人交流它，我们给它命名；或者通过命名，我们就以为了解了它。我们说“那是一朵玫瑰”，匆匆看上一眼，然后就走开了。 我们以为，给它一个名字，就是了解它了。我们把它分类，认为那样就了解了那朵花的全部内容和美。给事物命名，只不过把它分门别类，我们就以为了解了它，就不再更仔细地观察它。然而，如果不给它一个名字，我们就不得不观察它。也就是说，我们用一种新的观察方式来接近花或别的什么。我们观察它，仿佛以前从未见过它。 命名是与人和事物打交道相当方便的办法——说别人是德国人、日本人、美国人、印度人，你可以给他们贴上标签或是除掉标签。如果不给他人贴标签，就不得不观察他们，那样一来，要杀掉他们就会很难下手。你可以用炸弹除掉那个标签，感觉正气凛然，但如果不贴标签，你就必须观察这个个体 — 不管是一个人还是一朵花、一个事件、一种情绪 — 那时，你就不得不考虑你与它的关系，考虑你与接下来的行动的关系。所以命名或贴标签是与任何东西打交道非常方便的办法，你可以非常轻易地否定它、谴责它或为它辩护。 这是这个问题的一个方面。 命名事物的核心是什么？那个一直在命名、选择、贴标签的中心是什么？我们都感觉到存在一个中心、一个核心，那是我们作出行动、进行判断和命名的源头。那个中心、那个核心是什么？有些人倾向于认为那是精神本体、上帝之类的东西。所以，我们就来弄清楚那个核心、那个中心，它一直在命名、称呼和判断。显然那个核心是记忆，不是吗？一系列的感觉，被认同的、被封闭的感觉 — 过去，通过现在获得重生的过去。那个核心，那个中心，通过命名、贴标签和回忆，依靠现在供养而活着。随着披露展开，我们很快就会看到，只要这个中心、这个核心存在，就不可能了解事物。只有消解那个核心，才能了解事物。因为，说到底，那个核心就是记忆，关于各种经验的记忆。这些经验被命名，被贴上标签，被认同。带着那些被命名、被贴上标签的经验，从那个中心出发，我们接受、拒绝，下决心做什么或不做什么，根据记忆中的感觉、快乐和痛苦作出种种反应。所以，那个中心就是那个词。如果不命名那个中心，还存在一个中心吗？ 换句话说，如果不通过语言思考，如果不使用词语，你可以思考吗？思考是通过语言表达来形成的，或者说，语言表达开始对思考作出回应。那个中心、那个核心是无数快乐和痛苦的经验的回忆，它被语言化了。请在你的内心观察这一点，你会看到词语变得比实质更重要，标签变得比实质更重要。我们依靠词语活着。 对我们来说，真理、上帝之类的词语，或者这些词语所代表的感觉，已变得相当重要。当我们说出“美国人”、“基督徒”、“印度教徒” 或“愤怒” — 我们就是代表感觉的词语。但我们并不清楚那个感觉是怎样的，因为那个词变得重要了。如果你称自己为佛教徒、基督徒，那个词是什么意思？那个词背后的含义是什么？ 你从未审视过那些。我们的中心、那个核心，就是那个词、那个标签。如果标签不重要，如果重要的是标签背后的东西，那你就可以一探究竟，但如果你认同了那个标签，死守不放，你就无法前行。然而，我们认同了那个标签：那所房子、那个形式、那个称号、那些家具、那个银行账户、我们的观点、我们的兴奋剂，等等。我们就是那一切 — 那些东西被一个名称所代表。东西变得重要了，名称、标签变得重要了；因此，那个中心、那个核心就是那个词。 如果没有词语，没有标签，没有中心，就会有一种消解、一种空，不是吗？— 不是那种有所恐惧时的空，那完全不是一回事。会有一种感觉，一种什么也不是的感觉，因为你去除了所有的标签，更准确地说，因为你了解了你给情绪和观念贴标签的原因，你焕然一新了，不是吗？ 你行动的时候，不再有一个中心。那个中心，即那个词，被消解了。标签被除去，哪里还有一个充当中心的你？你还在，但已发生转变。那个转变有点吓人，于是你就止步不前，你已开始判断，开始抉择你是喜欢还是不喜欢这样。你没有在已有的领悟下前进，你已经在判断了，意思就是，你的行动是从一个中心出发的。因此，你一旦判断，你就止步了；“喜欢”、“不喜欢”这样的字眼变得重要了。 但如果不命名，那会怎样呢？你会更加直接地体验一种情绪、一种感觉，因而与它产生截然不同的关系，正如你要是不命名一朵花，就必须观察它。你被迫重新看它。如果不命名一群人，你就不得不挨个看每一张脸，不把他们概括为大众。因此你就会警醒得多，敏锐得多，更富有同情心；你有一种更深的怜悯和爱，但如果把他们概括为大众，一切就结束了。 如果不贴标签，你就必须留心出现的每一种感觉。你贴标签的时候，感觉与标签有区别吗？还是标签唤醒了感觉？请好好思考一下。贴标签的时候，我们大部分人都强化了感觉。感觉和命名是即刻的。如果在命名和感觉之间有一个间隔，你就可以弄清楚感觉是否与命名不一样，然后你就能不去命名而直接处理感觉。 怎样从我们命名的一种感觉，比如从愤怒中解脱出来，这才是问题，不是吗？不是怎样征服它、怎样升华它或压抑它，那些做法既愚蠢又幼稚，但要怎样真正从中解脱呢？要真正从中解脱，我们就必须看看词语是不是比感觉更重要。“愤怒”那个词比那个感觉本身更重要。要真正发现那一点，感觉和命名之间就必须有间隔。这是一个方面。 如果我不命名一种感觉，意思就是思想不在词语里打转，或者说如果我不使用词语、意象或符号思考，那是大多数人的做法— 那会怎样？显然那时，头脑就不只是观察者了。如果头脑不使用词语、符号和意象思考，就不存在一个有别于思想即词语的思想者。那时头脑就是安静的，不是吗？不是被迫安静，而是真正安静下来。当头脑真正安静下来，出现的感觉就可以即刻得到处理。 只有当我们命名感觉，并因而强化了它们，那些感觉才得以延续；它们被储存在那个中心，我们再贴上更多的标签，不是为了强化它们，就是为了谈论它们。当头脑不再是那个中心，不再充当一个由词语和过去的经验构成的思考者——那一切都是记忆、标签，被储存起来，分门别类 — 如果不做那些事情，头脑自然就安静了下来。它不再被束缚，不再是那个中心、那个“我”——我的房子、我的成就、我的工作 — 这些仍然是词语，推动了感觉并因而强化了记忆。如果这一切都没有发生，头脑就是非常安静的。那个状态并非一种拒绝。相反，要走到这一步，你必须经历上述种种，这可是相当艰巨的工作；并不是学一套说辞，然后像个小学生似的反复念叨 — “不要命名”、“不要命名”。要了解其中全部的含义，一路追踪到底，体验它，观察头脑怎样工作，因而走到不再命名的那一步，意思就是，不再有一个有别于思想的中心 — 显然，这整个过程就是真正的冥想。 当头脑真正安静下来，那不可测度的境界才有可能出现。任何其他的过程，任何其他对真实的寻求，都不过是自我投射，是自造幻觉，因而是不真实的。但这个过程是艰难的，它意味着头脑不得不时刻觉察内在发生的一切。要来到这一步，从始至终不可以评判或辩护 — 不是说这是终点。 终点并不存在，因为某个非凡的东西仍然在继续。没有承诺。你要去试验，去探究你自己，一层一层深入下去，把那个中心的所有层面都解开，你可以做得很快或者慢腾腾地来。观察头脑的运作过程，观察它怎样依赖词语，观察词语怎样刺激记忆或恢复僵死的经验，给它注入活力，这是相当有意思的。在那个过程中，头脑不是活在未来，就是活在过去。因此不管是对神经学，还是对心理学，词语都意义重大。要了解这些，请不要只听我说或者读本书就算了。他人和书籍都无法让你真正学到。你从书上学到或找到的东西都是不真实的。但你可以体验它，你可以在行动中观察你自己，在思考中观察你自己，看看你是怎样思考的，你是怎样快速地命名心中出现的感觉 — 对这整个过程的观察，就把头脑从那个中心解脱了出来。那时，头脑安安静静，可以迎接永恒之物。 参阅资料 节选自 《The First And Last Freedom》 ","date":"2024-05-03","objectID":"/2024-05-03-nameless/:0:0","tags":["Time"],"title":"无名，天地之始","uri":"/2024-05-03-nameless/"},{"categories":["Thinking"],"content":" 没有任何体制、修炼方法或“如何”可以带来解脱，只有观察才是真正的解脱行动。你必须去观察，但不是透过别人的眼睛。 — 克里希那穆提 你基于对经验的记忆、基于反应发展出内在的信念、内在的原则，借以在生活的运动中指导自己。 所以信念要么属于过去，要么属于未来。也就是说，当存在需求时，欲望制造出未来；而当你现在根据已有的经验来指导自己时，那标准是属于过去的，它已经死去。所以我们发展出对现在的抗拒，并称之为意志。 而在我看来，只有缺乏理解时，才会存在意志。我们为什么需要意志？当我理解经验并充分活在其中时，我不需要与之斗争，我不需要抗拒它。当我完全理解了经验，就不再有仿效和调整的想法，或者想要抗拒它的愿望。我完全理解了它，因此从它的重负下解脱出来。 ","date":"2024-04-21","objectID":"/2024-04-21-awareness/:0:0","tags":["Time"],"title":"看到任何事实时，都没有“我”","uri":"/2024-04-21-awareness/"},{"categories":["Thinking"],"content":"不生不灭 问：我想知道你说的“觉察”是什么意思，因为你经常说，“觉察”是你的教诲真正的核心。 我曾尝试通过听你的演讲和读你的书，来理解这点，但是我似乎并没有走多远。我知道这不是一种练习，而且我也明白你为什么如此强调否定任何形式的练习、训练、体系、戒律以及例行程序。我看到了这一点的重要性，因为否则事情就会变得机械，最后心智就变得迟钝和愚蠢。 如果可以的话，我想和你探讨一下，“觉察”到底意味着什么，并把这个问题深究到底。你似乎赋予了这个词某种特别的深刻的含义，但是对我来说，我们似乎一直都能觉察到发生着什么事情。我生气的时候我知道，伤心的时候我知道，开心的时候我也知道。 克：我想知道，我们是否真的觉察到了愤怒、悲伤和快乐？还是我们在它们都结束了的时候才觉察到这些事情？ 让我们这样开始，就好像关于觉察我们一无所知，从头开始。我们不要做任何武断或者巧妙的断言，而是一起来探讨这个问题，如果你真的愿意非常深入地探索的话，那这个问题将揭示一种心智也许从未触及的非凡状态，一种肤浅的觉知从未触及的境界。 我们先从浅层的觉知出发，一路走下去。我们用我们的眼睛看，我们用感官来感知我们周围的东西——花的颜色，花上飞着的蜂鸟，加州的阳光，有着不同质地和细微之处以及不同深度和高度的千万种天籁之音，树影以及树的本身。 从我们自己的身体我们也能有相同的感觉，身体是这些不同的各种浅层感官觉知的工具。如果这些觉知保持在浅层，那么就完全不会产生困扰。 那朵花，那朵紫罗兰，那朵玫瑰，就在那儿，对它们来说，仅此而已。没有偏好，没有比较，没有喜欢或不喜欢，只有我们面前的那样东西，而不涉及任何心理活动。 所有这些浅层的感官觉知或者说觉察都清楚了吗？通过所有的现代科技仪器，这种觉知可以扩展到繁星，扩展到深海，扩展到科学观测的最前沿。 问：是的，我想我明白这点。 克：于是我们看到了那朵玫瑰，整个宇宙和其中的人们，你自己的妻子，如果你有的话，星星，大海，山脉，微生物，原子，中子，这间屋子，门，它们都真实地存在着。 现在，开始下一步；你对这些东西有什么想法，或者对它们有什么感觉，这是你对它们的心理反应。而我们把这叫做思想或者感情。所以说，浅层的觉知是非常简单的事情：门在那儿。 但是，对门的描述不是那门本身，当你将情感注入那描述时，你就看不到那门了。这描述可以是一句话，或者一篇科学论文，或者一种强烈的情感反应；这些都不是那门本身。 从一开始就要清楚这点，这非常重要。如果我们不清楚这点，我们就会越来越困惑。描述从来都不是所描述之物。尽管我们现在也是在进行描述，我们不得不这么做，但是我们所描述的事情，并不是对它的描述，所以在我们的谈话中请务必把这一点牢记心中。永远不要把语言和语言所描述之物混为一谈。 语言从来都不是那真实的东西本身，而我们却很容易被语言带走，尤其是当我们下一步要谈到觉察的时候，我们很容易把觉察变得个人化，透过这个词我们变得情绪化。 那么有了对树、鸟和门的浅层觉知，然后对它们产生反应，也就是思想、感觉和情感。现在，当我们觉察到这些反应，我们可以把它称为第二深度的觉察。有对那玫瑰的觉察，还觉察到对玫瑰的反应。我们经常觉察不到对玫瑰的反应。 实际上看到反应的觉察和看到玫瑰的觉察是同一个觉察。这是同一个运动，觉察有内外之别的说法是错误的。当对树产生视觉感知而没有涉及心理活动时，这里的关系就没有分裂。但是当对树产生心理反应时，那反应就是局限的反应，那反应来源于过去的记忆、过去的经验，这反应就变成关系中的分裂。 在这反应中，就诞生了我们关系中所谓的“我”和“非我”。你就是如此把自己置入与世界的关系中的。这就是你如何制造出了个体和团体。世界再也不是如实地被看到，而是，与记忆组成的“我”形成了各种关系，从这关系中去看这个世界。 这种分裂，就变成了生活，滋养壮大了我们称为心理存在的各种事情，从这里就产生了所有的矛盾和分别。你很清楚你已经看到这点了吗？当对那棵树有觉察的时候，是没有评判的。但是如果对那棵树有了心理反应，当那棵树被判定为喜欢还是不喜欢，那么在这觉察中就发生了分裂，分成了“我”和“非我”，“我”不同于所观之物。 这个“我”就是关系中来自过去的记忆和经验的反应。现在，能不能觉察、观察那棵树，而不带有任何评判？能不能不带有任何评判地观察那反应和回应？这样我们就消除了分裂的根源，“我”和“非我”的根源，观察那棵树的同时也观察我们自己。 问：我正努力跟上你。我们来看看我是不是理解对了。有对树的觉察，这点我理解。然后产生了对树的心理反应，这点我也理解。心理反应来源于过去的记忆和过去的经验，是喜欢和不喜欢，这就产生了树和“我”之间的分裂。是的，我想我都懂了。 克：这点就像那树本身一样清楚呢，还是只是描述的很清楚？请记得，正如我们已经说过的，被描述之物并非描述。你明白的是什么，是事实本身还是对它的描述？ 问：我想是事实本身。 克：那么就没有了那个看到这个事实并对它进行描述的“我”。看到任何事实时，都没有“我”。 要么有“我”，要么有觉察，不可能两者同时都在。“我”就是无觉察。“我”无法看清，也无法觉察。 问：到这里我能停一下吗？我想我对此有所感觉，但是我必须完全领会吸收这一点。我可以明天再来吗？ 问：我想我真的已经理解了，从非语言层面上理解了你昨天说的话。有对树的觉知，有对树的局限的反应，这局限的反应就是冲突，是出自过去的记忆和经验的行为，比如喜欢和不喜欢，这是偏见。我也明白了，这偏见的反应催生了我们所谓的“我”或者审查官。我清楚地看到，“我”，“自我”，存在于所有的关系中。那么，有没有一个“我”存在于关系之外？ 克：我们已经看清我们的反应是多么严重地受限了。当你问有没有一个“我”存在于关系之外，只要没办法从这些局限的反应中解脱，那么它就变成了一个思想性的问题。你看到这点了吗？ 所以我们首要的问题，不是有没有那样一个“我”，在局限的反应之外。而应该是，包含了我们所有感情的心智能否从这过去的局限中解脱出来？ 过去就是“我”。活在现在这一刻就不会有“我”的存在。只要心智还在过去中运作，就会有“我”，而心智就是这过去，心智就是这个“我”。你不能说，心智是存在着的，过去是存在的着的，不管是几天前的过去，还是一万年前的过去。 所以我们要问：心智能把自己从昨天解脱出来吗？现在这里涉及到几件事情，是不是？首先，有浅层的觉知。然后是对局限的反应的觉察。然后是意识到心智就是过去，心智就是这局限的反应。然后问题是，心智能否把自己从过去中解脱出来。这一切都是一个整体的觉察行动，因为其中没有结论。当我们说心智就是过去，这种认识不是一个文字结论，而是对事实的真实觉知。法语里有个词表达这样一种对事实的觉知，他们把它叫做“证实”。 当我们问，心智能否从过去中解脱，那么这个问题是不是那个审查官，那个正是过去的“我”提出来的？ 问：心智能否从过去中解脱出来。 克：是谁在问这个问题？是作为许多冲突、记忆和经验的结果的那个存在体——是他在问吗？还是这个问题是它自己从对过去的觉察中产生的？如果是那个观察者在提出这个问题，那么他只是在试图从自己的事实中逃脱，因为，他说，我已经在痛苦中，在困境中，在悲伤中生活了这么久，我想要超越这不停的挣扎。 如果他是从这个动机问的这个问题，那么他的答案就会是在某种逃避中寻求庇护。他要么转身逃避事实，要么面对它。而语言和符号就是一种转身逃避。事实上，仅仅提出这个问题本身就已经是一种逃避行为了，不是吗？让我们来弄清楚这个问题是不是一种逃避行为。如果是逃避，那它就是一种噪音。如果没有观察者，那么就会有寂静，就会有对整个过去的全然否定。 问：在这里我迷失了。我要怎样在几秒钟内抹掉过去？ 克：我们讨论的是觉察，让我们把这点记在心中。我们在一起讨论觉察这个问题。有树，以及对树局限的反应，也就是关系中的“我”，而“我”就是冲突的最核心。 那么，是这个“我”在问这个问题吗？——我们说过，这个“我”就是过去构造出来的。如果这个问题不是从过去的构造中问出的，如果问题不是“我”问出的，那么就没有了过去的构造。当那构造在问出这个问题时，它就是在和它本身这个事实的关系中运作，它把自己吓坏了，想要采取行动逃开自己。当那构造不再问出这个问题时，它就没有在和自己的关系中运作。 再重申一下：有树，有语言，有对树的反应，也就是来自于过去的审查官，或者“我”；然后就有了这个问题：我能从这一切混乱和痛苦中逃脱吗？如果是这个“我”在问这个问题，那它就是在无休止地延续自己。 现在，觉察到这点，它就不会再问那个问题了！觉察，看到其中的所有涵义，就不会再问这个问题了。它根本不会问这个问题，因为它看到了其中的陷阱。 现在，你是不是看到了所有这些觉察都是浅层的？它就和看到树的觉察是一样的。 问：有没有其他类型的觉察？觉察有没有其他的境界？ 克：我们又得小心点，我们得非常清楚我们并不是出于任何动机来问这个问题。如果有动机，我们就又落入局限的反应这个陷阱里去了。当观察者完全安静的时候，不是制造出的安静，那就必然会有一种不同品质的觉察产生。 问：没有观察者的情况下，会有怎样的行动产生——怎样的问题或者行动？ 克：再问你一次，你是从河的此岸问出这个问题，还是从彼岸问的？如果你在彼岸，你不会问这个问题；如果你在彼岸，你就会从彼岸行动。所以对此岸有一种觉察，连同此岸的一切结构，它的本质，它所有的陷阱，而试图逃离陷阱就会落入另一个陷阱。这一切都是多么致命地无聊乏味啊！觉察已经展示给我们那陷阱的本质，进而把所有陷阱都否定掉；所以心智现在是清空的。清掉了“我”和那陷阱。 这心智就具有了一种不同的品质，一种不同境界的觉察。这种觉察并不知道它在觉察。 问：我的天，这太难了。你说的话似乎是真的，听","date":"2024-04-21","objectID":"/2024-04-21-awareness/:1:0","tags":["Time"],"title":"看到任何事实时，都没有“我”","uri":"/2024-04-21-awareness/"},{"categories":["Thinking"],"content":"不垢不净 问：当我听你演讲的时候，我似乎能理解你所说的内容，不只从字面上能理解，而且能在更深的层次上理解。我已经融入其中，我以我的整个存在充分领会了你所说的真相。我的听觉敏锐了，看到花朵、树木与那些积雪的山脉，就让我感觉我是它们的一部分。在这份觉察之中，我没有冲突，没有矛盾。好像我可以做任何事情，我不论做什么，都是正确的，都不会带来冲突与痛苦。 但是很不幸，这种状态无法持续。或许在听你演讲的时候，能持续一两个小时。在我离开演讲时，那状态似乎就全都蒸发掉了，我又回到了原来的样子。我努力地觉察自己，不断回想我在听你演讲时的状态，一直努力再进入并保持那种状态，于是这就变成了一种挣扎。你曾经说过，“觉知你的冲突，聆听你的冲突，认清你冲突的原因，你的冲突就是你自己。” 我知道自己的冲突、痛苦、悲伤和困惑，但是这份觉察并没有解决这些问题。相反地，这种觉知反而给它们赋予了生命力和持久性。你还谈到毫无选择地觉察，这又滋生了我内心的另一种冲突，因为我的心中充满了选择、决断及观点。我曾把这份觉察应用于自己的某个特殊习惯，可是那习惯并没有因此消失。当你觉察到某种冲突或压力时，那觉察同样会一直注意看它是不是已经消失了。这似乎总在提醒你那冲突的存在，这么一来你就永远无法摆脱它了。 克：觉察并不是对某件事情的专注。觉察是没有方向的观察，内心和外在所有的事物你都能观察到。你是觉知的，而你觉察到的东西又不会被助长或增强。觉察不是专注于某个特定的事物上。觉察不是意志力的行为，也不拣选任何觉察的对象，更不是通过分析来达到某种结果。 如果刻意把觉知集中在某个特定的对象上，譬如某个冲突，那么这时的觉察就变成了意志力的行为，也就是专注。在专注的时候，也就是把你全部的精力和思想都集中在自己所选择的区域中，不管是读书还是观察自己的愤怒，如此一来，在这种排外的行为中，你就增强了、滋养了自己所专注之物。 因此我们首先必须了解觉察的本质，我们得了解我们用“觉察”这个词时探讨的究竟是什么。要么你觉察的是某个特定的事物，要么觉察的是作为整体的一部分的某个特定的事物。特定的事物本身并没有什么意义，但是你如果能看到整体，特定事物就和整体产生了关系。只有在这种关系之中，特定的事物才有真正的意义，而同时又不会变得特别重要，不会被夸大。 因此真正的问题就在于：我们看到的是人生的整个过程，还是专注于其中的细节，从而错过了生命的整个领域？对整个领域的觉知，也能看到细节，但同时，还能了解细节与整体的关系。假设你发怒了，而你又很想息怒，然后你把所有的注意力集中在愤怒上，这么一来你不但看不清整体，反而助长了怒气。而愤怒是和整体关联在一起的。如果你把细节从整体中分离出来，细节就会自己滋生出问题。 问：你所谓的看到整体是什么意思？你说的这个整体，在这广泛的觉知中局部只是细节而已，这整体到底是什么东西？它是不是某种神秘的、不可思议的经验？如果是的话，我们就彻底迷失了。或者你也许指的是，存在的整个领域中有个局部是愤怒，如果只关心这一小部分，就会阻碍广泛的觉知？然而广泛的觉知又是什么？只有透过所有的细节，我才能看到整体。你所谓的整体到底是什么意思？你说的是心智的整个领域，存在的整个领域，我自己的全部，还是整个生命？你说的整体是什么意思，我要如何才能看到这点? 克：我指的是生命的整个领域：包括心智、爱与生命中的所有事物。 问：我怎么可能看得到所有的那些！我知道自己看到的都是局部，我所有的觉察也只限于特定的局部，这反而助长了局部的问题。 克：让我们换一种方式来探讨：你在觉知的时候，心智与情感是不是分开的？还是你的听觉、视觉、感觉和思想，不分割地一起并用？ 问：我不知道你说的是什么意思。 克：假设你听到一句话，你的心智告诉你，这是一句侮辱的话，你的感觉又告诉你，你不喜欢这句话，接着你的心智又插手进来，企图控制自己或为自己辩解，等等。当心智下了一个结论，感觉又一次占了主导。如此一来，一个事件便从你的存在的不同局部引发了一连串的连锁反应。你所听到的变得支离破碎，而你如果只专注于其中的一个碎片，你就错过了整个的聆听过程。 聆听可以是支离破碎的，也可以用你的整个存在完整地做到。所以我们所谓的觉察整体指的就是你的视觉、听觉、情感和心智同时并用，而不是各自分开去觉察。你付出全部的注意力。在全神贯注之下，那局部，比如愤怒，就有了不同的意义，因为它和很多其他的问题是相互关联的。 问：因此你所谓的看到整体，指的就是以你的整个存在去观察，这是质而不是量的问题，对不对？ 克：是的，完全正确。但是你真的能这样看到全部吗？还是只说说就算了？在观察自己的愤怒时，你的视觉、听觉、心智与情感，能同时并用吗？还是你看到的愤怒是和你其他的部分无关的，因而显得特别重要？当你赋予整体重要性时，并不表示你就忽略了局部。 问：但是局部的愤怒又会怎么样？ 克：你以你的整个存在去觉察愤怒。如果是这样，愤怒还会产生吗？粗心大意之下才会产生愤怒，全神贯注之中绝没有愤怒。以你的整个存在全神贯注就是看到整体，粗心大意则只能看到局部。觉察整体和觉察局部，以及两者之间的关系，就是整个问题。我们总是把局部和其他部分分开，然后再试图解决它。于是冲突就加深了，没有解决的出路。 问：你所谓的只看到局部的愤怒，你的意思是不是仅以生命的某一部分来观察愤怒？ 克：如果你仅以生命的某个片段来观察那个特定的问题，那个特定的问题和正在观察它的碎片之间的距离就会拉大，如此一来冲突便增强了。假如根本没有那种距离，就不会有冲突。 问：你是说，我能以我的整个存在去观察愤怒，愤怒和我之间就不会产生距离？ 克：一点也不错。你是真的做到了这点，还是只听听话语而已？实际发生了什么？这比你的问题重要多了。 问：你问我实际发生了什么。我只是想明白你的意思罢了。 克：你是在努力地弄明白我的意思，还是你看到了我们所讨论的真相？而这真相是独立于我而存在的。如果你真的能认清我们所讨论的真相，也就是了解你自己，那么你不但是自己的老师，同时也是自己的学生。这份自我了解，你无法从别人那里学到。 ","date":"2024-04-21","objectID":"/2024-04-21-awareness/:2:0","tags":["Time"],"title":"看到任何事实时，都没有“我”","uri":"/2024-04-21-awareness/"},{"categories":["Thinking"],"content":"不增不减 问：你使用各种不同的词语来表达觉知。有时候你用到“觉知”，也会用到“观察”、“看到”、“了解”和“觉察”。我想，你用所有这些词都是在表达同一件事情：清晰地，彻底地，完整地看到。 一个人能完整地看到任何事情吗？我们说的不是物理上的或者技术上的事情，而是在心理层面，你能完整地觉察或者了解任何事情吗？难道不是总有些东西隐藏着，所以你只能看到局部？如果你能相当深入地探讨这个问题，我将不胜感激。我觉得这是一个很重要的问题，因为它可能是了解生命中很多事情的线索。如果我能够完全了解我自己，那么也许我就能解决我所有的问题，并成为一个快乐而非凡的人。在我谈到这点的时候，我感觉非常兴奋，因为我有可能超越自己充满问题和痛苦的狭隘世界。所以，你说的觉知、看到，究竟是什么意思？一个人能够完全看清自己吗？ 克：我们总是偏颇地看事情。首先是因为我们漫不经心，其次是因为我们总是透过我们关于所见事物形成的偏见，透过语言和心理意象去观察事物。所以我们从未完整地看到任何事物。即使客观地去观察自然，也变得十分费力。不带有意象地观察一朵花，不带着任何植物学知识——只是单纯地观察它——变得非常困难，因为我们的心智总是在游荡，漠不关心。即使心智感兴趣，它还是会带着某种欣赏之情和语言描述去观察这朵花，这似乎给了观察者一种他确实在观察的感觉。刻意地去看，根本就不是观察。 所以我们从未真正观察过花朵。我们透过意象观察它。或许去看某个并没有深深触动我们的东西，会相当容易，而当我们去看电影，会有那么一刻我们被某种东西深深打动，但是我们很快就忘记了。而不带有意象地观察我们自己——这个意象就是过去，是我们积累的经验和知识——这样的观察鲜有发生。我们对自己抱有意象。我们觉得我们自己应该这样，不应该那样。 我们已经为自己建立了先入为主的观念，再透过这些观念去观察我们自己。我们认为自己是高尚的或者卑微的，而如实地看到我们自己，要么会让我们沮丧，要么会吓坏我们。所以我们不能完整地观察自己，而在那完整的观察中，是有可能从我们所观察到的情形中解脱的。我们的觉知，不仅仅是通过眼睛，通过感官进行的，而且要用到心智，而心智显然是严重受限的。 所以智力上的理解，只是片面的觉知，而智力上的觉知似乎已经让我们大多数人都心满意足了，我们觉得自己明白了。支离破碎的了解是最危险和最具破坏性的东西。而这正是全世界都在发生着的事情。 政客，牧师，商人，技术人员；还有艺术家——他们所有人都只是在片面地观察。所以他们是真正非常具有破坏性的人们。因为他们在世界上占有非常重要的地位，他们片面的觉知就变成了公认的规则，而人类也就深陷其中了。我们每个人都同时是牧师，政客，商人，艺术家，以及许多其他支离破碎的实体。我们每个人都是。 问：我清楚地看到了这点。当然，我用“看到”这个词，也是从智识上讲的。 克：如果你完全看到了这一点，不是从智识上、字面上或者情感上，那么你就会行动，并开始过一种完全不同的生活。当你看到一个危险的悬崖，或者面对一个危险的动物时，就没有片面的了解或者片面的行动；就会有全然的行动。 问：但是我们的生活中并不是每时每刻都面临这么凶险的危机。 克：我们确实始终一直面临着这样凶险的危机。你只是习惯了它们，或者对它们漠不关心了，或者你把它们留给别人去解决这些问题了；而这些别人一样的盲目和偏颇。 问：但是我要怎样才能始终都觉察到这些危机，而你又为什么说一直是有危机的？ 克：整个生命都在每个瞬间中。每个瞬间都是一项挑战。不恰当地应对这挑战就是生命中的危机。我们不想看到这些是危机，我们闭上眼睛逃避面对。所以我们变得更加盲目，危机就升级了。 问：但是我要怎样才能完整地觉知呢？我开始了解到我只是在片面地观察，而且明白了以完全的觉知来观察自己和世界的重要性，但是，我的内在有那么多事情在进行着，很难决定该观察些什么。我的心智就像一个装满了烦躁不安的猴子的大笼子。 克：如果你完整地观察一项活动，在那完整中，所有其他的活动就都包括在其中了。如果你彻底明白了一个问题，那么你就了解了人类的所有问题，因为它们都是相互关联的。所以问题是：一个人能否如此彻底地了解、觉察或者看到一个问题，在那对问题的了解中，他就明白了所有其他的一切？这个问题必须在发生时被看清，而不是之前或之后，不是作为记忆或者一个例子。 比如说，现在我们探讨愤怒或者恐惧，就没有意义；要做的事情是，在它们发生的时候观察它们。觉知是即刻发生的：你要么立即了解某件事情，要么什么都没明白：看到，听到，了解都是即刻发生的。而听和看是有持续性的。 问：我的问题还在继续。它在一段时间内都存在着。你说看到是即刻发生的，因而摆脱了时间。而是什么给嫉妒或者别的什么习惯或者问题带来了持续性呢？ 克：它们在继续，难道不是因为你没有敏锐地、以智慧和无选择的觉知去观察它们吗？你只是片面地观察，因而就让它们得以继续。此外，想要去除它们，是造成持续性的另一个症结。没能力解决某件事情，就让它成为了一个持续的问题，并赋予了它生命力。 问：但是我要怎样即刻看到事情的全貌？我要如何去了解它，它才再不会反复出现？ 克：你把重点放在再不出现上还是了解上？如果你把重点放在再不出现上，那就意味着你想要永远地从中逃脱，而这意味着制造出了另一个问题。所以我们只有一个问题，也就是要如何完全看清那个问题，从而从中解脱出来。觉知只能出自于寂静，一个喋喋不休的心智是无法觉知的。喋喋不休的心智也许想要除掉那问题，减轻它，逃避它，压抑它，或者寻找一个替代品，但是只有安静的心灵才能看清。 问：我要如何获得一颗安静的心灵？ 克：只有安静的心灵才能看清，你看不到这个真相。如何获得安静的心灵，这个问题不会被提出来。真相是，心智必须安静，看到这个真相，就把心智从喋喋不休中解脱了出来。觉知，也就是智慧，就开始运作了，而不是推断你为了看到而必须安静。推断也能够运作，但是那是片面的，破碎的运作。片面和整体之间没有关系；片面不能融入整体。因此，看到是最重要的。看到就是全神贯注，而只有漫不经心才会导致问题。 问：我要怎样才能一直全神贯注？那是不可能的！ 克：非常对，那是不可能的。但是，觉察到你的漫不经心，这点是最重要的，而不是如何一直全神贯注。因为贪婪才会提出这个问题，“我要怎样才能一直全神贯注？”一个人会在练习全神贯注中迷失。练习全神贯注就是漫不经心。你不能练习变得美丽，或者练习去爱。当恨止息时，就有了另一个，爱。只有当你对恨付出全部的注意力，当你在学习但是不再累积关于它的认识时，恨才会止息。很简单地开始。 问：如果听你说了之后我们没什么可练习的，那你的演讲还有什么意义？ 克：听到是最重要的，而不是你之后去练习些什么。倾听是即刻发生的行动。而练习会使问题持续下去。练习完全就是漫不经心。永远不要练习：你只能练习错误。学习永远都是新鲜的。 参阅资料 节选自 《The Urgency Of Change》 ","date":"2024-04-21","objectID":"/2024-04-21-awareness/:3:0","tags":["Time"],"title":"看到任何事实时，都没有“我”","uri":"/2024-04-21-awareness/"},{"categories":["Thinking"],"content":" 当一个困惑的心灵开始行动，它只会带来更多的困惑。 — 克里希那穆提 我们多数人都是情绪失调的。我们多数人都困惑、焦虑，甚至那些拥有房产、汽车等物品的富人也会有这样的问题。当我们不知道怎样解决这样的失调，它就会在我们的生理上发生反应，产生疾病，这是显而易见的。问题是：我们一定要请精神病医生来帮我们解决失调，重获健康吗？有没有可能让我们自己来发现如何解决失调，如何解除恐惧、焦虑和悲伤？ 如果我们已经失调，是什么原因让我们失调？什么是失调？我想要什么东西，但是我得不到，因此我就进入了这种状态。我想通过我的孩子，我的妻子，我的财产、地位、成功等等来实现，但是我却受到阻碍，这就意味着失调。我野心勃勃，但是其他人却把我推到一边，超了过去，我又一次陷入混乱和焦虑，于是就产生了生理反应。 现在，我们能从这一切的焦虑和困惑中解放出来吗？什么是困惑？你们理解吗？困惑只存在于事实和“我”对事实的看法之中：我对事实的观念，对事实的轻视，对事实的逃避，对事实的评估，等等。如果我能撇去外部的观念来观看事实，就不会有困惑。 比如，如果我看待这样的事实——有一条路是通往文图拉的——就不会有困惑。只有当我认为或坚持那条路是通往别处的，困惑才会产生。而这确实是我们多数人所处的状态。我们的观念、信念、欲望和野心如此强烈，我们被这些东西压得太重，以致我们无法去观看事实。 因此，当事实附带上了观念、判断、评价、野心等等，就产生了困惑。那么，身处困惑之中的我们能否不行动？诚然，任何源自困惑的行为都一定会引起更多的困惑，更多的焦虑，这一切都会在身体上，在神经系统上发生反应，进而产生疾病。 对困惑的人来说，对自己承认困惑，这需要的不是勇气，而是某种思想的清醒，认识的清醒。 我们多数人都不敢承认我们的困惑，所以为了走出困惑，我们就去选择追随领袖、导师和政客。当我们去选择什么来走出困惑的时候，这选择就一定是困惑的，而选择的领袖也因此一定是困惑的。 那么有没有可能觉察到我们的困惑，了解这困惑的原因，然后不做出行动？当一个困惑的心灵开始行动，它只会带来更多的困惑。但是一个觉察到自己的困惑并理解这困惑全过程的心灵，是不需要行动的，因为这种清楚就是它的行动本身。 我觉得这对多数人来说很难理解，因为我们非常习惯去行动或行事。但是如果一个人去观看行动，看到行动的结果，观察在这个世界上，在各个方向上正发生着什么政治事件，那么就会发现这一点显而易见——所谓的改革行为只不过带来了更多的困惑，更多的混乱，更多的改革。 所以，我们个人能不能觉察到我们自身的困惑，我们的焦虑，然后和它一起生活，理解它，而不去驱逐它，摆脱它，逃避它？只要我们还在摒弃它、责备它、逃离它，那么这责备和逃离就是困惑的过程。我不认为有哪位分析师能够解决这个问题。他也许暂时地帮助你顺服于某种社会模式，他将其称之为正常的存在。但是问题比那要深刻得多，而且除了你自己之外，没有人能够解决。你和我创造了社会，它是我们行动、思想和存在的结果。 只要我们还是单纯地试图去改良结果，而不去理解产生结果的主体，我们就会有更多的疾病，更多的混乱，更多的犯罪。理解自我会带来智慧和正确的行动。 对大部分人而言，爱代表着慰藉和安全感，一种使他在余生能继续享有这份满足感的保证。然后我这个人就出现了，并且提出了质疑：“这算是真正的爱吗？”同时还要求你向内检视自己。 但是你实在不想去看那个令人不安的真相，你宁愿和人讨论灵魂的问题或是政经方面的情势，不过如果你被逼到一角，不得不面对真相时，你会发现一向被你视为爱的东西根本就不是爱，不过是一种相互报偿、互相剥削的交易罢了。 我说“爱是没有明天，也没有昨天的”，或是“自我的中心点一旦消失，爱就出现了”。这仍然是我自己寻获的真相，对你而言是不具任何意义的。你可能引用我的话作为一种公式，事实上却没有什么实际的效用。 你必须亲自去看清真相，要达到这点，必须先从所有的赞同、反对、谴责或辩护之中解脱出来。然而，“看”实在是生活中最难的一件事，“听”也是一样。你心中的挂虑时常会令你盲目，即使是眼前的落日美景也视若无睹。 我们大部分人都已经失去和大自然的接触，文明逐渐集中在都市里，我们也逐渐变成了都市人。我们住在拥挤的公寓中，那狭窄的房间连天空都看不到，因此，我们已经跟自然的美感脱节了。你有没有注意到，真正好好看过日出、日落或湖面月色的人寥寥无几？ 人与大自然脱节之后，自然就会致力于智性方面的发展，我们阅读各种书籍，参观各种博物馆，欣赏音乐会，在家里看电视，做各种不同的消遣。我们还喜欢引用他人的观点，高谈阔论有关艺术的事。为什么我们那么重视艺术？是为了逃避，还是为了激发灵感？如果你直接和自然接触，欣赏鸟儿展翅高飞，观察天空的变幻之美，看着山坡上移动的阴影或是一张美丽的脸庞，你还会想去美术馆观赏那些图画吗？ 也许正因为你不知道该如何去看自己的种种，你才会求助于某些迷幻药来刺激你看得更清楚一点。能够透视自己的内心，而不只是外在的人事，实在是最难的事了。 我们声称自己看到了一棵树、一朵花或一个人，然而我们是真的看到它们了吗？还是我们只看到由那些词汇所制造出来的意象罢了？换句话说，当你注视一棵树或夜晚云彩的变化时，你是否真真实实地看到了它们？不只是眼睛和头脑看到了，而是完整彻底地看到了一切。 你是否曾经不假任何联想或既定的知识，好好凝视过一个客体，譬如一棵树？你和树之间是否可能没有任何偏见、判断和字眼——这些阻碍是你看到它之所以为它的屏障？ 试试看，身临其境、全神贯注地观察一棵树会是一种什么经验？你会发现在那份强烈的感受之下 ，观察者就消失了，只剩下了专注本身。心不在焉时才会有观察者与被观察者的区别。在专注的那一刹那，思想、方式或记忆都毫无藏身之处。如果你的心能注视一棵树、天上的星星或闪耀的河水直到完全忘我的地步，你就能体会什么是美了。在我们真正看见的那一刹那，我们就浸淫在爱中了。 平常我们都是从比较或人为的方法来认识美，这表示我们总是将美归因于某种东西。我看到一栋我认为很美的建筑物，当时我是根据我对建筑的知识，加上和其他建筑物的比较之下，才认为它美。但是我现在就要问自己了：有没有一种不需要客体的美？只要那个能够检查、经验和思考的观察者存在，美就不存在了，因为那份美已经变成了观察者所注视和评鉴的外在事物了。只有使观察者的自我消失，没有客体的美才会出现，那需要多么深的觉察及探索的工夫啊！ 美存在于完全忘却观者与所观之物的境界中，惟有彻底的苦修才能达到这种忘我的地步。我所指的并不是神职人员的严厉、制裁、戒律以及服从等的苦修，也不是指衣着、观念、饮食和行为上的刻苦，我所说的苦修是那种完全单纯而谦虚的心境，其中没有任何对于成就的追求欲望，也没有攀缘的阶梯，只有第一步，而这第一步实在是永恒的一步。 假设你独自散步或与别人并肩而行，你们的交谈这时已经告一段落，在自然的怀抱中，没有狗吠，也没有车声，连鸟儿振翅的声音都听不见，你完全沉静下来，周遭的一切也都沉寂无声。在这种安宁的状态下，观察者不再把所见的景色诠释为思想，当观者与所观之物都归于寂静时，那出奇的美就出现了。既无自然界，也无观察者，那是一种完全的、彻底的空寂，这空寂就是美。 如果你真的处于爱之中，还有观察的主体存在吗？只有当爱变成欲望和快感时，观察者才出现。如果爱不跟欲望、快感相连，就会变得极为强烈，那也就是美，它每天都会示现出崭新的面貌。所以我才说，美是既无昨日，也没有明天的。我们心中不再存有先入为主的观念或意象，才能直触生活。 我们所有的人际关系通常都建立在思想塑造的印象之上。如果你对我早有某种印象，我对你也是如此，那么我们自然无法看到真正的对方，所以我们的人际关系才会出毛病。我说我认识你，这表示我只认识昨天的你，对目前真实的你其实是一无所知的。 我所认识的只是我对你的印象罢了，其中还包括了你以前对我的夸奖或侮辱。你对我的各种反应，累积成为印象，贮存于我的记忆中，而你对我的印象也是如此形成的。就是这种造成人际关系的印象，阻碍了我们真实的接触。我们必须对真实的人际关系有所认识，才能同心协力，这种合作是无法通过形象、象征和观念上的意识而达成的。也只有当我们了解了真实的关系以后，爱才可能产生。如果我们老是凭着旧有的印象相待，爱就被舍弃了。 因此，我们必须在日常生活中确实认识自己是如何形成对妻子、丈夫、邻居、孩子、国家、领袖、政客以及上帝的印象，然后你就会发现，你所拥有的只是一大堆意象罢了。这些意象使你与所观察的对象之间产生了空隙，冲突便随着这个空隙而滋生。我们现在要一块儿探索的就是如何从我们所制造的空隙中解脱出来，我不是指身外的空隙，而是那个在人心内破坏真实关系的空隙。 现在你赋予这个问题的专注力，正是你解决这个问题的能量。如果你能全神贯注于一件事情，观察者就消失了，只剩下了那股专注力，也就是最高形式的智慧。这种心智状态显然是完全寂静的，而这种寂静只有在完全专注时才会出现，它不是靠修炼得来的。这种既无观者也无被观者的彻底寂静，就是最高形式的道心。这不是言辞所能描绘的，因为一化为文字，就脱离了事实本身。你必须亲自去经历、寻获它。 所有的问题都是息息相关的，如果你能彻底解决一个问题——不论是哪种问题——你就能轻而易举地面对其他问题，并且加以解决。我们已经看出，问题都来自时间，换句话说，我们没有全神贯注。 因此，我们不但需要觉察问题的本质和结构，彻底地观察它，还要在它一出现时，立刻加以解决，使它无法在内心生根。如果你任凭一个问题拖延到下个月、明天，甚至几分钟以后，它都会扭曲你的心境。 我们有没有可能不加扭曲，立刻面对一个问题，然后从中彻底解脱，而不留下任何残存的记忆？这些记忆就是我们时常把持的印象，我们不断用这些印象来处理那","date":"2024-03-31","objectID":"/2024-03-31-confusion/:0:0","tags":["Time"],"title":"虚室生白","uri":"/2024-03-31-confusion/"},{"categories":["Thinking"],"content":"关于 INFJ 在如何参与剧本，大概有以下几种方式。 ","date":"2024-03-09","objectID":"/2024-03-09-infj-2/:0:0","tags":["Maya"],"title":"人格剧本","uri":"/2024-03-09-infj-2/"},{"categories":["Thinking"],"content":"探索与改进剧本 代表人物： 维特根斯坦：“哲学所能做的一切就是破除偶像。” 代表作：《逻辑哲学论》 代表人物： 尼尔斯.波尔：“多么美妙，我们碰到了一个悖论。现在我们有希望取得进展。” 代表作：哥本哈根诠释 ","date":"2024-03-09","objectID":"/2024-03-09-infj-2/:1:0","tags":["Maya"],"title":"人格剧本","uri":"/2024-03-09-infj-2/"},{"categories":["Thinking"],"content":"探索与改进角色 代表人物： 陀思妥耶夫斯基：“人们称我为心理学家，不，我是高度意义上的现实主义者，我的意思是，我描绘人的内心的全部深度。” 代表作：《罪与罚》 代表人物： 但丁：“你生来不应像畜生一样生活，而是要追随美德和知识。” 代表作：《神曲》 ","date":"2024-03-09","objectID":"/2024-03-09-infj-2/:2:0","tags":["Maya"],"title":"人格剧本","uri":"/2024-03-09-infj-2/"},{"categories":["Thinking"],"content":"从剧本中解脱 代表人物： 卡尔.荣格：“一个人毕其一生的努力，就是在整合他自童年时代起就已形成的性格。” 代表作：分析心理学 代表人物： 柏拉图：“我说过有两样真实存在的东西，一个统治着理智的秩序和区域，另一个统治着眼球的世界。” 代表作：《理想国》 ","date":"2024-03-09","objectID":"/2024-03-09-infj-2/:3:0","tags":["Maya"],"title":"人格剧本","uri":"/2024-03-09-infj-2/"},{"categories":["Thinking"],"content":"从角色中解脱 代表人物： 释迦牟尼：“我只解释了苦、苦的生起、苦的止息和灭苦之道。” 代表人物： 克里希那穆提：“这个新的法门就是要将时间停止！” ","date":"2024-03-09","objectID":"/2024-03-09-infj-2/:4:0","tags":["Maya"],"title":"人格剧本","uri":"/2024-03-09-infj-2/"},{"categories":["Thinking"],"content":"总结 这类人格对人类的贡献主要集中在精神认知层面。 他们关注剧本与角色，沉迷于抽象思考与感受，却忽略了对道具的关注。。。 参阅资料 idrlabs.com ","date":"2024-03-09","objectID":"/2024-03-09-infj-2/:5:0","tags":["Maya"],"title":"人格剧本","uri":"/2024-03-09-infj-2/"},{"categories":["Thinking"],"content":" 你和我就是问题所在，而不是世界，因为世界就是我们自身的投射。 — 克里希那穆提 有这样一个故事: 一位年轻记者在机场发现了一位僧人，并决定采访他。他问僧人: “先生，您认为世界上最大的问题是什么? 是全球变暖吗？世界饥饿？腐败？” 僧人微笑着回答: “我先问你一件事。你是谁？” “我是一名记者，” 年轻人回答道。 “不，那是你的职业，” 僧人说，“你是谁？” “我是约翰·史密斯，” 记者回答。 “不，这是你的名字，” 僧人说，“你是谁？” “我……是一个人”，年轻人犹豫道。 “不，那是你的物种，” 僧人说，“你是谁？” 这种情况持续了一段时间，直到最后，记者屈服并说: “好吧，好吧……看来我不知道自己是谁！” 然后，僧人对他说: “这就是世界上最大的问题。” 世界的问题太大，太复杂，要了解并进而解决它们，必须采用非常简单直接的方式。简单，直接，不依赖外部的环境，也不依赖我们特定的偏见和情绪。 我已经指出过，召开大会、描绘蓝图或用新领袖取代旧的，如此等等，都是无法找到解决办法的。显然，解决的办法就在制造问题的人身上，就在制造祸端、引起人与人之间的仇恨以及深深误解的人身上。制造这些祸端的，制造这些问题的，就是个人，就是你和我，而不是我们以为的世界。世界就是你和他人的关系。 世界不是某个独立于你我的东西；世界，社会，就是我们所建构或试图建构的人与人之间的关系。 所以，你和我就是问题所在，而不是世界，因为世界就是我们自身的投射。要了解世界，必须了解我们自己。世界不是独立于我们存在的；我们就是世界，而我们的问题就是世界的问题。 这一点怎么强调都不为过，因为我们的心智太迟钝了，我们以为世界的问题不关我们的事，我们以为那些问题必须由联合国来解决，或者必须通过新领袖取代旧领袖来解决。这样思考的心智是非常迟钝的，因为是我们造成了这个世界上惊人的苦难和混乱，造成了这永远迫在眉睫的战争。 要转变世界，我们必须从自身开始；从自身开始的关键在于意图。意图必须是了解我们自己，而不是要别人去转变他们自己，也不是通过左派或右派的革命作一些改良。要认识到这是我们的责任，是你的责任、我的责任，了解这一点非常重要。 因为，不管我们所生活的世界有多小，如果我们能转变自己，能在日常生活中彻底转变观念，也许我们就能影响整个世界，在大范围内影响我们与他人的关系。 我说过，我们要设法弄清楚了解自我的过程，那并不是一个孤立的过程。了解自我不是要你遗世独立，因为孤立生活是不可能的。生活就是产生关系，并没有孤立生活这回事。正是因为缺乏正确的关系才导致了冲突、痛苦和争端。 不管我们的世界多么小，如果我们能在那个狭小的世界中转变我们的关系，它就会像波浪一样一直向外扩展。我认为看到这一点是非常重要的，即世界就是我们的关系，不管多么狭小；如果我们能在那里产生转变，不是一种表面的变化而是根本的转变，那么我们就开始积极转变世界了。 真正的革命不以任何模式为准则，不管是左派的模式还是右派的模式，它是一种价值革命，一种从感官价值到非感官价值的革命，一种不是由环境影响形成的价值革命。 要找到这些真正的价值，这些能带来彻底的革命、转变或新生的价值，就必须了解我们自己。自我认识是智慧的开端，因此也是转变或新生的开端。要了解自己，就必须有了解的意愿 — 那正是我们的困难所在。虽然大多数人都心怀不满，但我们却期望突然的改变，我们的不满被轻易疏导，只为达到某个目标；心怀不满时，我们不是去找份别的工作，就是干脆屈服于环境。 不满没有点燃我们内心的火焰，促使我们质疑生活、质疑生存的整个过程，它被疏导了，我们变得庸碌无为，丧失了那份动力、那份强度去弄清楚生存的全部意义。 因此，亲自来发现这些事情是很重要的，因为对自我的认识无法由别人恩赐，也无法从任何书本中找到。我们必须去发现，要发现，就必须有这个意愿，必须去探究，去质疑。只要那个深度探究、弄个水落石出的意愿不强或根本没有，只是嘴上说说或偶尔心血来潮要发现自己，那是没有什么意义的。 因此，世界的转变要由自我的转变来实现。因为自我是整个人类生活的一部分，是它的产物。要转变自我，就必须认识自我。不认识你的真实状况，就没有正确思维的基础；不认识你自己，就不可能有转变。 你必须如实认识自我，而不是认识你希望成为的样子，那只是一个理想，是虚构的，不真实的。能够被转变的就是真实的那部分，而不是你希望的那部分。如实认识自我，需要一颗极其机敏的心，因为实情在不断转变、变化，要快速跟上它，头脑必须不被任何教条或信仰所束缚，不被任何的行动模式所限制。如果你要追踪任何东西，受束缚可没好处。 要认识你自己，心必须警觉、敏锐，从所有的信仰和理想主义中解脱出来。因为信仰和理想只能带给你一些色彩，却妨碍了真正的理解。如果你想认识真实的自己，你不能想象或信仰某些你不具备的东西。 如果我贪婪、嫉妒、暴力，只是抱有非暴力、不贪婪的理想，那并没有什么价值。然而，要认识到自己贪婪或暴力，要认识并了解这一点，需要极强的洞察力，不是吗？那需要诚实，需要清晰的思维。但追求某个脱离实际的理想，是一种逃避；它会阻碍你的发现，阻碍你从你的实际出发直接行动。 了解自我的真相，不管是什么样的真相 — 或丑或美，或邪恶或不端，了解自我的真相，不作扭曲，就是美德的开端。美德是必要的，因为它带来自由。只有在美德中你才能发现，才能生活 — 而不是在美德的培养中，培养美德只是带来声名，而不是理解和自由。 具有美德和变得具有美德是不一样的。具有美德源于对真相的了解，而变得具有美德是在拖延，是在用你想要的状态掩盖你真实的状态。 因此，在变得具有美德的过程中，你在逃避从实际出发的直接行动。这个通过培养理想逃避真相的过程，被认为是具有美德的；但如果直接、仔细地观察，你会明白根本不是那回事。那只是一种不肯直面真相的拖延。美德不是去变成跟实际相反的样子。美德是了解实际的状态，并因而从实际的状态中解脱出来。 在一个急速瓦解的社会中，美德是必要的。要创建一个新的世界、一个新的结构，脱离老旧的那一切，必须有发现的自由，而要自由，必须具有美德，因为没有美德就没有自由。一个不道德的人，努力想变得具有美德，他能了解美德吗？不道德的人永远无法自由，因此他永远弄不清楚真相是什么。 我们只能在了解实情的过程中发现真相；要了解实情，就必须有自由，必须摆脱对实际状况的恐惧。要了解那个过程，就必须有认识实情、追踪每一个思想、情感和行为的意愿；而了解实情是相当困难的，因为实情从来不是静止的、停滞的，它始终在变动。 实情是你真实的状况，而不是你希望的状况；它不是理想，因为理想是虚构的；它是你每时每刻实际的行为、思想和感情。实情就是事实，要了解事实需要觉察力，需要一颗非常警觉、机敏的心。但如果我们开始谴责实情，开始批判或抗拒它，就无法了解它的变动。 如果我想要了解某个人，我不能责备他；我必须观察他，研究他。我必须爱我所研究的这个东西。如果你想了解一个孩子，你必须爱他，绝不能责备他。你要跟他一起玩，观察他的动作、他的脾气、他的行为方式；但如果你只是责备、抗拒或批评他，你对那个孩子就不会有了解。 同样的，要了解实情，我们必须观察每时每刻的所思、所感、所行。那就是事实。任何其他的行动，任何理想的、意识形态的行动，都不是事实；那只是个愿望，一个虚构的欲望 — 想要变成某个跟实际不一样的东西。 要了解实情，需要一颗不认同、不谴责的心，也就是说，需要一颗警觉而被动的心。 当我们真的想要了解什么的时候，我们的心就处于那种状态；如果了解的兴趣足够强，那种状态就会出现。如果你有兴趣了解实情，了解心的真实状态，你不必强迫，不必自律，不必控制；相反，你会有一种被动的警觉和留心。有兴趣、有意愿了解的时候，那种觉察的状态就会出现。 对自我的彻底了解，并不是由知识或经验的累积达成的，那不过是培养记忆罢了。 了解自我是每时每刻的事。如果我们只是累积关于自我的知识，那知识本身就会阻碍进一步的了解，因为累积的知识和经验变成了中心，思想通过这个中心聚焦、生成。 世界与我们以及我们的行为无二无别，因为正是我们的实际状况造成了世界的问题。大多数人的困难在于，我们没有直接认识自己，相反，我们寻求一个体系、一种方法、一种操作方式，指望它来解决人类的许多问题。 那么，存不存在认识自我的方法或体系呢？随便哪个聪明人、哲学家都能创建一个体系、一个方法；但遵循一个体系，显然只会产生一个由那个体系造成的结果，不是吗？如果我遵循某个特定的了解自我的方法，我就会得到那个体系必然产生的结果？但那个结果显然不是对自我的了解。 也就是说，我遵循一个了解自我的方法、体系、途径，照此模式塑造我的思想、我的行为；但遵循模式并不是了解自我。 因此，并不存在认识自我的方法。寻求方法，必然想到达某个结果 — 那就是我们全都想要的东西。我们追随权威 — 如果不是权威人士，就是权威的体系、权威的意识形态 — 因为我们想要一个令人满意的结果，一个能带给我们安全的结果。 实际上我们并不想了解自己，并不想了解我们的冲动和反应、了解思维的整个过程、了解意识以及潜意识。我们宁可去追求一个体系，一个保证会给我们一个结果的体系。然而，对体系的追求，始终是我们渴望安全、渴望确定的产物，而结果显然不会是对自我的了解。如果要遵循一个方法，就必须有一个权威 — 导师、古鲁、救世主、大师 — 那个提供给我们想要的保障的人；显然那并不是认识自我之道。 权威妨碍对自我的了解，不是吗？在权威、导师的庇护下，你也许会有暂时的安全感、幸福感，但那并不是对自我的整个过程的了解。权威在本质上就是充分觉察自我的妨碍，因此最终破坏了自由；而只有在自由中，才存在创造。只有通过认识自我，才有创造的可能。 我们大多","date":"2024-01-01","objectID":"/2024-01-01-self-knowledge/:0:0","tags":["Advaita"],"title":"认识自我","uri":"/2024-01-01-self-knowledge/"},{"categories":["Theory"],"content":" “许多独立的并且很有说服力的论点，都表明时空这个概念本身并不是基础性的。时空注定要消亡。在物理定律的实际底层描述中，根本不存在时空这样的东西。这是非常令人震惊的，因为物理学被认为是描述在空间和时间中发生的事情。因此，如果没有时空，就不清楚物理学讲的什么。” — 尼马·阿尔卡尼-哈米德，康奈尔大学信使讲座，2016 “那里没有勺子。” — 勺子男孩，《黑客帝国》 ","date":"2023-12-19","objectID":"/2023-12-19-itp/:0:0","tags":["Time"],"title":"虚拟 — 膨胀出全息世界","uri":"/2023-12-19-itp/"},{"categories":["Theory"],"content":"时空和物体感知的新视角 科学可以揭开奇异事物的神秘面纱。这种天赋带来了新技术——从手机到卫星。用亚瑟·克拉克的话说，这些技术看起来“和魔术没什么两样”。 科学也可以让平凡显得神秘。它可以突然把我们扔进好奇的兔子洞。例如，我看到一把勺子现在就放在那边的桌子上。这是如此稀松平常，以至于我根本不想花时间去思考它。但是就在这里，在完全出乎我预料的地方，科学注入了深奥的神秘：我们仍然不理解“现在”和“那边”。也就是说，我们不理解时间和空间——长度、宽度和深度——这些我们认为理所当然的东西，它们交织在我们日常感知的最根本结构中，我们认为它们是真实可靠的物理实在指南。 现在许多物理学家告诉我们，我们知道的是，时空注定消亡。空间和时间在我们的日常感知中占据中心地位。但是，即使是爱因斯坦精心构造的时空，也不能真正描述自然的基本定律。时空，以及它所包含的所有物体，在那个真实的描述中将会消失。例如，诺贝尔奖得主大卫·格罗斯注意到：“每个研究弦理论的人都相信……时空注定消亡。但我们不知道它会被什么取代。” 菲尔兹奖得主爱德华·威滕也认为时空可能“注定消亡”。普林斯顿高等研究院的内森·塞伯格说：“我几乎可以肯定，时间和空间都是错觉。这些原始概念都将被更复杂的东西取代。” 这令人深感不安。正如这一章开头引用的阿尔卡尼-哈米德的解释，“物理学被认为是描述在空间和时间中发生的事情。因此，如果没有时空，就不清楚物理学讲的什么。”对物理学家来说，这是个好消息。承认一个理论的失败，无论这个理论多么珍贵，都是一种进步。对于具有创造性的理论家来说，用更基本的东西取代时空理论是令人兴奋的挑战，很有可能改变我们对世界的看法——也许这是我们第一次有机会搞清楚，物理学到底讲的什么。 我在这一章的目标并不那么雄心勃勃。对时空注定消亡的认识以及随之而来的东西，还没有为目前的视觉理论提供启示。这些理论一般都假设空间和时间中的物体是物理实在的基础，视觉一般能复现这些预先存在的物体的真实属性。对于哪些真实属性被呈现，以及呈现是如何生成的，目前的感知理论普遍都还不能达成一致，但它们都假定物理学家认为错误的事情是正确的——时空中的物体是基础性的。 我将简要讨论感知的标准理论，然后给出一个关于我们对时空和物体感知的新视角。这个新的视角是受感知界面理论（ITP）和全息原理启发——在第 6 章中讨论的关键发现，即一个空间区域中可以存储的数据量取决于该区域外围的面积，而不是体积。这种关于时空和物体的新视角源于这样一个想法，即我们的感知已进化到编码适应度收益，并引导适应性行为。时空和物体的用途正在于此。但是怎么做到的呢？我认为部分是通过数据压缩和适应性信息纠错。 ","date":"2023-12-19","objectID":"/2023-12-19-itp/:0:1","tags":["Time"],"title":"虚拟 — 膨胀出全息世界","uri":"/2023-12-19-itp/"},{"categories":["Theory"],"content":"数据压缩和适应性信息纠错 先看看数据压缩。适应度收益函数可能很复杂，而且有许多适应度收益函数都会关系到人的生存，因此与人有关的适应性信息的量可能非常庞大——如果人必须全部感知的话将是沉重的负担。因此人需要把它压缩到可以处理的水平。 假设你想通过电子邮件将度假照片发送给朋友，但是图像超过了邮件服务器允许的大小。你可以压缩图像并检查清晰度是否可接受。如果不行，看不清你的家人在大峡谷的留影，你就不要压缩太多。你寻找一个可接受的折中方案——压缩到可以发送，但又不会模糊到不值得发送的程度。 对于人类视觉，时空和物体就是一种可接受的折中。适应度收益函数可以有数百个维度。经过亿万年的自然选择塑造，人类视觉把这些维度压缩成三维空间和一维时间，压缩成用形状和颜色维度刻画的物体。人不能处理数百个维度，但还是能处理一些。压缩过程无疑略去了一些适应性信息。例如，我们没有看到每天有数以百万计的 μ 介子穿过并用电离辐射破坏我们的身体。但我们还是感知到了足够多的关于生存和繁育后代的适应性信息。 我们在三维空间中看到物体，并不是因为我们重构了客观实在，而是因为这是一种压缩格式，这种压缩算法是进化赋予我们的。其他物种可能有不同的表示适应性的数据格式。我们的生活、移动和存在，并不是在时空和物体组成的客观实在中，而是在时空和物体格式的数据结构中，这种数据结构在智人中进化出来，以一种节约和有用的方式来表示适应度收益。我们的感知被编码为这种数据结构，而我们则错误地认为它的时空格式就是我们生活在其中的客观实在。这个错误是可以理解的，也是可以原谅的：我们的数据格式不仅限制了我们感知的方式，还限制了我们思考的方式。挣脱它的限制，甚至认识到这种可能性，都不容易。对这种可能性的领悟在知识阶层和宗教文化中有悠久的历史。 对于将时空和物体作为适应值的压缩编码，还有很多需要探索。例如，什么样的适应性被空间捕获，什么被物体捕获？形状、颜色、纹理和运动是如何在对适应度的压缩中产生的？为什么适应度的压缩会让我们产生不同形式的感知——视觉、听觉、味觉、嗅觉和触觉？也许空间距离意味着获取资源的成本：一个只消耗几卡路里的苹果可能出现在仅 1 米远的地方，而一个需要更多卡路里的苹果可能出现在更远的地方。猛兽为了抓到我消耗的卡路里越多，它们可能就显得越遥远。最近的实验支持这个观点。例如，丹尼斯·普罗菲特与合作者发现，饮用含糖饮料的人比饮用不含糖饮料(以及人工甜味剂)的人估计的距离要短；经常运动的人比不健身的人估计的距离要短。这表明，我们对距离的感知不仅取决于能量消耗，还取决于能量消耗与我们可用能量的对比。 再来看纠错。当我们使用网上银行或上网购物时，有价值的数据就会通过互联网传播。为了防止被黑客窃取，数据会加密。但另一个同等重要的问题是噪声。假设你花了 60 美元在网上给妈妈买花。后来你发现由于网络噪声小数点滑了两位，你实际上花了 6000 美元——这是一个代价高昂的错误。如果这样的错误很常见，电子商务将无法进行。为了防止这种情况，数据在发送前会被格式化为纠错码。 校验和纠错的关键是冗余。一个简单的例子是重复。假设您想要发送 4 比特数据，例如位串 1101。你可以连续发送三次：110111011101。接收器检查三次传输是否一致。如果一致，它就认为没错。但如果某次传输不同于其他，它就检测到了一个错误。它可以要求重新传输，或者假设相同的两个位串是正确的。 有许多巧妙的方法可以增加冗余，比如将消息嵌入高维空间中。但关键在于，我们的感官传递了关于适应度收益的信息，而获得正确的信息对于生存至关重要。适应度收益的小数点滑一位，对你可能是生与死的差别。可以想见，自然选择会在我们的感知界面中设置冗余，它塑造了我们的时空桌面和物理对象图标，使其带有适应度收益的冗余码，从而可以校验和纠错。 这正是贝肯斯坦和霍金对时空的发现。时空有冗余。二维可以包含任何三维空间中的所有信息。这就是我们在上一章讨论的苏士侃和特胡夫特的全息原理。这不符合直觉，并且违背了我们的假设，即三维空间是我们的感官重建的客观实在。但如果你认同我们的感官呈现适应度，并且需要冗余（比如额外的空间维度），以确保它们的呈现不会受噪声干扰，那么这就说得通了。 物理学家已经证实了自然选择的预测，即空间有冗余。但是，他们是否也证实了这种空间冗余的确有纠错码的功能？这一努力正在进行中，而且很有希望。物理学家阿迈德·阿尔梅赫利、董希和丹尼尔·哈洛发现，全息原理揭示的空间冗余表现出了纠错以防止数据被噪声擦除的特性。如他们所说，“全息原理也自然呈现于一个普遍性命题之中，即对于给定编码能保护多少量子信息不被擦除存在上限。”物理学家约翰·普雷斯基、丹尼尔·哈洛和费尔南多·帕斯陶斯基等人已发现了将时空几何解释为量子纠错码的具体方法。 由此得出的结论是，时空和物体是我们的感官用来呈现适应性的编码。像任何可用的编码一样，它使用冗余来抗噪。这个结论正是感知界面理论，同时增加了额外的洞察，即界面压缩数据和抑制噪声。 ","date":"2023-12-19","objectID":"/2023-12-19-itp/:0:2","tags":["Time"],"title":"虚拟 — 膨胀出全息世界","uri":"/2023-12-19-itp/"},{"categories":["Theory"],"content":"我们为什么看到对称性 这个结论还没有得到大多数视觉科学家的认可。他们仍然认为视觉是真实的，重建了时空中真实的物体。加州大学洛杉矶分校医院前首席精神病医生路易斯·韦斯特在《大英百科全书》的“空间感知”条目中阐述了这一假设。韦斯特认为，真实感知是“对存在的刺激的直接感知。没有一定程度的关于物理空间的真实性，人们就不能寻找食物，逃离敌人，甚至不能社交。真实的感知也会让人将变化的刺激体验为好像是稳定的：例如，即使老虎靠近时的感官图像变大了，人们还是倾向于认为老虎的体型保持不变。” 当然，视觉科学家并不声称感知始终是真实的。他们承认通过启发可以扭曲实在。但是他们认为真实性是目标，而且通常可以达到。 例如，他们认为，我们对物体的感知的对称性揭示了客观实在的对称性。视觉科学家齐格蒙特·皮兹洛就是这么说的。“想想动物身体的形状。绝大多数是镜面对称的。我们怎么知道它们是镜面对称的？因为我们把它们看成这样。除非两个对称的半体被认为具有相同的形状，否则就不可能把镜面对称的物体看成镜面对称。请注意这是很让人吃惊的，因为：(1) 我们只看得到前面，两个半体的可见表面；(2)我们从观察方向看到的两个半体相差 180°。除非形状不变性是一种真实的现象，并且除非它接近完美，否则我们甚至不知道对称形状是否真正存在。” 我们可以将这个说法精确化：我们感知中的任何对称性都意味着客观实在中的相应对称性。 这种说法成立吗？这里我们不能依靠直觉，我们需要证明。我们也的确有一个。由我提出猜想并由奇坦·普拉卡什证明的“对称性发明定理”揭示了这种说法是错误的。这个定理指出我们的感知中的对称性并不意味着客观实在的结构。对此的证明是建构性的。它明确展示了在一个没有任何对称性的世界里，感觉和行为是如何拥有对称性的，例如平移、旋转、镜面和洛伦兹对称。 这就提出了一个显而易见的问题。我们看到许多对称的物体。为什么？如果感知的对称性并不意味着实在的对称性，那么我们为什么要看到对称？ 答案依然是数据压缩和纠错——它们的算法和数据结构往往涉及对称性。过多的适应度信息可以利用对称性压缩到可接受的水平。为了感受这一点，想象看一个苹果。如果你稍微向左移一点，看起来会怎么样？你可以用对称——简单的旋转和平移——来回答这个问题。你不用为每个视角存储数百万数据，你只需要 5 个——3 个用于平移，2 个用于旋转。对称是我们用来压缩数据和纠错的简单程序。我们感知中的对称揭示了我们如何压缩和编码信息，而不是客观实在的本质。 “但是，”你可能会反对，“我们可以构建计算机视觉系统来驾驶汽车，并且看到和我们一样的形状和对称性。这难道不表明，我们和计算机都看到了实在的本来面目吗？” 并非如此。对称性发明定理适用于任何感知系统，无论是生物还是机器。计算机看到的对称性并不意味着客观实在的结构。我们可以制造一个能看到我们所看到的对称性的机器人。但这并不能让我们洞察世界的结构。 皮兹洛认为进化为对物体和空间的真实感知提供了理论基础。“如果不能提供计划性和目的性行为，动物的成功进化和自然选择的成功将是不可想象的。” 他认为，我们在狩猎、种植和采集方面的成功取决于计划和协作，而这需要对客观实在的真实感知。 计划和协作对我们的成功至关重要。但是，它们需要客观实在的真实呈现吗？根据“事实胜过真理”（FBT）定理，不需要。网络游戏《侠盗猎车手》让玩家为一些不光彩的目标而合作，比如抢劫商店或偷车。他们的计划不是基于对晶体管和网络协议的真实感知，而是基于一个由高速汽车和诱人目标组成的虚假世界。 支持真实感知的论证并不成立。而这个理论却依然是视觉科学的标准理论。根据这一理论，在时空中确实存在具有客观属性 （如形状）的三维物体，即使在没人观察的情况下也存在。当你看苹果时，苹果表面反射的光会被你眼睛的光学器件聚焦到你的二维视网膜上。这个苹果在二维视网膜上的光学投影会丢失苹果的三维形状和深度信息。你的视觉系统会分析它的二维信息，计算出苹果真正的三维形状。它恢复或重建光学投影丢失的信息。这个重建过程有时被称为“逆几何光学”，有时被称为“贝叶斯估计”。 具身认知理论的支持者反驳了这个观点，这个理论建立在心理学家詹姆士·吉布森的思想基础上。他们认为，我们是用真实身体与真实物理世界互动的物理存在，我们的感知与我们的行为紧密联系在一起。感知和身体行为必须放在一起理解。当我看到一个红苹果，我不仅仅是在解决一个逆几何光学或贝叶斯估计的抽象问题，而是看到一个与我的行动紧密关联的三维形状——我如何走向它，抓住它，然后吃掉它。大多数赞成逆几何光学或贝叶斯估计的视觉科学家都同意，行动和感知是紧密关联的。 “激进具身认知”的支持者则主张，感知和行为不仅相互关联，而且感知不需要信息处理。他们认为，感知和行为的互动不用计算和表征也可以理解。这种激进观点的支持者不多，并与量子物理学家主张的所有物理过程都是信息过程，以及信息永远不会被摧毁的观点相矛盾。这种主张也与另一种众所周知的真理不相一致，即任何经历一系列状态转换的系统都可以被解释为一台计算机（也许是一台愚蠢的计算机，但仍然是计算机）。 感知界面理论反对认为感知是真实的标准理论，但同意感知和行为是紧密关联在一起的。我们的感知进化是为了引导适应性探索和行为：我的苹果图标引导我选择吃还是不吃，以及如果吃的话怎么抓和咬；我的毒藤图标引导我选择不吃，以及为了避免任何接触而采取措施。 ","date":"2023-12-19","objectID":"/2023-12-19-itp/:0:3","tags":["Time"],"title":"虚拟 — 膨胀出全息世界","uri":"/2023-12-19-itp/"},{"categories":["Theory"],"content":"因果关系是虚构 感知界面理论对因果关系作出了一个违反直觉的断言：时空中物体之间因果关系的出现是虚构的——是有用的虚构，但仍然是虚构。我看见母球把 8 号球打进角袋。我很自然地认为，是母球导致了 8 号球滚向角袋。但严格来说，我错了。时空只是特定物体的桌面，物体是桌面上的图标；或者，就像我们讨论过的，时空是信道，物体是关于适应性的信息。如果我将文件图标拖入回收站，文件会被删除，如果我认为将图标拖入回收站导致了文件被删除，这种认识有助于操作，不过是错的。事实上，通过这种伪因果推理来预测行为后果的能力是界面设计良好的标志。 感知界面理论的这个预测——时空中物体之间因果互动的出现是虚构的——得到了缺乏因果顺序的量子计算的有趣支持。通常我们以特定的因果顺序每次计算一个步骤。例如，可以从数字 10 开始，除以 2，再加 2，得到结果 7。如果我颠倒顺序，先加 2 再除以 2，得到的结果是 6。运算的顺序很重要。但是量子计算机可以没有明确的运算因果顺序。这种计算机利用因果顺序的叠加以实现更高效的计算。 界面理论预测物理因果是虚构的。这与物理学并不矛盾。如果像物理学家现在认为的那样，时空注定消亡，那么其中的物理对象和它们表面上的因果关系也注定会消亡。目前的意识理论也注定如此，例如朱利奥·托诺尼的整合信息论（IIT）或约翰·塞尔的生物自然论，这些理论认为意识具有时空中物理系统的某些因果属性。如果像神经元这样的物理对象没有因果效力，那么 IIT 就是将意识等同于虚构，而不是具有效力的行为。此外，因果计算还不如放弃了因果的计算有力度。当 IIT 将意识等同于因果计算时，它就是将意识等同于次一等的计算。为什么意识应该低人一等？有没有关于意识的原理性洞察支撑这个可疑的主张？ 物理因果的虚构性使得构建玄妙的“万物理论”变得棘手。我们必须先给出一个关于我们的界面的理论，以及它的各个层次的数据压缩和纠错。然后我们可以用这个理论来问，从我们在界面上看到的结构中，我们能否推断出关于客观实在的什么。如果我们不能推断出任何东西，那么我们就必须假设一个客观实在的理论，并预测它会如何呈现在我们的界面上。如果要用我们的理论作出经验性预测，并通过细致的实验进行验证，以上是常规的科学程序。我怀疑，如果我们在这项事业上取得成功，我们将会发现，我们对生命和非生命的区分并不是出于对实在本质的洞察，而是由我们的时空界面的局限造成的。一旦我们将界面的局限性考虑进来，我们将会找到对实在的统一描述，包括生命和非生命。我们还会发现，神经元网络是我们用来表示纠错编码器的符号之一。 ","date":"2023-12-19","objectID":"/2023-12-19-itp/:0:4","tags":["Time"],"title":"虚拟 — 膨胀出全息世界","uri":"/2023-12-19-itp/"},{"categories":["Theory"],"content":"感知-决策-行动循环 在感知界面理论中，我们可以用如图 1 所示自主体与世界的互动简单表示感知与行为的关联。图顶部的圆角框表示自主体之外的世界。我暂时不会声称对这个世界有任何了解。特别是，我不会假设它有空间、时间或对象。我只能说这个神秘的世界有许多可以变化的状态，不管它们是什么。就自主体本身来说，有一系列体验和行为，也用圆角框表示。自主体基于当前的体验，决定是否以及如何改变当前的行为选择。标记为“决策”的箭头表示了这个决定。自主体然后对世界执行其选择的行为，图中表示为标有“行动”的箭头。自主体的行为改变世界的状态。反过来世界又会改变自主体的体验，图中表示为标有“感知”的箭头。感知和行为就这样在“感知-决策-行动” (PDA) 的循环中关联到一起（在附录中有对此的数学描述）。 图1:“感知-决策-行动”(PDA)循环。自然选择塑造了这个循环，让经验可以指导提高适应性行为。©唐纳德·霍夫曼“感知-决策-行动”(PDA)循环 \" 图1:“感知-决策-行动”(PDA)循环。自然选择塑造了这个循环，让经验可以指导提高适应性行为。©唐纳德·霍夫曼 PDA 循环由进化的一个基本要素 — 适应度收益函数塑造。行为的适应性取决于世界的状态，但也取决于生物 (自主体) 及其状态。每当自主体对世界执行某种行为，它就会改变世界的状态，并获得适应度奖励 (或惩罚)。只有行为能获得足够适应度收益的自主体才能生存和繁衍。自然选择偏好 PDA 循环能正确调整适应度的自主体。对于这样的自主体，它的“感知”箭头传递了关于适应度的信息，它的体验呈现了这些关于适应度的信息。这些信息和体验都是关于适应度的，而不是关于世界的状态。自主体的体验变成了界面——不求完美，够用就行。它引导能收集足够适应度的行为，从而能存活足够长时间繁育后代。 经过一代又一代的无情选择，每个自主体都已经被塑造得选择的行为能带来理想的适应度收益。要成功繁育后代，自主体就必须采取能收集足够适应度的行为来繁育后代，感知、决策和行动必须相互协同。那些缺乏这种协同能力的自主体很可能会悲惨地英年早逝。具有这种协同能力的自主体，则会拥有能形成有用界面的感知，产生能与这个界面正确关联的行为。 体验和行为不是免费的。你的技能越多，你所需的卡路里就越多，所以选择压力会抑制自主体的技能数量。但如果你的技能太少，你可能会缺乏关于适应度的重要数据以及能提升适应度的关键行为。不同自主体会演化出不同的解决方案，以不同的方式来平衡选择的竞争压力。人类可能比甲虫拥有更多的嗅觉体验；熊又比人类拥有更多的嗅觉体验。没有完美的解决方案——只有可行的方案，让自主体在所处的小生境中生存下来。 但无论是怎样的解决方案，与相关的适应度收益的复杂性比起来，体验和行为的数目都是很少的。自主体感知的所有关于适应度的信息必须压缩成便于管理的大小和可用的格式，而且不能丢失关键信息。信息应该让自主体能发现和纠正错误。 例如，你在黄昏时沿着人行道散步，突然害怕地跳了起来。你环顾四周，寻找罪魁祸首，当你发现草丛中是一根浇花的水管时，你放心了。你的惊跳是由一条适应度信息触发的，但是纠错不充分——它错误地写着“蛇”。正因为这条消息没有在纠错上浪费时间，所以它很快送达了，并且你迅速采取行动以避免适应度受损。在最初的惊吓之后，一条纠错信息出现了：“别担心，只是水管。”你不必要的跳跃浪费了卡路里，压力诱发了肾上腺素的分泌，所以它略微损害了你的适应度。但从长远来看，这种快速且容易出错的信息通过降低致命咬伤的风险增加了你的适应度。如果你只依靠可靠但缓慢的信息，那么很可能有一天你会正确地得知“你刚刚被蛇咬了”。很对，但没什么帮助。 这说明对于适应度信息的压缩和纠错有多种解决方案。我们可以想见，自然选择已经形成了各种解决方案，以应对变化多端的适应性，并且单个生物也可能有多种解决方案，以应对不同的适应性需求。但我们也可以想见在不同物种之间会有类似的解决方案，因为在物种形成的过程中，进化通常会再利用而不是重新设计。在眼睛的蹩脚设计中我们就能看到再利用：通过眼睛晶状体的光必须穿透血管和中间神经元的遮挡，才能碰到视网膜后部的感光器。所有脊椎动物都是这样的，这表明它在脊椎动物进化的早期就出现了，并且从未被纠正过。这种蹩脚设计完全没有必要。头足类动物的设计就是正确的，比如章鱼和鱿鱼的光感受器就位于中间神经元和血管的前面。 ","date":"2023-12-19","objectID":"/2023-12-19-itp/:0:5","tags":["Time"],"title":"虚拟 — 膨胀出全息世界","uri":"/2023-12-19-itp/"},{"categories":["Theory"],"content":"从二维全息膨胀出三维 我们可以在图 11 的视觉示例中看到实时纠错。左边的两个黑盘上有白色的剪口。右边是这两个盘旋转后剪口对齐。突然间，你看到的不仅仅是有剪口的圆盘。你看到一条发光线漂浮在圆盘前面。你可以检查圆盘之间是否绘制了发光：用拇指盖住圆盘，发光就会消失。 图11:修正擦除线。视觉系统在右侧的两个圆盘之间画一条线来纠正擦除错误。©唐纳德·霍夫曼修正擦除线 \" 图11:修正擦除线。视觉系统在右侧的两个圆盘之间画一条线来纠正擦除错误。©唐纳德·霍夫曼 你可以把这条发光的线看作你对擦除的纠正。这就好像你的视觉系统判断实际信息是一条直线，但是这条直线的一部分在传输过程中被抹去了。它通过用一条发光线填充缺口来纠错。这类似于对只能发送 000 和 111 两种消息的简单“汉明”码纠错。如果接收者收到比如说 101，那么它就知道有错误，中间的 1 被擦除了，所以它修复了擦除并得到消息 111。汉明码使用 3 比特发送 1 比特信息，因此它允许接收者检测和纠正单个擦除错误。 通过纠正黑盘图像中的擦除，你可以恢复一条消息：“圆盘前面的线。”还可以恢复另一条消息：“圆盘后面的线。”要得到这条消息，请将圆盘想象成白纸上的孔。你在透过这些孔看，在纸的后面看到一条线。请注意，当你看到这条线时，圆盘之间的线段不再发光，但你仍可以感觉到它在那里。 当你不看时，哪条线在那里？发光的还是不发光的？这个问题当然很蠢。当你不看时就没有线。你看到的线是你在更正擦除后恢复的信息。 让我们问另一个问题：当你在看时，你会看到哪条线？发光的还是不发光的？你不能确定。有时你会看到发光的线，有时看到不发光的线。但是你可以猜测概率。我更经常看到发光的线。我会说，我看到它发光的概率大约是 3/4，看到它不发光的概率约是 1/4。如果有人要求我用概率来表示这条线的“状态”(发光或不发光)，我会为这条线写下一个“叠加”态，在其中，发光态的概率为 3/4，不发光态的概率为 1/4。这类似于我们之前在量子理论中遇到的叠加态。回想一下，根据量子贝叶斯理论，量子态并不描述即使没有人观察也存在的世界的客观状态，而是描述某个自主体的信念，即如果她采取行动，她会看到什么，或者，更严格地说，如果她进行测量，她会得到什么结果。 让我们进一步看看这个例子。在图 12 中，左侧有 4 个带切口的黑色圆盘。右边对这些圆盘进行了旋转，让切口对齐。突然间，你不仅仅看到带有切口的圆盘，你还可以看到 4 条发光线漂浮在圆盘前方。每条发光线似乎都在圆盘之间的空白处继续延伸。你可以再次检查是否是你创建了圆盘之间的发光线，用拇指覆盖两个圆盘，发光线消失了。 图12:修正被擦除的正方形。视觉系统在右边的4个圆盘上创建一个正方形来纠正擦除错误。©唐纳德·霍夫曼修正被擦除的正方形 \" 图12:修正被擦除的正方形。视觉系统在右边的4个圆盘上创建一个正方形来纠正擦除错误。©唐纳德·霍夫曼 你的视觉系统纠正了 4 个擦除错误，创建了 4 条发光线。同时它也检测到了更高级别的编码信息：一个正方形。它接收不同抽象层次的信息——一维线和二维正方形。你的纠错可能同时涉及两个层次；正方形信息的证据增强了你的视觉系统对应该恢复被擦除线条的信心。 你的视觉系统还可以检测到另一种关于正方形的信息。再一次，把 4 个黑色圆盘想象成白纸上的孔洞，想象你正在透过这些洞看。你会看到纸的后面有一个正方形。当你这样作时，注意它的线条并没有发光。你确信这些线条是存在的，但是它们被白纸遮住了。 所以你可以从这个图中得到两条不同的关于正方形的信息。其中一条信息是前面的正方形，有发光的线条；第二条信息是后面的正方形，线条不发光。请注意，要么 4 条线都发光，要么都不发光。你永远不会同时看到两条发光的线和两条不发光的线。为什么？因为你的视觉系统已经将全部 4 条线组合成统一的信息：一个正方形。它将 4 条线“纠缠”在单个物体中，因此 4 条线必定是一样的。 现在进行这个例子的最后一步。图 13 的左边是 7 个有切口的黑色圆盘。右边对这些圆盘进行旋转，让切口对齐。突然你看到了 6 条发光的线条；你纠正了 6 处擦除的线条。 图13:修正被擦除的四棱锥。视觉系统在右边的7个圆盘上创建一个四棱锥来纠正擦除错误。©唐纳德·霍夫曼修正被擦除的四棱锥 \" 图13:修正被擦除的四棱锥。视觉系统在右边的7个圆盘上创建一个四棱锥来纠正擦除错误。©唐纳德·霍夫曼 但是现在你会做更激进的事情：你把这些线纠缠成单个物体——一个四棱锥——在这个过程中，你创建了一个新的维度——深度。你用二维信息全息膨胀出三维。这个例子中的纠缠与创建三维空间的意识体验密切相关。请注意，有时你会看到顶角朝外的四棱锥，有时是顶角朝内的四棱锥。当你从一个四棱锥变换为另一个时，你逆转了你全息构建的三维深度关系——前面的线条变成了后面的线条，反之亦然。这些线条都纠缠为一个整体，有一个现象可以证实这一点，当四棱锥出现在圆盘前面时，它们都会发光，出现在圆盘后面时，它们都不再发光。 在量子理论中，马克·范拉姆斯东克、布莱恩·施温格等人的研究表明，时空由纠缠的丝线编织而成。我怀疑不仅仅是相似。我怀疑在我们的视觉例子中看到的叠加态、纠缠和三维全息膨胀与量子理论中研究的完全相同。时空不是独立于观察者的客观实在。它是由自然选择塑造的界面，用来传递适应度信息。在四棱锥的视觉例子中，我们看到这个时空界面以及纠错、叠加、纠缠和全息膨胀在起作用。 另一种将二维空间膨胀为三维空间的方法如图 14 所示。左边圆盘中每个点的亮度随机选择。你只能看到噪声。中间圆盘的亮度均匀，看起来是平的。右边圆盘中的亮度则是逐渐而系统地变化。现在奇迹发生了——你把圆盘膨胀成了球体。即使这些信息是二维的，你也可以将其全息膨胀成三维物体。 图14:阴影圆盘。左边圆盘的随机阴影和中间圆盘的均匀阴影使它们看起来是平的。右边圆盘的阴影使它看起来像球体。©唐纳德·霍夫曼阴影圆盘 \" 图14:阴影圆盘。左边圆盘的随机阴影和中间圆盘的均匀阴影使它们看起来是平的。右边圆盘的阴影使它看起来像球体。©唐纳德·霍夫曼 有时你膨胀出一个凸面，有时膨胀出一个凹面，如图 15 所示：你的视觉系统更喜欢让膨胀出的形状显得光线像是从顶上照射下来的。 图15:凹凸圆盘。假设光源在顶上。©唐纳德·霍夫曼凹凸圆盘 \" 图15:凹凸圆盘。假设光源在顶上。©唐纳德·霍夫曼 除了膨胀亮度梯度外，你还会膨胀曲线，如图 16 所示。左边是有直线网格的圆盘，它看起来是平的。中间圆盘的线条略微弯曲，你会将它膨胀成球体。右边的曲线和亮度梯度结合在一起，你会将它膨胀成很逼真的球体。 图16:膨胀第三维。我们有时把弯曲的轮廓解释为有深度的三维形状。©唐纳德·霍夫曼膨胀第三维 \" 图16:膨胀第三维。我们有时把弯曲的轮廓解释为有深度的三维形状。©唐纳德·霍夫曼 我们从这些直线、正方形、立方体和球体的例子中学到了什么？按照标准的视觉科学的说法，这些例子向我们展示的是视觉系统是如何重建真实物体在客观时空中的真实形状。 而根据感知界面理论的说法，它们向我们展示的是完全不同的东西：视觉系统如何解码有关适应性的信息。没有客观时空，我们也不是在试图恢复时空中预先存在的物体的真实属性。相反，时空和物体只是传递适应性信息的编码系统。在刚刚看到的这些视觉例子中，我们发现自己把信息从二维膨胀成三维，这并不是表明客观实在是二维而不是三维的。相反，它们旨在挑战我们认为时空本身是客观实在的信念。这些例子有两个维度只是为了适合在纸上展示。 如果适应性信息被少量噪声损坏，系统有时可以纠错，就像我们看到的发光线条。如果噪声太多，比如像素具有随机亮度的圆盘，我们就无法纠错；我们看到的噪声没有清晰的适应性信息。 但是，如果亮度和轮廓传递了一致的信息，那么我们通常会将这些信息解码成三维形状的语言，这种语言是为引导适应性动作而量身定制的。例如，我们看到球体，就能知道该如何抓住它或避开它。我们看到苹果，就知道抓起和吃掉它可以增加我们的适应度；我们看到猎豹，就知道采取靠近它是不明智的。 总之，时空不是在生命萌芽前很久就已存在的古老剧场。它是我们临时创建的数据结构，用于搜寻和捕获适应度收益。像梨子和行星这样的物体，也不是在意识出现之前很久就已存在的古老舞台道具。它们也是我们创建的数据结构。梨子的形状是描述适应度收益的编码，并建议了我们可以采取的获取它们的行动。它的距离编码了我接近并抓取它的能量消耗。 参阅资料 《眼见非实》- 唐纳德•霍夫曼 ","date":"2023-12-19","objectID":"/2023-12-19-itp/:0:6","tags":["Time"],"title":"虚拟 — 膨胀出全息世界","uri":"/2023-12-19-itp/"},{"categories":["Thinking"],"content":" 无法达成的目标才是我的目标，迂回曲折的路才是我想走的路，而每次的歇息，总是带来新的向往；等走过更多迂回曲折的路，等无数美梦成真后，我才会感到失望，才会明白其中的真义。所有极端与对立都告消失之处，即是涅槃。我所向往、渴慕的那颗星，依然在我心中熠熠闪烁。 — 赫尔曼·黑塞《堤契诺之歌》 ","date":"2023-12-17","objectID":"/2023-12-17-infj/:0:0","tags":["Maya"],"title":"人格角色","uri":"/2023-12-17-infj/"},{"categories":["Thinking"],"content":"INFJ-A 代表什么？ I = 内向。“内向型的人往往更喜欢较少但深入和有意义的社交互动，通常更喜欢安静的环境。” N = 直觉。“直觉型的人非常富有想象力、思想开放并充满好奇心。他们重视原创性，专注于隐含的意义和遥远的可能性。” F = 感受。“感受型的人重视情感表达和敏感性。他们非常重视同理心、社会和谐及合作。” J = 评判。“评判型的人果断、周到，很有条理。他们重视清晰度、可预测性和封闭性，更喜欢结构和计划，而不是自发性。” A = 坚决。“坚决型的人自信、性情平和，能抵抗压力。他们拒绝过度担心，在努力实现目标时往往会自信面对。” ","date":"2023-12-17","objectID":"/2023-12-17-infj/:0:1","tags":["Maya"],"title":"人格角色","uri":"/2023-12-17-infj/"},{"categories":["Thinking"],"content":"INFJ 人格为什么不健康？ INFJ 通常是高度敏感的，他们容易受到外界的影响，对世界和人类的痛苦感到痛心疾首。INFJ 通常是高度关注自我和内心的，他们不断探索自己内心的感受和思想，但有时也会过度关注自我，忽略了周围的人和事。 INFJ 通常情感丰富，他们很容易感受到他人的情感，并能够产生共情。 INFJ 有时候会陷入情感波动中，情绪容易受到外界因素的影响。INFJ 通常是高度想象力丰富的，他们可以轻松想象出各种可能性。INFJ 有时候会过度想象，容易陷入自己的想象和幻想中，忽略了现实的存在和重要性。在这种情况下，INFJ 可能会变得迷失和难以理解。 INFJ 通常是理想主义者，他们对人类和社会有着高度的期望和信仰。但有时候现实与他们的理想相差太大，导致他们遭受挫折和失落。在这种情况下，INFJ 可能会失去动力和信心，导致难以继续前行。 ","date":"2023-12-17","objectID":"/2023-12-17-infj/:0:2","tags":["Maya"],"title":"人格角色","uri":"/2023-12-17-infj/"},{"categories":["Thinking"],"content":"INFJ 在现实中真的稀有吗？ INFJ 属于理想主义者的性格类型，正常人很难有此特质，所以 INFJ 所占人口比例很少。INFJ 这种类型的理想主义者，具有强烈的移情能力。能够获知别人的意向是善良亦或邪恶，甚至在那个人有所意识之前。INFJ 喜欢独处，性格复杂有深度，是独立的思考者。INFJ 有责任心喜欢解决问题，通常在认真思考之后行动，在同一时间内只专注一件事情。 如果你愿意花时间慢慢了解 INFJ 的想法，你会发现他们不善言辞的外表下，藏着一个有意思的灵魂，他们会挖掘事物的本质。有些会让人觉得虚无不可思议，比如人生的意义是什么呢？思考到狗究竟知不知道自己是狗，为什么歌颂兰花却不歌颂韭菜，那兰花的精神又体现在哪里呢? 比如隔壁那个 ENFP 这个快乐修勾，脑子里都在思考些啥? 不过可以肯定的是，不管是友情还是爱情，INFJ 都是十分值得相处交往的对象，他们一旦真的认定你，不管是赴汤蹈火还是温柔守护，INFJ 都会是那个最可靠的存在，这个人格因为把坚持这个词汇做到极致而显得纯粹，如果各位身边有 INFJ 型人，希望大家一定好好珍惜这个小老头，不要伤害这些小老头们。 ","date":"2023-12-17","objectID":"/2023-12-17-infj/:0:3","tags":["Maya"],"title":"人格角色","uri":"/2023-12-17-infj/"},{"categories":["Thinking"],"content":"抛开人前的面具，INFJ 真正的自我是什么？ INFJ 的底色是典型的理想主义者，理想是个中性词，不一定所有的理想都是美好的正义的。为了实现理想，INFJ 也不计手段。是天使还是恶魔，要看理想的底色，INFJ 是冷漠和热诚的混合体，外在表现可能不同。本质上热诚是因为愿意让他人变得更好而毫不自私，而冷漠是因为这种对普罗大众的爱那么平均，反而让真正亲密的人感到冷漠。虽然内心向善，但并没有表面上看上去那么热情和那么善良，更多时候是因外界需要，而让自己“看起来很好说话”，“看起来很纯善”。 每过一段时间情绪就会有上下波动，通常是在非常冷酷，和非常热情之间游走。INFJ 是彻底的理想主义是没错，但大多时间是为个人理想而理想，而非为集体，INFJ 会感觉自己很奇怪，对于跟别人相处真的会不计回报的付出，但是又感觉真的不在乎这个人，就算对方离开了也不是特别的难受。感觉网友们说的内心是空的，这个说法很可能是真的。真正的自我应该就是，全世界最信任的人只有自己，就算是孤独了第一反应也不是想着再去交几个朋友，而是去探索精神世界，沉浸在里面时会有一种滑进虚无的感觉。 ","date":"2023-12-17","objectID":"/2023-12-17-infj/:0:4","tags":["Maya"],"title":"人格角色","uri":"/2023-12-17-infj/"},{"categories":["Thinking"],"content":"INFJ 凉薄吗，有什么特点？ INFJ 可能会给人一种不以物喜，不以己悲的感觉，但其实这都是 INFJ 展示出来的样子。很多时候我会感觉环境就像是个巨大的背景幕布，形形色色的人流车辆都是点缀。感觉自己是结合冷淡和热情的矛盾体，多数时候表现出来的，都是别人需要的样子。 INFJ 并不是真的淡漠，INFJ 善于倾听，善于自省，善于给他人提建议，并积极希望可以得到好的解决。只是多数时候会疲惫于人际交往，甚至无效社交。因为总是在吸收别人的情绪，忽略自己的情感需求。而别人又很难懂自己，所以多数情况下会更喜欢独处，做自己喜爱的事情更加放松。 如果你真正想深入了解 INFJ，请多一点耐心对 INFJ，因为我们的面具戴的太久了可能揭下来需要一点时间，也请多一点认真负责，因为我们做好面具揭下来的准备了，就难免面具会连着血肉。 ","date":"2023-12-17","objectID":"/2023-12-17-infj/:0:5","tags":["Maya"],"title":"人格角色","uri":"/2023-12-17-infj/"},{"categories":["Thinking"],"content":"为什么说 INFJ 是黑圣母？ 当你靠近 INFJ 的时候，能感觉到他的温柔，可是那种疏离感却也扑面而来，而打破这种疏离感的方法至今仍未找到，因为他们本身自带着“遗世而独立”的感觉。行在人烟之处，却难融于尘世之中，他们更像独活在山顶上烟雾缭绕之处。隐晦于世间，不理会任何凡俗之事的人。 他们在看待事物的时候，更喜欢把自己放置于一个十分客观的位置。用上帝视角来俯瞰众生，然后进行内心评判。至于他们在评判些什么，只有他们自己心里清楚，旁人永远想不到。表面耐心的倾听者，此刻内心评判的声音，早已淹没了当事人的倾诉的声音。 当对方真正依赖上 INFJ 的时候，才是 INFJ 报复的开始。众所周知，情感上的依赖是极难放下的，所以此时 INFJ 报复起来的杀伤力，远远超过歇斯底里的对峙。至于报复的方法和手段，那就由 INFJ 自己掌握了。但是只要被 INFJ 所认可的人，将会得到比 INFJ 付出的两倍还不止。 INFJ 是敢爱敢恨的一类人，他们认可的人和事会一条路走到黑。他们是父母同学眼里的乖孩子，是从不逾矩的老实人。可只有他们才知道究竟有多渴望打破常规，他们一生都在寻找自由，只是遗憾的是，他们从未找到真正的自由。 ","date":"2023-12-17","objectID":"/2023-12-17-infj/:0:6","tags":["Maya"],"title":"人格角色","uri":"/2023-12-17-infj/"},{"categories":["Thinking"],"content":"INFJ 好像与世界格格不入？ INFJ 容易成为社会边缘人，他们的思想行为与周边世界格格不入，又无法被人理解，INFJ 内心有离经叛道的一面，也寻求真实和实质的东西。INFJ 确实是希望世界和谐，但世界和谐的方法并不只有一种，并不是一定人们为了和谐而去牺牲自己伪装自己，INFJ 认为真实的、和谐的、也包括人们内心的和谐，并不只是大表面的和谐。 INFJ 希望人人都能看透本性。去追求人性深处的善良与正义。INFJ 会有点小固执，但可能不会表现出来。INFJ 虽然会去追求博爱，但更多的 INFJ 应该能自我认知自私。很多的 INFJ 会告诫自己，自己的博爱行为本质是自我取悦。除了寻找外界共鸣的人得到认同外，还可以通过在学习成长和自我探索中，建立起自我认同。 INFJ 在个人成长和理解自己方面，取得进展时，更能够与自己保持一致，并相对地减轻了对外界的认同需求。建立自我认同，是一项长期艰苦奋斗的工作。INFJ 在工作上，非常有责任感且追求完美。但常常被他人所误解。为了面对这种认同匮乏和疲劳，INFJ 会学各种技能，提升职场综合能力以及工作效率。在不违背本能的情况下减轻工作负担，又可以增强自我认同感。 ","date":"2023-12-17","objectID":"/2023-12-17-infj/:0:7","tags":["Maya"],"title":"人格角色","uri":"/2023-12-17-infj/"},{"categories":["Thinking"],"content":"INFJ-A 感觉似乎不太像 INFJ？ 发现 INFJ-A 很容易在累积了多次内心的不满和积怨之后，相较和平不会大吵大闹的逐渐疏远然后绝交。感觉 INFJ-A 并不像大多 INFJ 一样对外十分温和，感觉社交有点像 E 人，算是有点锋芒的那种，但仍会以自己的方式努力与其他人和平相处，争取整体自然真实的和谐。会很容易察觉到他人情绪，所以从没得罪过人。但对于无意义社交会尽量避免，表现会变得很疏离冷漠。 审美品味不似普遍认知只有高雅的爱好，认为美好的都会很喜欢，并会不拘束于一面。内核很 INFJ 很喜欢和谐有序的氛围，尤其是各司其职的场面。朋友圈极小但很稳定。对朋友热情真诚，希望彼此能共同进步。也想要去帮助和指引困惑中的朋友。 直觉很强看人比较准，对真诚的人毫无抵抗力。喜欢深刻的话题和电影，对于日常琐碎不太感兴趣。强压下比较能自我调节与适应甚至会有斗志，但闲下来的晚上却容易内耗和过于极端，很间接性的厌世，所以需要靠独处和一些哲学书籍，追寻内心的宁静。 ","date":"2023-12-17","objectID":"/2023-12-17-infj/:0:8","tags":["Maya"],"title":"人格角色","uri":"/2023-12-17-infj/"},{"categories":["Thinking"],"content":"INFJ 为什么喜欢讨论哲学？ 因为哲学是总结事物发展的大规律， INFJ 一直以来想要追寻这些的，探索物质本质的理想不谋而合。 INFJ 内部可能也有不同的倾向，有些人会喜欢抽象的思考，有些人会喜欢感性的表达，只不过程度不同，不需要过度在意这些东西。 INFJ 的思辨性也不只是体现在哲学这一个方面上，你说你不喜欢哲学，但是你生活中运用的一切思考和行为，无不透露着你所坚信的人生哲理，只是发现和不发现的区别。 我们喜欢它作为逻辑推理结构，喜欢它作为非逻辑的直观把握，喜欢它作为对行为效果的描述，但不喜欢它无法指导我的生活。而且并不比我在困难的生活中，解决精神危机的方法更高明。你可以适当读一读哲学的书的，会让你有时候能到一个更高的视野。 文案来自 UP主 小树洞qaq ","date":"2023-12-17","objectID":"/2023-12-17-infj/:0:9","tags":["Maya"],"title":"人格角色","uri":"/2023-12-17-infj/"},{"categories":["Thinking"],"content":" 大智不群，大善无帮，何惧孤步，何惧毁谤。 — 余秋雨《文化苦旅》 提倡者 (INFJ-A)提倡者 (INFJ-A) \" 提倡者 (INFJ-A) 对待人们就像对待他们应该成为的人一样，您可以帮助他们成为他们有能力成为的人。 — 约翰·沃尔夫冈·冯·歌德 倡导者可能是最稀有的人格类型，但他们肯定会在世界上留下自己的印记。他们理想主义、有原则，不满足于平平安安地度过一生 — 他们想要站起来，有所作为。对于倡导者来说，成功不是来自金钱或地位，而是来自寻求成就感，帮助他人，成为世界上一股向善的力量。 他们有远大的目标和抱负，倡导者不应该被误认为是无所事事的梦想家。这种性格类型的人关心的是事情的本真，直到他们做了他们认为正确的事情，才会满足。他们对自己的价值观有着清醒的认识，他们在生活中兢兢业业，他们的目标是永远不会忽视真正重要的东西 — 不是根据其他人或整个社会，而是根据自己的智慧和直觉。 ","date":"2023-12-17","objectID":"/2023-12-17-mbti/:0:0","tags":["Maya"],"title":"提倡者 (INFJ-A)","uri":"/2023-12-17-mbti/"},{"categories":["Thinking"],"content":"寻求目的 也许是因为他们的性格类型很不常见，倡导者往往会有一种与大多数人不同的感觉 — 无论他们是否意识到。由于他们丰富的内心生活和寻找生活目标的深沉而持久的渴望，他们并不总是与周围的人融为一体。这并不是说倡导者不能享受社会接纳或亲密关系 — 只是他们有时会感到被误解或与世界背道而驰。 幸运的是，这种不合拍的感觉并没有削弱倡导者让世界变得更美好的承诺。倡导者受到不公正的困扰，他们通常更关心利他主义而不是个人利益。他们经常觉得有必要利用自己的长处 — 包括创造力、想象力和敏感度 — 来鼓舞他人，传播同理心。 没有什么能像改变别人的生活那样照亮倡导者。 许多倡导者将帮助他人视为生活中的使命，他们一直在寻找介入并为正确的事情大声疾呼的方法。具有这种人格类型的人也渴望解决社会更深层次的问题，希望不公平和艰辛能够成为过去。然而，有时，倡导者可能会如此专注于自己的理想，以至于他们没有充分照顾自己 — 这种模式可能导致压力和倦怠。 ","date":"2023-12-17","objectID":"/2023-12-17-mbti/:0:1","tags":["Maya"],"title":"提倡者 (INFJ-A)","uri":"/2023-12-17-mbti/"},{"categories":["Thinking"],"content":"与他人联系 倡导者可能内向，但他们重视与他人的深厚、真实的关系。很少有事情会像真正认识另一个人一样给这些性格类型带来快乐 — 同时也为别人所理解。倡导者喜欢有意义的对话远远超过闲聊，他们倾向于以热情和敏感的方式进行交流。这种情感上的诚实和洞察力可以给周围的人留下深刻的印象。 只要有一些亲密的关系是真实的，就可以使倡导者的内心充满热情。 倡导者深思熟虑并富有同情心，为他们的关系注入了大量的精力和关怀。这并不意味着他们总是会得到回报。倡导者往往以深思熟虑和谨慎的态度行事，当其他人没有意识到他们的良好意图时，这可能会让他们感到沮丧。结果，即使是建设性的批评也可能对这些个性特点的人产生难以置信的伤害。 ","date":"2023-12-17","objectID":"/2023-12-17-mbti/:0:2","tags":["Maya"],"title":"提倡者 (INFJ-A)","uri":"/2023-12-17-mbti/"},{"categories":["Thinking"],"content":"个人使命 许多倡导者认为，他们的生活有一个独特的目标 — 一个他们来到地球上要完成的使命。对于具有这种个性类型的人来说，生活中最有意义的方面之一就是寻找这个目的 — 然后，一旦他们找到了这个目的，就努力做到这一点。 当倡导者遇到不公平或不公正时，他们很少放弃 — 相反，他们会参考自己的直觉和同情心来找到解决方案。 凭借他们与生俱来的平衡心灵和头脑的能力，倡导者天生就能纠正世界上的错误，无论是大是小。这些人只需要记住，当他们忙于照顾其他人的时候，他们需要偶尔停下来，照顾好自己。 参阅资料 16 personalities 测试结果 16 型人格的雷点丨 INFJ 篇 INFJ：行走的佛陀 ","date":"2023-12-17","objectID":"/2023-12-17-mbti/:0:3","tags":["Maya"],"title":"提倡者 (INFJ-A)","uri":"/2023-12-17-mbti/"},{"categories":["Thinking"],"content":" 不要试图去弯曲勺子。这是不可能的。相反，要尽力去发现真相。勺子根本不存在。 — 勺子男孩，《黑客帝国》 人类的自我就像是在黑夜中独自前行的手电筒，光芒经由我们自己发出，最后在别的人事物上看见了自己的反射。我们对生活是那么漫不经心，以至于我们很少注意到自我的意向中心与由这个意象中心生成的其他意象实际上是无二无别的，都是它自己而已。 如果你的思维只是试着改变外在世界来符合你所认为的探寻之路应有的样子，这像为了改变镜中的样子，却去调整影像。为了让镜中的影像微笑，你显然不能去操纵影像，你必须意识到你自己才是影像的真正来源。镜子或思维的存在并不是问题，恰恰相反，人类的错误或偏差是我们认同于它。这种迷失或对局限性自我的认同，就是幻象。 觉察到观者与被观者不二，并不意味着一定要与那被观者认同，也并不意味着外界的人事物必须改变。改变的是自觉的、灵性的、内在的能量或生命力，它们从各种制约模式中解脱，从而可以由灵魂来指引一切。只有当你看到被制约的自我以及它无止尽的欲求，然后放下这一切，你才能觉知灵魂的目的。 你所遇到的所有人其实都是你自己。因为这句话，我这几年感受到了前所未有的自由感，我曾经无处不在的那种自卑感一夜之间荡然无存。如果你是一个在生活当中特别在意别人看法的人，并且你想获得在任何场合都镇定自若的气场，你就时刻刻提醒自己这个观点。 我们先思考这样一个现象，就是为什么当没有人知道你在做什么的时候，你反而会活得更好更自在，而一旦你的朋友，你的同事，你的父母知道你的工作，你的生活，你要做的事情的时候，你反而会不断的陷入到各种的困境之中。古人说事以密成，语以泄败。大概的意思就是说，一旦有人知道了你的目标，那么你原本那种势如破竹的状态就会瞬间被破坏，为什么？这个现象的答案其实是心智占据，当存在一些观众的时候，我们就不得不分离出一部分的心智来应对这些观众，我们会本能的希望自己在对方的眼里表现的还不错。 因此你在用多重评价体系来规训自己的行为。 就好比鲁宾逊落入到一个荒无人烟的孤岛上，他不会在意自己是不是衣不蔽体，他自己做了什么看似很蠢的事情啊，自己钻木取火失败了多少次。但是如果他参加的是一个野外生存的真人秀，他知道灌木丛当中其实隐藏着非常多的摄像头，那么在他的心智当中就存在着至少两套评价体系，第一要逃出荒岛，第二要在镜头当中看起来不愚蠢，因为观众是多元的，比如说，粉丝会很在意鲁宾逊，你有没有灵光乍线的求生的小妙招啊，那些黑粉会在意他，哎呀，鲁宾逊，你有没有做出什么违背常识的事情，让我来黑黑你。那鲁宾逊的父母也是观众啊，他会心疼自己的儿子在求生当中受了好多的苦啊。那鲁宾逊的女友可能会考虑，嗯，这个男人是否在这个过程当中展现出了一些值得信赖的意志品质，观众越多元，被占据的心智就会越多，于是呢，最终的表现就会越来越糟糕。 那么我们应该怎么办呢？你以为烂大街的结论：我们不要去在意别人的目光、看法，要做自己，要敢于让别人讨厌。我给你一把石破天惊的钥匙。也就是我开头说到那句话，你所遇到的所有的人，其实都是你自己。 事实上，在人生的任何场合，从来都只有你在场，你有没有发现我们前面说关注会带来压力，于是你会表现的更糟糕。这句话其实非常不对，因为关注本身并不会带来压力，而是知道有人在关注你才会带来压力。并且更加有意思，甚至有点诡异的是，你知道吗？那个关注你的观众不是别人，其实就是你自己。 有一句话叫做别人眼中的你并不是你，你眼中的别人才是你。怎么理解呢？你看现在这个屋子里面挤满了人，他们在做各自的事情，但实际上你看不见他们，你看见的其实是自我的价值观投射，比如你皱着眉头看着小明在大声喧哗，实际上你对小明其实一无所知。你看到的实际上是你自我的投射，叫做你无法忍受当众喧哗。现在你会看到了小李在安静的读书，但是有可能这其实是小李今年第一次读书，我是说你依旧对小李一无所知，你看到的其实是自己的价值观的投射，叫做你欣赏喜欢读书的人。 实际上你发现了吗？人类就像是一个手电筒，光芒经由我们自己发出，最后在别人的身上看见了自己的反射。理解了这一点，就能明白了为什么一个人崇拜什么就会对这个东西感到自卑，因为自卑的光打到别人的身上就变成了崇拜。当一个人对学历有着无可救药的崇拜时，是因为他长期对自己的学历感到自卑，于是别人只要拿出一本硕士证书就能镇住他。当一个人对于金钱有着疯狂的执着时，是因为他先从小对金钱有着强烈的匮乏感，那么别人只需要稍微显露一点财富便能驾驭他。 你看，人类在玩的永远适合自己的游戏。所以我们说的那个关注你的观众其实是假的，那个让你崇拜的人也是假的，他们从来都是你自己而已。对于那个参加真人秀的鲁宾逊而言，他从来都没有意识到他不是被别人影响了，他只是被头脑当中的自己给绑架了。对于自卑的人而言呢，他也没有意识到并不是那个人是完美的崇拜对象，他只是先感受到了自身的怯懦和不满。 一旦你拿到了我给你的钥匙，一旦你能够穿透那个虚幻的别人，一旦你意识到生命当中在场的从来都只有你自己，那么你就真正能够获得解脱自由。说起来，你现在看到这条文章里的我，或许其实也是你自己。万物都是合一的存在，其实没有人在关注你，只有你自己。大脑是投影源，我们眼睛里看到只是自我的意识投射。我们之所以在乎他人眼光，只是没有接纳自己。“不要在意别人的看法”的另一个解释：别人对你的看法是他自己对这个世界的认知，是他自己在世界上的映射。所以，别人眼中的你不是你，你眼中的别人，才是你。用王阳明的话就是：我不看花时，花与我心同寂，我看花时，则花有百般颜色，花已入我心。用佛法说，心外无物，万法唯心。 推荐阅读 观察者与被观察者 - 克里希那穆提 当我看见 - 鲁米 ","date":"2023-12-06","objectID":"/2023-12-06-performer/:0:0","tags":["Maya"],"title":"事情是如何发生的","uri":"/2023-12-06-performer/"},{"categories":["Thinking"],"content":" 我觉得有件东西是不可或缺的，那就是没有动机的热情。— 克里希那穆提 克: 我们昨天已经讨论过，心理上的时间感就是冲突的根由，时间就是人类的敌人。自从有人类以来，这个敌人就存在了。为什么人类从一开始就误入了歧途? 既然已经走错了，还有可能转到另外一个正确的方向吗? 我们昨天谈过，外在的活动就是内心活动的投射，内在即是外在。我们也问到: 我们是否热切地关注人类转向的问题，要如何才能使他不受时间的局限，只保留生活上外在的知识就够了? 宗教人士、政客和教育者全都失败了，他们从未关怀过这个问题。你赞成这样的看法吗? 博姆: 我想宗教人士也努力探讨过永恒的问题，不过他们似乎都没有成功。 克: 这就是我想讨论的。对他们而言，宗教已经变成了一种概念、理想，一种原则和价值观，而不再是真相了。大部分的宗教人士都执着于某种信仰或教条，他们紧抓着耶稣或其他形象不放。 博姆: 没错。不过你如果考虑到所有的宗教，例如各种宗派的佛教，他们想说的和你现在所说的，在某种程度上是相同的。 克: 是的，在某种程度上是相同的。但我真正想探讨的是人类为什么从不面对自己的问题？我们为什么不说“让我们停止内心的冲突”？相反的，我们却鼓励冲突，总以为只有如此才能使我们进步。 博姆: 冲突有时候确实可以激励我们，使我们有能力克服敌对的力量。 克: 先生，你我如果认清了真相，不是抽象地、而是确实深入地认清了真相，我们能不能立刻采取行动，在当下的这一刻就把烦恼解决、彻底废除心理上的时间感? 昨天我们也谈到，当心中空无一物时，就能无所不有，也就是进入无限的能量了。当时间感彻底停止以后，是不是一个崭新的开始? 没有时间感的“缘起\"存不存在? 我们又如何才能弄清楚? 沟通时必须靠语言文字，但语言文字并不是那个东西的本身。因此当时间感彻底停止以后，又是什么状态呢? 我指的是心理上的时间感，不是…… 博姆: 不是生活中的时间。 克: 时间感就是“我”或“自我感”。当这一切全都停止以后，重新开始的又是什么? 我们姑且可以说: 从时间的灰烬中又产生了新的东西? 重新开始的又是什么东西? 不对，我们不该用“开始”这两个字，因为它们暗示了时间感。 博姆: 就说有新的事情发生好了。 克: 发生了什么? 博姆: 我们昨天已经说过，那可能就是真正的创造，各种创造的可能。 克: 是的，创造。有新的东西创造出来吗? 博姆: 它已经不再是一种“变成”的过程。 克: 噢，当然不是的，那个过程已经停止了。“变成”是最糟的事，因为它就是时间感，也是所有冲突的根由。我们现在是要弄清楚当“自我” (也就是时间感)消失时，会发生什么事。佛陀称之为“涅粱”，印度教称之为“解脱”。我不知道基督徒是否称之为“天堂”…… 博姆: 基督教的神秘主义者曾经达到过类似的境界…… 克: 是的，类似的境界。但是据我了解，基督教的神秘主义者对于耶稣和教会的信仰是根深蒂固的，他们并没有超越这些。 博姆: 据我所知也似乎如此。 克: 我们刚才讨论的境界已经不再有这些执着，所有的我”都消失了。如果一个人的心已经完全消除了所有的陈迹，又会如何呢? 我们为什么要问这个问题? 博姆: 你是说这不是一个妥当的问题? 克: 我只是在问我自己而已。这个问题背后的心态，是不是还存有非常微细的期望，想证明自己已经达到那种空无的境界了? 如果是这样的话，就是一个不妥当的问题。你赞不赞成? 博姆: 这个问题会使你想找到更有希望的结果。 克: 如果所有的努力都只是想找到一个超越自我的东西，那么这份努力以及获得的境界，仍然局限在“我”的范围之内。因此我并没有这份期望，我的心中已经没有任何期望和需求了。 博姆: 那么策动你探索的又是什么? 克: 我的探索只是为了停止冲突。 博姆: 那么我们就要十分小心了。我们可能会因此而制造想停止冲突的期望。 克: 不，不，已经没有任何期望了。我已经把它断除了。我知道一旦用了“希望”这两个字，就会制造一种“未来”的感觉。 博姆: 没错，这也是一种欲望。 克: 于是又有了时间感。我的心必须把这一切都彻底搁置一旁。如果我的心仍然在追寻或摸索着某个不可解的东西，它就仍然卡在时间的范畴之内。 博姆: 是的，那仍然是一种欲望。 克: 欲望和非常微细的虚荣。 博姆: 为什么是虚荣? 克: 虚荣来自于“我达到了”的感觉。 博姆: 一种自欺。 克: 所有的自欺和幻相都会因此而出现。我是在一边探讨边清除路面。 博姆: 你似乎在清除所有微细的欲望。 克: 现在欲望的问题也解决了，剩下的便只有“心”了，对不对? 博姆: 是的，不过我们必须考虑一下自然界的本质，如果一切都是唯心所造，自然界也应该包括在内，但是它似乎是独立的。 克: 我们已经说过整个宇宙都是唯心所造。 博姆: 你是说连大自然也包括在内? 克: 是的，它也是心的一部分。 博姆: 宇宙心的一部分? 克: 没错。 博姆: 你不是指某个特定的心吧? 克: 我指的是“宇宙心”。 博姆: 我们必须把这点弄清楚，你说大自然也是唯心所造，它毕竟还是具有某种程度的真实性，不是吗? 克: 这是显而易见的。 博姆: 但是你刚才的意思似乎是。大自然只是宇宙心的一个抽象的想法罢了。 克: 它确实是宇宙心的一部分。不过我现在想探讨的是完全空寂的心。一个人的心完全空了以后，就只剩下宇宙心了，对不对? 博姆: 没错，我们讨论过，一个人的欲望一旦完全断除…… 克: 这就是我的意思。如果所有的欲求都止息了，接下来的又是什么? 还有下一步吗? 我们昨天说过，下一步又是另一个开始，然而“开始”这两个字暗示了时间感，因此并不妥当。 博姆: 我们不该用“开始”这个字眼，应该说“终点”才对。 克: 这点我们已经讨论过了。 博姆: 接下来到底还有没有新的东西了? 克: 还有没有心智无法捕捉的东西了? 博姆: 哪一种心?是宇宙心，还是某个特定的心? 克: 那个特定的心已经停止活动了。 博姆: 你是说那个接下来的境界，连宇宙心都无法捕捉了? 克: 这就是我们要弄清楚的。 博姆: 你是说超越宇宙心之外，还有一个实相? 克: 我们是不是在玩剥洋葱的游戏? 剥到最后除了眼泪之外什么都没了? 博姆: 我不知道。 克: 因为我们先说有一个终点，然后又有一个宇宙心，超越它之外，还有没有更高的境界? 博姆: 你认为这更高的境界也是能量吗?一种超越宇宙心的能量? 克: 我认为是的，因为宇宙心也是它的一部分。 博姆: 这是可以理解的。你是说这能量是活的? 克: 是的，是的。 博姆: 也有智力吗? 克: 等一等。 博姆: 以某种角度来说，它是否也是一种心智? 克: 如果这能量也有智力，它为什么会许人类误入歧途? 博姆: 我想这也许是思想不可避免的发展过程。思想的活动就是要不停地发展，包括误入歧途的自由。 克: “抉择”是不是人类最初的自由? 博姆: 不，思想必须有犯错的能力。 克: 如果一切都是由那超越的智能所操纵，它为什么会允许这个错误发生? 博姆: 我们可以假设有一个“宇宙律法”的存在。 克: 是的，宇宙有它自己的秩序。 博姆: 没错，这架宇宙机器也有犯错的自由，这就是宇宙律法的原则之一。即使这架机器故障了，对于宇宙而言也并不算失序，它还是在宇宙秩序之内的。 克: 没错。失序也是宇宙秩序之一，只有人类才会担心这个问题。 博姆: 对于宇宙而言，无所谓失序不失序。 克: 只有在较低的层次，才有这种担忧。 博姆: 也就是在人类的层次，才有失序的问题。 克: 人类为什么从一开始就失序了? 博姆: 因为他仍然无知，他还没有认清真相。 克: 他就是宇宙的一部分，却只能活在一个小小的角落里而且还是失序的。这个巨大的宇宙智能还没有…… 博姆: 是的，你可以说创造的可能性里面包括了失序。人类既然有创造的能力，也应该有犯错的能力。他不能像机器一样，永远万无一失。那个超越的智能不可能把他变成一台不会失序的机器。 克: 不，当然不会。那么在宇宙秩序之外，还有什么东西吗?一种智能? 博姆: 你是说宇宙心创造了井然有序的大自然，它一定具有更深的意义，而不只是一种机器化的运作? 克: 这就是我们要弄清楚的。 博姆: 你似乎能觉察整体宇宙和人类，这份觉知是从哪里来的? 克: 让我们从新开始:自我感(也就是时间感)一旦完全止息，所有的期望也都消失之后，就进入了空无状态。空无就是全宇宙了。 博姆: 是的，也就是宇宙心，宇宙物质了。 克: 整个宇宙。 博姆: 你是怎么知道的? 克: 噢!我就是这么知道的。简单地说:由时间、思想和教育造就的分别心已经完全止息了。因为不再有分别心，不同的境界就出现了。 博姆: 你是说分别心一停止，不同的境界就能被我们觉知? 克: 不是觉知，只是存在而已。 博姆: 我们要如何才能察觉它的存在? 克: 我不认为人们能察觉它。 博姆: 那又是什么东西让你说出了这些话? 克: 它只是宇宙的“本来面目”而已，不是我察觉它，或是它被我察觉。 博姆: 没错，它是一切事物的“本来面目。 克: “本来的面目”。 博姆: 你似乎在暗示说话的就是这“本来的面目”。 克: 没错。我很高兴你替我说了出来，因为我自己不好启口，我们现在讨论到哪里了? 博姆: 我们讨论到宇宙是一种活生生的智能，而我们都是它的一部分。 克: 只有在没有自我感时，才能说我们是它的一部分。 博姆: 也就是没有分别心的时候。 克: 我想再深入一点。超越这一切之外，还有什么东西存在? 博姆: 你是说超越这智能之外? 克: 是的。我们已经探讨过，空无一物即是无所不有，也就是所有能量的总和。这种能量纯净无染、永远不会腐败，但是在它之外，还有没有东西存在?我们又为什么要问这个问题? 博姆: 我不知道。 克: 我觉得我们到现在还没有探讨完全，还有更超越的东","date":"2023-10-05","objectID":"/2023-10-05-time-2/:0:0","tags":["Time"],"title":"清除心中的陈迹","uri":"/2023-10-05-time-2/"},{"categories":["Thinking"],"content":" 可能有不带目标并因此没有行动者的行动吗 — 不是为了某个结果的行动？这样的行动不是一种“成为”，因此不是一种争斗。的确有这样一种行动的状态，这是一种没有经验者和经验的状态。 — 克里希那穆提 克: 我们该如何开始讨论? 首先我想提出一个问题: 人类是否已经误入了歧途? 博姆: 歧途?很显然是的，而且早就走错了。 克: 这也是我的感觉。但为什么会如此? 以我看来，人类一直都想“变成”理想中的什么，因此才出了问题。 博姆: 很可能。有一回我读到一篇东西，非常令我震惊。文章上说，五六千年以前，当人类刚刚懂得掠夺和奴役其他生命的时候，就已经误入歧途了。从此以后人类生存的目的就变成了剥削和掠夺。 克: 除此之外，还有一种心理上的“变成”需求。 博姆: 人类在剥削和掠夺之下到底会“变成”什么?人类发明了许多技术和工具，本来应该用在建设性的方向，为什么会转而走上掠夺邻人的捷径。他们到底想“变成”什么? 克: 这一切的根由都来自于冲突。 博姆: 哪些冲突? 如果我们设身处地为先民着想，你认为会是哪些冲突? 克: 冲突的根由是什么? 不只是外在的，也包括人类内心的巨大冲突。 博姆: 冲突似乎是由相互矛盾的欲望引起的。 克: 不。所有的宗教信仰都鼓励人们“变成”什么，或“达成”什么，对不对? 博姆: 什么原因使他们产生了这种渴求?他们为何不满意自己的现状? 你知道，人类如果不渴望“变成”什么，宗教就不会那么受欢迎了。 克: 是不是因为他们逃避自我、不能面对现实，才转而渴求更多的东西? 博姆: 你认为人们不能面对的是哪些现实? 克: 就是基督徒所谓的“原罪”。 博姆: 但是歧途是在更早以前就步上的。 克: 没错，是更早以前的事了。印度教徒早已相信轮回之然而这种信仰的起源又是什么? 博姆: 我们已经说过了，因为人类无法面对现实。不论现实是什么，他们总是幻想情况能变得更好。 克: 没错，他们总想“变得”更好。 博姆: 我们可以这么说，他们一旦有能力把东西制造得更好，就推而广之地要求自己:“我也需要变得更好。” 克: 对，在心理上要求自己变得更好。 博姆: 我们大家都必须变得更好。 克: 很正确。那么这一切的根由是什么? 博姆: 我认为思想很自然地总要投射出更高的目标。也就是说，思想的本质里就有这种成分。 克: 是不是由外在转变成了内在的渴求? 博姆: 如果外在的一切都能变得更好，我的内心为什么不能变得更好? 克: 这就是冲突的原因吗? 博姆: 有点接近了。 克: 逐渐接近了？时间？时间是不是因素之一？我们总是说我需要更多的知识来完成这个或那个。”同样的原则是不是也用在心理上了？时间是不是主因？ 博姆: 我看不出时间本身就是唯一的因素。 克: 不，我不是这个意思。我是说“变成”之中就暗示着时间的成分。 博姆: 没错，但是我看不出时间能造成什么问题。至少它在心外并没有造成什么困扰。 克: 它还是造成了某些困扰。不过我们现在要讨论的是内心的时间感。 博姆: 我们必须先弄明白心理上的时间感为什么具有破坏性。 克: 因为我们总想“变成”什么。 博姆: 没错，但是大部分人都会说这是很自然的事。你必须解释清楚“变成”有什么不对。 克: 我一旦想变成什么，就会产生内心的冲突和永不休止的交战。 博姆: 好，让我们再深入一点: 它为什么会造成内心永不休止的交战?我在改善自己的社会地位时，并没有引起内心的交战啊! 克: 外在还不成什么问题，相同的原则一用在内心，就会造成矛盾。 博姆: 矛盾何在? 克: “本来的面目”和“应有的面目”之间就存在着矛盾。 博姆: 它为什么只会造成内在而非外在的矛盾? 克: 因为在内心里它会制造一个自我中心，不是吗? 博姆: 没错，但是我们能否找出它会制造自我中心的理由? 时间也会在心外制造同样的问题吗? 似乎没有这个必要。 克: 确实没有这个必要。 博姆: 如果我们的内心一产生时间感，就会强迫自己改头换面。 克: 正是如此。人的脑子是否已经习惯于冲突，因此一概拒绝接受其他方式的生活? 博姆: 人为什么要认定冲突是不可避免的? 克: 冲突的起源到底是什么? 博姆: 我们已经讨论过了，我们本来是一种面目，心里又想变成另外一种面目。当两种需求并存时，冲突就产生了，对不对? 克: 我了解你的意思。但是我要找出的是所有的不幸、困惑、冲突及挣扎的起源，所以在一开头就提出了人类是否误入歧途的问题。“我非我”是否就是问题的起源? 博姆: 我认为现在又更接近答案了。 克: 没错，就是它了。为什么人类会制造出一个“我”?只要有“我”，就一定产生冲突，只要有“我”和“你”，“我”比你”更好……等等，问题就产生了。 博姆: 我想这是人类在远古以前就犯下的错误，我们一旦懂得分别外在的事物，就已经步入歧途了。其中并没有恶意，只是无知而已。 克: 的确如此。 博姆: 看不清自己在做什么。 克: 这是否就是所有冲突的起源? 博姆: 我不太能确定，你的感觉呢? 克: 我的观察告诉我，真正的起源是自我感，“我”。 博姆: 是的。 克: 假如没有自我感，什么问题都没了，冲突也没了，时间感也没了，也不会再有“变成”什么或“不变成”什么的问题。 博姆: 但是我们很可能又会重蹈覆辙。 克: 等一等，有没有这样的可能? 巨大无边的能量被窄化于心智的范围内，由于脑子无法承受这么巨大的能量，因此也缩小了?你了解我的意思吗? 博姆: 我了解。 克: 于是脑子就逐渐缩成了“我”。 博姆: 我不太明白这点。我知道有这个现象，但是我不明白其中的步骤。你是说脑子确实无法承受这么巨大的能量，还是，脑子决定自己无法承受这么巨大的能量? 克: 脑子确实无法承受这么巨大的能量。 博姆: 如果它真的无法承受，那么人类就没有出路了。 克: 等一等，让我们慢慢讨论。我想再深入一点来探讨。为什么脑子里的思想会创造出一个有自我感的“我”，为什么? 博姆: 我们需要一个能赖以运作的身份。 克: 是的，为了运作。 博姆: 为了得到归属感。 克: 就是这些外在的活动造成了“我”吗? 我认同我的家，我的房子、我的职业，于是这些逐渐都变成了“我”。 博姆: 我认为你所说的“大能”也进入了自我的范围。 克: 没错，我们等一下会谈到的。 博姆: 你说得很对，自我感是逐渐强化的。但是只凭这一点，仍然无法说明它后来为何变得如此壮大。“自我”若想形成完全的主控者，必须成为“大能”的焦点，所有的能量都集中在它身上，才会造成这种情况。 克: 脑子是不是无法承受这么巨大的能量? 博姆: 脑子似乎很想让这股能量循规蹈矩。 克: 能量不可能循规蹈矩。 博姆: 但是，脑子如果觉得自己可能失控，它就会努力使自己循规蹈矩。 克: 我的脑子、你的脑子、她的脑子、大家都有的这个脑子，并不是一个新产生的东西，它已经非常、非常老了。 博姆: 你说的“老”是什么意思? 克: 我指的是它的进化程度。 博姆: 从动物开始的进化。我们可以说整个进化过程都包含在脑子里了。 克: 我对进化论存疑。当然，从牛车到喷射机的进化是可以理解的。 博姆: 在你质疑之前，我们应该先考虑一下人类在发展过程中留下的证据，这些你总不该质疑了吧? 你能吗? 克: 不，当然不能。 博姆: 我的意思是，人类的肉体在某些方面确实是进化了。 克: 没错，肉体确实是进化了。 博姆: 脑子也变得更大、更复杂了。不过你可能会怀疑心智进化的价值。 克: 你知道，我其实是想革除心理上的时间感。你了解吗? 博姆: 是的，我了解。 克: 对我而言，它就是我们的敌人。它就是人类所有不幸的肇因? 博姆: 人类必须透过时间来作息，然而时间也因此被误用。 克: 我了解。如果我要学一种语言，就必须花些时间来学。 博姆: 可是时间一误用到心理层面…… 克: 心理层面，这就是我要讨论的。心理一产生时间感，我们就会希望自己“变得”更完美，进化得更好、更有爱心等等。你明白我的意思吗? 博姆: 我明白你的意思。很显然的，如果我们把这种想法完全去除，人类的整个结构就会全盘瓦解。 克: 一点都不错。 博姆:我不知道还有没有其他原因了? 克: 等一等，我想再深入探讨一下。我说的并不是个人的主观想法，对我而言，无论内在或外在的时间活动都不存在。换言之，心理上的“明天”是不存在的。 博姆: 你指的是心理上的时间感? 克: 没错，心理上的以及外在的时间感。如果心理上的时间感不存在，冲突就会消失，“我”和“你”之间的对立感也就不见了。不过人类在科技上确实是进化了。 博姆: 肉体的结构也进化了。 克: 然而在心理上，我们也外向化了。 博姆: 我们把生存的焦点都集中于外在了，这是不是你的意思？ 克: 是的，我们把所有能力都向外发挥了，而且把外在的活动延伸到了内心。如果我们没有心理上的时间活动，不想变得更好或更完美，那么时间感就停止了。你知道，外在的活动就是内心的活动。 博姆: 没错，这此活动是永无止境的。 克: 如果这些活动真的停止了，又会怎么样? 我不知道这么说对不对:人类除了外在的活动，根本还未接触过任何其他的活动。 博姆: 大致来说确实是如此。我们把大部分的能量都消耗到外在的活动了。 克: 心理的活动也外向化了。 博姆: 心理的活动就是外在活动的投射。 克: 我们以为那是内心的活动，其实根本是外在的活动，对不对? 博姆: 是的。 克: 如果这种活动停止了，它也必须停止了，那么我们的内心会不会产生真正的活动一超越时间的活动? 博姆: 你是说，有没有另外一种活动，一种与时间无关的活动? 克:是的。 博姆: 我们必须好好讨论一下。你能不能再深入一点? 克: 你知道，“活动”这两个字就意味着时间。 博姆: 它真正的意思是从一个地方移动到另外一个地方。不管怎样，它都代表着一种非","date":"2023-10-04","objectID":"/2023-10-04-time-1/:0:0","tags":["Time"],"title":"心理冲突的根由","uri":"/2023-10-04-time-1/"},{"categories":["Thinking"],"content":" 观念能产生行动吗？还是观念只是塑造了思想，因此限制了行动？ — 克里希那穆提 我想讨论一下行动的问题。一开始也许是相当深奥和困难的，但是我希望通过对它的认真思考，我们能够清楚地看这个问题，因为我们的整个存在、整个生活，就是一个行动的过程。 我们大多数人活在一系列的行动中，一系列看似不相关、相互脱节的行动，这导致了分裂和挫折。这是一个关系到我们每一个人的问题，因为我们通过行动而活着，没有行动就没有生活、没有经验、没有思考。思考就是行动；仅仅在某个特殊的意识层面（实际上是外在的）追求行动，仅仅投身于外部的行动而没有理解行动本身的整个过程，将不可避免地导致我们走向挫折、痛苦。 我们的生活就是一连串的行动，或者说是一个在不同意识层面上的行动过程。意识就是经验、命名和记录。也就是说，意识是挑战和回应——这是经验，然后称谓或者命名，然后记录——这是记忆。这个过程就是行动，不是吗？意识就是行动；没有挑战、回应，没有经验、命名，没有记录——记忆，就没有行动。 行动创造了行动者。当行动有一个期待中的结果和目标时，行动者就悄然出现了。如果在行动中没有结果，就没有行动者；但如果有一个被期待的目标或结果，那么行动就产生了行动者。因此，行动者、行动和目标或结果，是一个同一的过程，一个单一的过程，当行动有一个期待中的目标，这个过程就产生了。朝向一个结果的行动就是意志；否则就没有意志，不是吗？要实现一个结果，这个期望产生了意志，这就是行动者——我想要实现，我想要写一本书，我想要成为一个富人，我想要画一幅画。 我们熟悉这三个状态：行动者、行动和目标。这就是我们的日常生活。我仅仅是在说明实际状况；只有当我们清楚地观察它，没有对于它的错觉或偏见，我们才能开始了解怎样如其所是地转变。构成经验的这三个状态——行动者、行动和结果——无疑是一个成为的过程。否则就不会有成为，不是吗？如果没有行动者，如果没有朝向目标的行动，就不会有成为；但是我们所知的生活，我们每天的生活，就是一个成为的过程。我是个穷光蛋，我带着一个期待中的目标行动起来，那目标就是要成为富人。我是个丑八怪而我想要变得美丽。因此，我的生活就是一个成为什么的过程。存在的意志就是成为的意志，在意识的不同层面上，在不同的状态中，其中有挑战、回应、命名和记录。这种成为就是冲突，这种成为就是痛苦，难道不是吗？它是一种持续不断的争斗：我是这个，而我想要成为那个。 因此，问题在于：难道没有这种“成为”就没有行动了吗？难道没有这种痛苦，没有这种持续不断的争斗就没有行动了吗？如果没有目标，就没有行动者，因为是带着一个期待的目标的行动创造了行动者。但是可能有不带目标并因此没有行动者的行动吗——不是为了某个结果的行动？这样的行动不是一种“成为”，因此不是一种争斗。的确有这样一种行动的状态，这是一种没有经验者和经验的状态。 这听起来太过哲学但实际上却非常简单。在体验的那一刻，你不感觉有独立于体验之外作为经验者的你；你就处在体验的状态中。举个非常简单的例子：你很愤怒。在那个愤怒的时刻，既没有经验者也没有经验；只有正在体验着。但是当你从那种状态中出来的时候，那个感受过后的一瞬间，经验者和经验就出现了，行动者和带着一个期待中的目标的行动就出现了，那目标就是要摆脱或者压制愤怒。我们反复地处在这种状态里，处在体验的状态中；但我们却总是从它里面出来，然后给它一个称谓，命名并记录它，并因此而让“成为”得以延续。 如果我们能在行动这个词的根本意义上来了解行动，那么，那个根本的了解也会影响我们外在的行为；但是，首先我们必须了解行动的根本本质。行动是由观念产生的吗？你是先有一个观念然后行动？或者是先行动，然后因为行动产生了冲突，你就在它周围构造出一种观念？是行动创造了行动者还是先有行动者呢？ 弄清楚何者为先是非常重要的。如果是观念在先，那么行动就只是在遵从一种观念，因此它不再是行动而是一种依照观念的模仿和强迫。认识到这一点是非常重要的；因为，由于我们的社会主要是建立在理智或言辞的层面上，我们所有人都是观念在先而行动跟随在后的。那么行动就成了观念的奴仆，而仅仅只有观念的构建显然是对行动有害的。观念滋生出进一步的观念，而当仅仅只有观念的滋长的时候就会有对抗，并且，社会随着观念作用的理智过程而变得头重脚轻。我们的社会结构是非常理智化的；我们以我们生命存在的所有其他要素为代价来培养理智并因此被观念窒息。 观念究竟能否产生行动？还是观念只是塑造思想并因此限制了行动？当行动被观念驱使的时候，行动就永远不可能使人类获得解放。了解这一点对我们来说是极其重要的。如果观念塑造了行动，那么行动就永远不可能给我们的苦难带来解决办法，因为，在行动发挥效用之前，我们必须先看清观念是如何产生的。对观念化以及观念的树立的研究——无论它是社会主义的、资本主义的、共产主义的、还是形形色色的宗教的观念——是至为重要的，尤其在我们的社会处于悬崖边缘，正引起另一次大灾难、另一次毁灭的时候。那些真正严肃认真地意在发现我们许多问题的人性解决办法的人，必须首先了解观念化的过程。 我们所说的观念是什么意思？ 一个观念是如何出现的？观念和行动能被凑到一起吗？假设我有一个观念并且我想要实现它。我开始寻求一种实现那个观念的方法，然后我们思索，把时间和精力浪费在为观念如何才能被实现而争论不休上。所以，搞清楚观念是怎样出现的非常重要；而在看清了它的真相之后，我们才能够讨论行动的问题。不讨论观念，仅仅只讨论如何行动没有意义。 你如何获得一个观念——一个非常简单的观念，而不必是哲学的、宗教的或经济的观念？显然它是一个思想的过程，不是吗？观念是一个思想过程的产物。没有思想过程，就不可能有观念。所以在我能够了解思想过程的产物——观念——之前，我必须先了解思想过程本身。 我们所说的思想是什么意思？你什么时候思考？显然，思想是一个反应结果，神经性的或心理性反应的结果，不是吗？它或者是感官对于感觉的即刻反应，或者是心理的，那储藏的记忆的反应。有神经对于感觉的即刻反应，也有心理储藏的记忆的反应，种族的影响，团体、古鲁、家庭、传统等等的影响——所有这些你称之为思想。所以思想过程是记忆的反应，不是吗？如果你没有记忆你将没有思想；而一种经验的记忆的反应将思想过程带入到行动中。比方说，我有民族主义的储藏记忆，自称为印度教徒。那过去记忆的储藏会对伊斯兰教徒、佛教徒或基督教徒的刺激做出反应，反应为行动、暗示、传统、风俗等等，并且记忆对于刺激的反应不可避免地会产生一个思想的过程。观察你内在的思想过程的运作，然后你可以直接地验证这个事实。如果你曾被某人侮辱，那会保留在你的记忆里；它成了背景的一部分。当你遇见那个人，也就是刺激，发生反应的就是那个侮辱的记忆。因此，记忆的反应，也就是思考过程，制造出一个观念；所以想法总是被制约的——了解这点是重要的。那就是说，观念是思考过程的结果，思考过程是记忆的反应，记忆总是被制约。记忆总是在过去，并且记忆借助刺激在现在存活。记忆本身没有生命；当现在面对一个刺激的时候它便苏醒过来。所有的记忆，不管是蛰伏的还是活跃的，都是制约，难道不是吗？ 所以必须要有非常不同的方法。你必须自己去发现，在内在，你是否在依观念行动，以及是否可能存在非观念化的行动？让我们来找出这样一件东西：不基于观念的行动。 什么时候你会不依观念行动？什么时候才有非经验结果的行动呢？正像我们所说的，一个基于经验的行动是局限性的，因此是障碍。一个并非观念产物的行动是自发的，当基于经验的思想过程不在控制行动的时候；这意味着，当头脑不控制行动的时候，就会有不依赖于经验的行动。那就是存在理解的唯一状态。当基于经验的头脑，不支配行动的时候；当基于经验的思想不塑造行动的时候；当没有思考过程的时候，那行动是什么呢？可能存在没有思想过程的行动吗？就是说，我想要建造一座桥梁、一座房屋。我知道技术，并且技术告诉我怎样去建造。我们把那叫作行动。有写一首诗的行动，有绘画、政府职能的行动，有社会的、环境的反应的行动。所有这一切都基于一种观念或以前的经验，这观念或经验塑造了行动。但是当观念化不存在的时候有没有行动呢？ 毫无疑问当观念终止的时候就会有这样的行动，而观念只有在存在爱的时候才会终止。爰不是记忆，爱不是经验。爱不是回想所爱恋的人，因为那样它就只是思想。你不可能想起爱，你可以想起你热爱的人或者把自己奉献给你的古鲁、你的偶像、你的妻子、你的丈夫；但是那思想、那符号，并不是真实，并不是爱。所以爱不是一种经验。 当有爱的时候就有行动，不是吗？而那个行动难道不是一种解放吗？它不是心理活动的结果，爱和行动之间没有间隙——象观念和行动之间的那种间隙。观念总是旧的，把它的阴影投射到现在，而我们却一直想尽一切办法要在行动和观念之间构建桥梁。当有爱的时候——并非心理活动、并非观念化、并非记忆、并非经验的产物、并非训练有素的爱——那时那爱就是行动。那就是唯一自由的东西。只要还有心理活动，只要还在用其实就是经验的观念来塑造行动，就不可能有解放；只要观念过程在继续，所有行动就都是局限的。当真相被看清的时候，爱的品质，非心理活动的、不可思量的爱的品质，就会出现。 一个人必须觉知这全过程，觉知观念是怎样形成的，行动是怎样由观念而伸展开来的，以及观念是如何依靠感觉控制行动并因此限制行动的。它们是谁的观念并不重要，不管是左派的还是极右派的观念。只要我们执著于观念，我们就处于根本没有体验的状态。那样我们就只是活在过去的时间范畴里，那会产生进一步的感觉，或者我们就只是活在未来，那是另一种形式的感觉。 只有当头脑从观念中解脱出来的时候才会存在体验。观念不是真实；真实是必须被直接体验的东西，从一个片刻到一个片刻。它不是一种你期望","date":"2023-10-04","objectID":"/2023-10-04-action-and-idea/:0:0","tags":["Advaita"],"title":"行动与观念","uri":"/2023-10-04-action-and-idea/"},{"categories":["Theory"],"content":"在密码学中，了解数字签名工作原理的最好方法是了解它的起源。因此，让我们花点儿时间简要介绍一下零知识证明(ZKP)，然后重新讨论数字签名。 想象一下，Peggy 想向 Victor 证明自己拥有一些信息。例如，Peggy 想证明她知道某个群元素的离散对数。换句话说，对于一个给定的 Y 以及群生成元 g，Peggy 想要证明她知道一个 x， 满足 $$ Y = {g^x} $$ 当然，最简单的解决方案是 Peggy 把 x(称为见证)发送给 Victor。这就是一个简单的知识证明，但如果 Peggy 不想让 Victor 得到这个 x，这个方案就不适用了。 注意 从理论上讲，如果在一个协议中 Peggy 能向 Victor 证明她知道某个证据，我们就说该协议是完备的。如果 Peggy 不能用协议来证明她确实知道某个见证，那么这个方案就不实用。 在密码学中，我们最感兴趣的是不会将证据泄露给验证者的知识证明，这种证明称为零知识证明。 ","date":"2023-05-02","objectID":"/2023-05-02-zkp/:0:0","tags":["Blockchain"],"title":"零知识证明 — 数字签名的起源","uri":"/2023-05-02-zkp/"},{"categories":["Theory"],"content":"交互式零知识证明 我们将从被攻破的协议中逐步构建一个 ZKP，并演示 Peggy 如何证明自己知道 x 而不透露 x。 密码学中处理这类问题的典型方法是使用一些随机值来“隐藏”见证(例如，通过加密)。但我们所做的不仅仅是隐藏: 我们还想证明这个见证确实存在。要做到这一点，我们需要一种代数方法来隐藏见证。 一个简单的解决方案是将随机生成的值 k 与见证相加: $$ s = k + x $$ 然后，Peggy 可以将隐藏了见证的 s 和随机值 k 一起发送给 Victor。 为了判断 Peggy 是否真的知道见证，Victor 可以检查 Peggy 给他的值是否与他所知道的相符，Victor 可以检查下面两个数字是否相等: $$ g^s = g^{k+x} = {g^x}{g^k} $$ $$ Y{g^k} = {g^x}{g^k} $$ 这个方案的思想是，只有知道见证 x 的人才能构造出满足这个等式的“盲”证据 s。因此，这是知识的证明。但这个方案存在一个问题，显然它是不安全的! 事实上，由于隐藏见证 x 的等式只有一个未知项(x 本身)，因此 Victor 仅通过移项就可以求出 x 值: $$ x = s - k $$ 为了解决这个问题，Peggy 可以把随机值 k 隐藏起来! Peggy 将随机值 k 隐藏在 g 的指数中（关键 🤔），以确保 Victor 的等式仍然有效。 $$ R = g^k $$ 这样一来，Victor 就无法获得 k 的值, 也就无法恢复 x 的值。不过他依然可以验证 Peggy 是否知道 x 的值! $$ g^s = g^{k+x} = {g^x}{g^k} $$ $$ YR = {g^x}{g^k} $$ 我们的方案有一个问题，那就是 Peggy 可以作弊。她可以在不知道 x 的情况下让 Victor 相信她知道 x! 她所要做的就是颠倒她计算证明的步骤。Peggy 首先生成一个随机值 s，然后根据 s 计算 R 值: $$ R = \\frac{g^s}{Y} $$ 而 Victor 验证计算时，$ YR = g^s $ 确实成立，因此相信 Peggy 拥有见证 x。(这种使用逆运算来计算一个值的技巧也用于密码学中的许多攻击。) 注意 从理论上讲，如果 Peggy 不能作弊(说明如果 Peggy 不知道 x，那么她就不能欺骗 Victor)，我 们说这个方案是“可靠的”。 如果要确保 ZKP 方案是可靠的，Victor 必须能够确保 Peggy 通过 R（k） 来计算 s，而不是通过 s 计算 R。为此，Victor 使协议具有交互性。 1.Peggy 必须对随机值 k 做出承诺，以确保 Peggy 以后无法更改 k 的值。 2.在收到 Peggy 的承诺后，Victor 在协议中引入了他自己的一些随机数。他生成一个随机值 c(称为挑战)，并将其发送给 Peggy。 3.然后，Peggy 可以根据随机值 k 和挑战 c 计算她隐藏了见证 x 的承诺。 由于 Peggy 在没有 Victor 的挑战 c 的情况下无法执行最后一步操作，而 Victor 在没有看到随 机值 k 的承诺的情况下不会将挑战 c 发送给 Peggy，因此 Peggy 不得不使用 k 来计算 s。 最后构成的协议称为 Schnorr 身份识别协议，Schnorr 身份识别协议是一个交互式 ZKP，它满足了完备性(Peggy 可以证明她知道一些见证 x)、 可靠性(Peggy 不知道见证 x 时无法证明她知道 x)、零知识性(Victor 对见证 x 一无所知)。 注意 Schnorr 身份识别协议运行在诚实验证者零知识(Honest Verifier Zero-Knowledge，HVZK)模 型下:如果验证者(Victor)不诚实并且没有随机选择挑战 c，那么他可以得到见证 x 的一些信息。 一些更强的 ZKP 方案可以确保即使在验证者是恶意的情况下知识证明也是零知识的。 所谓的交互式 ZKP 方案通常包含 3 个步骤(承诺、挑战和证明)，在文献中通常被称为 Sigma 协议，有时写成 Σ (Sigma 的希腊字母表示方法)协议。那么这与数字签名有什么关系呢? ","date":"2023-05-02","objectID":"/2023-05-02-zkp/:1:0","tags":["Blockchain"],"title":"零知识证明 — 数字签名的起源","uri":"/2023-05-02-zkp/"},{"categories":["Theory"],"content":"非交互式零知识证明 上述的交互式 ZKP 的问题在于它是交互式的，而现实世界中人们通常不希望协议是交互式 的。交互式协议增加了一些不可忽略的开销，因为它需要双方发送多条消息(通过网络)，并在参与双方不同时在线时会增加无法限制的延迟。因此，应用密码学领域几乎不使用交互式 ZKP。 但这并不说明之前的讨论毫无意义! 1986 年，Amos Fiat 和 Adi Shamir 提出了一项技术，该 技术可以轻松地将交互式 ZKP 转换为非交互式 ZKP。这项技术(称为 Fiat-Shamir 启发式或 Fiat-Shamir 转换)的关键是让证明者以他们无法控制的方式自己计算挑战。 这项技术的实现方法是，由证明者计算发送和接收的所有消息的哈希值，这个哈希值可以视为交互式协议中的挑战。如果哈希函数的输出与随机数无法区分(即哈希函数的输出看起来是随机的)，那么它可以成功地模拟验证者的角色。 Schnorr 在上面的基础之上注意到任何信息都可以计算哈希值! 例如，对一条消息计算哈希值。这样一来，我们得到的不仅是一个能证明我们知道某个见证 x 的证据，还是对一个与证据相关联(指在密码学上的关联)的消息的承诺。 换句话说，如果证据是正确的，那么只有知道见证(此处见证成为签名密钥)的人才能对该消息做出承诺。那就是签名! 数字签名就是非交互式 ZKP。将 Fiat-Shamir 转换应用于 Schnorr 身份识别协议， 我们就可以得到 Schnorr 签名方案。 总而言之，Schnorr 签名本质上是两个值，R 和 s，其中 R 是对某个秘密随机值的承诺(通常称秘密值为 nonce，因为它需要对每个签名都是唯一的)，s 是通过承诺 R、私钥(见证 x)和消息(挑战)计算的值。 参阅资料 节选自 《Real-World Cryptography》 推荐阅读 初识「零知识」与「证明」 一文读懂零知识证明背后的简单逻辑 彻底读懂零知识证明及其实现方法：解析 zk-SNARK 浅谈零知识证明：背景与起源 创建零知识证明的加密红包 ","date":"2023-05-02","objectID":"/2023-05-02-zkp/:2:0","tags":["Blockchain"],"title":"零知识证明 — 数字签名的起源","uri":"/2023-05-02-zkp/"},{"categories":["Thinking"],"content":"我没有任何信仰，我不愿意属于任何宗教组织，请你们务必谅解这点。我坚持主张没有任何宗教组织能引领人们见到真理，如果为了这个目的而成立人为组织，必定造成人们的依赖、软弱和束缚，既阻碍他们的成长，也使他们残缺不全。个人的特色一被抹杀，便无法见到那无限的真理了。 我主张真理是无路可循的。你不能透过任何宗教或法门而达到它。既然真理是无限的，没有任何束缚而又无路可循，也就不需要人为组织。如果你这么做，真理就变成了僵死的教条，同时也变成那些懦弱的人和暂时无法得到满足的人的玩物。 我真正关心的只有一件事，那就是如何使人类得到解脱。我要把他们从所有的牢笼和恐惧之中解放出来，因此不再建立任何新的宗教、教会、理论或新的哲学。我希望那些想了解我的人能获得自由，而不是追随我，把我关在笼子里，变成一个新的教主。 我只有一个目的，那就是使人类都能得到解脱，帮助他们挣脱所有的局限，只有这样他们才能得到永恒的快乐。他们应该解脱所有的恐惧，包括宗教的恐惧、赎罪的恐惧、得不到爱的恐惧、死亡的恐惧以及存在的恐惧。 绝对真理就是生命本身，我要每一个人都像晴空中的飞鸟一样快乐，无拘无束，独立自主，充满着自由的至乐。 我不想要任何追随者，无论在天上或地上我都没有门徒，我不需要任何追随者。一旦追随某个人，你就不再追随真理。我不是老师。如果我是老师，你就是学生。如果你是学生，你就毁了自己。 我不是任何权威，否则你就仍然在模仿、顺从与接受，在自己的内心树立另一个权威。这个权威和你之间会再发生冲突：你独特的自我，会不断与你认为应该服从的那套理论冲突。如果你向权威臣服了，你就不得不压抑自己。摆脱权威才能从恐惧中解脱出来。 一个受制于权威的人，他所学到的知识只会阻碍心中的自由，使他无法真的有所领悟。 你虽然得到了知识，但是你的心是不自由的，所以你变成了现今制度下的奴隶。这就是说，你是一个没有创造力的人。你的心中必须先要有允许创造力存在的自由，你才能用你的知识去表达那份创造力。很不幸，我们大部分的人都不了解这份创造力，因为我们的心已经被知识、传统、记忆、经典、佛陀及其他人所说的话拖累了。 所有的权威，尤其是思想及领悟方面的权威，可能是最具毁灭性、最邪恶的。领导者会糟蹋了追随者，追随者也会毁了领导者。你应该成为自己的导师和自己的徒弟。 凡是人们视为必然而重要的事，你都该提出质疑。 你们已经习惯于听从权威的话，你们以为依赖某个权威，就能得到心灵的解脱，因此你们所有的人生观都奠基在这个权威的身上。你们一旦臣服于某个权威，一定想在这个权威之上建立一个组织，于是就落在牢笼中了。 你取悦权威，是因为你惧怕什么。你们大都是在恐惧的心情下对别人表示尊敬的，只有那些不快乐、充满恐惧的人才崇拜。你崇拜是因为你惧怕什么。这种尊敬是假的，因为它的背后藏有恐惧。你的宗教就是你的恐惧，你的教主就是你的恐惧。庙宇是根据人类的恐惧而建造的，它奠基在求取安全的欲望上或是宗派的分别上。 如果一个人寻求的是真理，他会避开庙宇，因为庙宇使人类分裂。 我即使一无所有也不会成立任何组织。真理不在任何人为组织中，一旦落入组织，人心就开始僵化、定形、软弱、残缺。当你抛弃整个宗教结构和任何形式的心灵权威，你就自由了。自由里没有权威。它永远不知权威所在。这不是对权威的反对，而是根本不存在权威。 哪里没有自由，哪里便一定会有权威，而任何形式的权威都是邪恶的。不论是佛陀、基督、教皇、里根告诉我做什么，对不起，我不接受。这意味着我们必须具有非常卓绝的独在的能力。你们要打字的时候，便使用打字机，你们绝不会在这个时候把打字机供在神坛上，但是当你们一心想成立宗教组织时，你们却在这么做。在你将自己投身永恒权威、精神或神圣秩序的那一刻，你就被限制了，你窒息了你那想获得充实和自由的生命。只要有限制，就有束缚和痛苦。现在的世界就是被束缚的生命的表现。在我看来，信仰、宗教、教义，与生命无关，与真理无关。 如果你不属于任何类型，你就不必通过任何观念或信仰的门户之见来评断，而是在你和你的观察之间做最直接的接触。 即使你是第一次观察某些事物，你已经自动依据自己的偏见来诠释你所看到的事。如果你没有偏见、没有歧视，如果你是完全开放的，那么所有环绕你的事物都会变得非常有趣、非常活泼。如果拘泥于一种信仰，如果局限于一种观念，那么你终生无法自由的看事物。将种种信仰完全放在一边，才能够没有任何恐惧。 如果你不再隶属于任何家族、国家、文化或特定的一洲，你就会有一种局外人的超脱感。如果一个人能如此彻底独处，就能产生赤子之心，也只有赤子之心才能使人从悲伤中解脱。 我们常听人说，所有的道路都通向真理，走印度教的路，走基督教的路，最后都会相遇于同一座门前。仔细观察一下，这种说法是不合理的。真理是无路可循的，而它的美也就在于此，因为它是活生生的。一个死的东西才是有路可循的，因为它是静止不动的。 真理是无路可循的。没有基督教的道路、印度教的道路、佛教的道路、你的道路、我的道路。一个人要找到真理必须摆脱所有这些道路。所谓的宗教世界里，不论是印度教、佛教、犹太教、天主教，整个的宗教，是通过思维建立的，这是人发明的。是人心创造了石雕的偶像供人膜拜，是人心创造了有组织的宗教及数不清的信仰；要想弄清楚什么是真相，你就必须超越心智所创造的东西。 全世界的人类，不论属于哪一个宗教及哲学派别，都对心智加以规范，这意味着控制、抵抗、调整、压抑等等。如果你的心是扭曲的，你就永远无法诚实地看事情；如果你的心是有限的，你就不能觉察到无限。 心就是觉察的工具，为了要如实地觉察，就必须有直觉心，它必须去除所有的限制和恐惧。 它也必须从知识的束缚中解脱出来，因为知识把人心导入了不同的方向，并且把事物扭曲。如果你以印度教徒、佛教徒、基督教徒的立场来反应，你的反应就受到限制，因此根本就不算是反应。如果你以印度教徒、天主教徒、佛教徒等立场来思考事情，你的心智就已经开始走下坡路，已经腐败了。 学习和自由是在一起的。人除非自由地不落入任何形态、公式、概念的观察，否则无从学习。这种观察，这种认知，没有任何雷同、模仿、压制、控制，其中还有非凡的美。 在日常生活中，没有了知识，我们就无法开车，无法做许多事情。但是当知识变成一种传统时，它就变成了障碍，变成了领导人类心智、心理和内在的信仰，它把人的思想塑造成某种模式，这种模式不但造成人与人之间的分歧，并且造成彼此的敌意，同时也阻碍了我们向内心深处去探索什么是真相。 我们加入各种宗教，坚守着某些哲学，但是这一切都不能解决人性的问题，它们是完全没有用的。相反，它们带来了更大的不幸与悲惨。我们需要的不是哲学或理论，我们需要的是一个能够自由探索、发现及创造的心。 你是否注意到世界上的人如何把自己划入不同的圈内，他们称自己为印度教徒、佛教徒、基督教徒等。是什么东西造成了他们的分歧？使他们分歧的就是传统，传统的信念把他们的心智局限在特定的方向。 他们停止发问，因为他们的心已经被既有的知识和别人的意见塞满，他们接受了传统，然后就陷入传统中。只要你不停地发问，你就是在突破，但是当你开始接受时，你的心理上就已经僵死了。所以在你的一生中，不需要接受任何一件事，你必须探索与研究，然后你就会发现自己的心真是不可思议的东西，它根本没有止境，这种心是不会死的。 我们必须摒弃自己内心的权威，那些由自己的经验所累积的意见、知识、观念及理想。昨天的经验教你一些事情，他就成了新的权威；昨天才建立的权威和流传千年的传统是同样具有破坏性的。要了解我们自己，不需要任何昨日的、成千年以前的权威，因为我们是活生生的生命，是永远在变动、流动而永不止息的。 如果我们透过昨天已死的经验来看自己，我们就看不见那活生生的进展，以及那些活动的美和本质。 只有从内在以及外在的所有权威中解脱，你的心才能时时年轻、新鲜、天真无邪、充满热情活力。只有处在这种心境中，人才能观察和学习。要达到这种境界，需要极大的觉察力，对自己内心活动的觉察力。只是觉察不去纠正，也不指示它什么该做，什么不该做，因为你一纠正它，便树立了另一个权威及督察。 宗教强调如果人心对宗教的东西有信心，这个东西就会带给人心力量。很显然，人用心智创造了这东西，然后又从自己的创造中要回力量。这就是人心不停在做的一件事，制造一个东西，然后从中取回力量、快乐与利益。也正因为如此，人心永远是空虚的、贫乏的。 文明愈古老，传统压制你的力量就愈重，它老是告诉你应该或不应该做什么，你自己的力量就被压了下去，在心理上就像被压路机碾平了一般。这就是发生在印度的现象，传统的力量是这么大，所有创造的才能都被破坏了，你不再是一个独立的个人，你只是社会机器的一部分，而你却心满意足了，你明白吗？ 你不反抗、不抗争、不抽离。你的父母不要你反抗，你的老师不要你抽离，因此你的教育目标就是使你顺服于既有的制度。于是你就不再是一个完整的人，因为恐惧啮噬着你的心，只要有恐惧，就没有喜乐，没有创造力。你的心中必须没有恐惧，如果你的心中有恐惧，你就不能探索、观察、学习，不能深入地察觉。所以，教育的意义是消除外在及内在破坏人类思想、关系及爱的那份恐惧。如果你有恐惧，你永远也不可能有智慧。 智慧是一种无限的包容力，允许你自由地思想，没有恐惧，没有公式，然后你才能发现什么是真实的、正确的事物。 使我们接受种种制约的就是恐惧。当你给智慧下结论时，你就不再有智慧了。这就是大部分年长的人所做的事，他们给一切事情下了结论，然后他们就不再有智慧了。因此你立刻觉察到一件事，那就是：有智慧的心是会永不停止学习、永远不下结论的。一个满意于诠释的心是很浅薄的，所以是不具有智慧的。智慧不是你能获取的东西，它不像学习；它是在巨大的革新之中升起的，也就是当你没有恐惧的时候，这其实意味","date":"2022-08-14","objectID":"/2022-08-14-freedom/:0:0","tags":["Advaita"],"title":"我没有任何信仰","uri":"/2022-08-14-freedom/"},{"categories":["Theory"],"content":"The Architecture of a Web3 applicationhttps://mirror.xyz/straycatokinawa.eth/orz4h4Q-XbKC-NH8n4mdAyLp2QFD21Dsq5ewL05qoMk \" The Architecture of a Web3 application 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。 —《程序员的自我修养》 上述名言概括了计算机系统软件体系结构的设计要点，整个计算机体系结构从上到下都是按照严格的层次结构设计的。不仅是计算机系统软件整个体系是这样的，体系里面的每个组件比如操作系统本身，应用程序、软件系统甚至很多硬件结构都是按照这种层次的结构组织和设计的。 个人认为，区块链的层次结构与经典网络分层模型极为相似，在区块链里遇到的难题或许可以参考网络模型在现实中的实践方式。在探讨分层模型之前，我们需要先回顾基本的网络术语，网络由节点、节点之间的链路和管理节点间数据传输的协议组成。 ","date":"2022-06-05","objectID":"/2022-06-05-blockchain-2/:0:0","tags":["Blockchain","Network"],"title":"像理解网络模型一样理解区块链","uri":"/2022-06-05-blockchain-2/"},{"categories":["Theory"],"content":"网络术语 ","date":"2022-06-05","objectID":"/2022-06-05-blockchain-2/:1:0","tags":["Blockchain","Network"],"title":"像理解网络模型一样理解区块链","uri":"/2022-06-05-blockchain-2/"},{"categories":["Theory"],"content":"节点 节点(node)是连接到网络的物理电子设备，比如电脑、打印机、路由器等等。如果配置正确的话，节点可以在网络上进行信息的收发。节点可以彼此相邻，其中的节点 A 可以直接连接到节点 B。节点之间也可以有中间节点，例如节点 A 和节点 B 之间可以放置一个交换机或路由器。通常，路由器将网络连接到因特网，而交换机运行在网络内部，促进内网通信。 主机(host)是一种需要具有 IP 地址的节点。所有的主机都是节点，但是并不是所有的节点都是主机。 ","date":"2022-06-05","objectID":"/2022-06-05-blockchain-2/:1:1","tags":["Blockchain","Network"],"title":"像理解网络模型一样理解区块链","uri":"/2022-06-05-blockchain-2/"},{"categories":["Theory"],"content":"链路 链路(link)连接网络中的节点，它可以是有线的，比如以太网，也可以是无线的，比如 WiFi。链路要么是点对点的(节点 A 与节点 B 相连)，要么是多点的(节点 A 与节点 B 和节点 C 相连)。我们也可以在谈论信息传输时将其描述成一对一与一对多的关系。 ","date":"2022-06-05","objectID":"/2022-06-05-blockchain-2/:1:2","tags":["Blockchain","Network"],"title":"像理解网络模型一样理解区块链","uri":"/2022-06-05-blockchain-2/"},{"categories":["Theory"],"content":"协议 协议(protocol)是一组相互商定的规则，允许网络中的两个节点交换数据。有线和无线链路都可以有协议。虽然任何人都可以创建协议，但是基于因特网组织(例如，因特网工程任务组(IETF，Internet Engineering Task Force))发布的标准的协议通常是最被广泛采纳的。 权威语录 “协议定义了管理通信过程中语法（可通信的内容）、语义（如何通信）以及同步（何时通信以及通信的速度）的规则。协议可以由硬件、软件或二者的组合实现。协议可以由任何人创建，但是最被广泛采纳的协议都是基于标准的。” —— The Illustrated Network ","date":"2022-06-05","objectID":"/2022-06-05-blockchain-2/:1:3","tags":["Blockchain","Network"],"title":"像理解网络模型一样理解区块链","uri":"/2022-06-05-blockchain-2/"},{"categories":["Theory"],"content":"网络 网络(network)是一组计算机、打印机或任何其它想要共享数据的设备的通用术语。常见的网络类型包括：局域网(LAN)、家庭局域网(HAN)、校园网(CAN)、城域网(MAN)、广域网(WAN)、虚拟专用网(VPN)等。 ","date":"2022-06-05","objectID":"/2022-06-05-blockchain-2/:1:4","tags":["Blockchain","Network"],"title":"像理解网络模型一样理解区块链","uri":"/2022-06-05-blockchain-2/"},{"categories":["Theory"],"content":"拓扑 拓扑(topology)描述的是节点和链路如何在网络配置中组合在一起，通常用图描述。常见的网络拓扑类型包括：点对点网络(P2P)、总线型拓扑(Bus)、环形拓扑(Ring)、星形拓扑(Star)、树形拓扑(Tree)、网状拓扑(Mesh)、混合型拓扑(Hybrid)等。 ","date":"2022-06-05","objectID":"/2022-06-05-blockchain-2/:1:5","tags":["Blockchain","Network"],"title":"像理解网络模型一样理解区块链","uri":"/2022-06-05-blockchain-2/"},{"categories":["Theory"],"content":"TCP/IP 模型 在提到 TCP/IP 模型之前，我们先回顾 OSI 模型。OSI（Open System Interconnection）参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为 OSI 参考模型或七层模型。它是一个七层的、抽象的模型，不仅包括一系列抽象的术语或概念，也包括具体的协议。 \r分层是为了让每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能。比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。 OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。于是，后来居上的 TCP/IP 模型反而成为了编程实践中的事实标准。我们不能将 TCP/IP 四层模型和 OSI 七层模型完全精确地匹配，不过可以描述两者的对比： OSI 模型与 TCP/IP 模型对比OSI 模型与 TCP/IP 模型对比 \" OSI 模型与 TCP/IP 模型对比 下图具体描述了网络分层中每层对应的职责与作用。 每层的职责与作用每层的职责与作用 \" 每层的职责与作用 ","date":"2022-06-05","objectID":"/2022-06-05-blockchain-2/:2:0","tags":["Blockchain","Network"],"title":"像理解网络模型一样理解区块链","uri":"/2022-06-05-blockchain-2/"},{"categories":["Theory"],"content":"区块链模型 区块链(blockchain)是借由密码学连接并保护内容的链式数据记录 (又称区块)。每一个区块包含了前一个区块的加密散列、相应时间戳以及交易数据 (通常用默克尔树(Merkle tree)算法计算的散列值表示)，这样的设计使得区块内容具有难以篡改的特性。用区块链技术所连接的分布式账本能让交易双方有效纪录交易，且可永久查验此交易。 区块链技术在原有的基础概念上已经有了很大的变化和进步，截止到目前为止公认的区块链四大核心技术分别是分布式账本，共识机制，密码学和智能合约，在区块链中它们分别起着数据存储、数据处理、数据安全和数据应用的作用。 下图展示了区块链的分层，以及每个层级中涉及的技术与术语。 区块链分层模型区块链分层模型 \" 区块链分层模型 对比着网络模型，我们可以理清区块链的层级结构，并了解区块链项目开发中所涉及的底层技术。 区块链与OSI、TCP/IP的比较区块链与OSI、TCP/IP的比较 \" 区块链与OSI、TCP/IP的比较 本文主要介绍了计算机网络与区块链的分层(layer)。提醒一下自己，后续需要总结的内容是计算机领域的状态(state)和分片(fragmentation)。 参阅资料 OSI 模型-维基百科 白话 OSI 七层网络模型 为什么网络要分层？每一层的职责、包含哪些协议？ 什么是区块链的 Layer0/1/2 推荐阅读 Web3 应用的架构 Web3 DApp 最佳编程实践指南 ","date":"2022-06-05","objectID":"/2022-06-05-blockchain-2/:3:0","tags":["Blockchain","Network"],"title":"像理解网络模型一样理解区块链","uri":"/2022-06-05-blockchain-2/"},{"categories":["Thinking"],"content":" 有苦而无什么受苦者， 有作而无作者的存在， 有灭而无入灭者， 有道却无行者的存在。 —《清净道论》 独立的事物存在于想象中，不存在于现实世界。宇宙是整体的行为，个人的独立行为存在于想象中，不存在于现实世界。 第一个假象是“我”。“我”是在两三岁时伴随思想记忆而产生的，“我”是所有邪恶、痛苦、欲望、攀比、焦虑、恐惧的根源。 第二个假象是时间与因果。由于“我”的视野极其狭隘，只见树木，不见森林，“我”从整体中拆分出某个局部，却误认为这就是全部事实，于是就出现了时间与因果的观念。 那则盲人摸象的寓言就是“我”所处困境的最好阐述，一群盲人触摸到一头大象的不同部位： 摸到象腿的人说大象就像一棵树； 摸到大象尾巴的人说大象就像一根绳子； 摸到象牙的人说大象像一根长矛； 摸到大象耳朵的人说大象像一面扇子； 摸到大象身体的人说大象像一堵墙。 大象即不是树、绳子、长矛、扇子、墙，也不是由树、绳子、长矛、扇子、墙组合起来的事物。 基于独立部分的得到任何观念和结论都是对整体进行抽象甚至错误的认识。 “我”基于独立人生经验（某种幻觉体验）认为，事物有开始与结束。 于是“我”发问宇宙最初的原因是什么？先有鸡还是先有蛋？ 无论是鸡还是蛋，都是对整体抽象出的局部，鸡与蛋在现实世界中从来没有从环境中独立出来。 任何事物从来没有独立存在过，宇宙既是鸡也是蛋。 整体是处于当下的永恒运动。 整体是整体的原因和结果，不存在因果。 整体是整体的开始与结束，不存在时间。 时间是什么？时间是思想对整体的某个局部进行的抽象度量，它不存在于现实世界。 海上的浪花有开始与结束，而大海本身却是永恒的。 我们了知一件事情的发生，这个“了知”在哪？ 《楞严经》七处征心，心都不在。心既不固定在身体内，也不固定在身体外，内外的界限在哪？ 心究竟在哪？ 认识世界的心其实无处不在，整个宇宙的故事都发生“了知”的屏幕上。 因为大自然这个整体从来没有真正分裂过，分开水陆的海岸线，同时也是水陆间的结合线。 我们观察到的不是自然本身，而是自然因我们的提问方式而暴露出的部分。(维尔纳·海森堡) “觉悟”就是不再用割裂的方式看任何事物，而是认清那个幻想的“我”。 佛是什么？佛什么也不是，于是祂什么都是。整体通过释迦摩尼示现自己的存在，而非释迦摩尼扮演了“佛”的角色。 整体一旦认识了自己，就不再是有限的角色，而是作为无限存在。 推荐阅读 从个人梦中醒来 - 尼萨迦达塔语录 ","date":"2022-05-29","objectID":"/2022-05-29-no-secret/:0:0","tags":["Advaita","Time"],"title":"没有秘密","uri":"/2022-05-29-no-secret/"},{"categories":["Thinking"],"content":" 只要它是个中心，它的空间就必定永远受限。对吗？所以只要存在中心，空间就必定永远受到限制，就像一个住在监狱里的囚徒，他有在院子里散步的自由，但他永远是个囚徒。 — 克里希那穆提 请继续与我同行。尽管问题愈来愈细微复杂，但是让我们继续探讨下去。 在我建立起对你或对任何东西的意象后，我就只能看到那个意象了，于是这个意象和持有意象之人就产生了问题。例如，我看到一位穿红衬衫的人，我就会立刻生起喜欢或不喜欢的反应。这好恶的情绪，主要来自于我的文化、素养社交、嗜好以及我先天和后天的性格。我一向是透过这样的一个中心点来观察和判断事情的。因此，观察者和他的所观之物就分裂为二了。 观察者所觉察到的意象不只一个，他可以创造出上千个意象，那么观察者和那些意象有什么根本的差别？他本身不也是另一个意象吗？他老想在自己身上加点什么，又减点什么，他是一个在外界压力及内心催迫之下，不断衡量、比较、判断、修正而变化无常的生命，他活在自己的知识、影响以及不断衡量比较的意识领域中。 如果你同时注视着这个观察者(也就是你自己)，你会认出他不过是一堆记忆经验、事件、影响、传统和各种痛苦的组合，所有这些都是属于过去的。因此，观察者既是过去，也是现在，而明天在他的期待之下也成了他的一部分。他一半是活的，一半是死的，他就是在这种半死半活的状态下去观察一切的。 你这个观察者，就是从这种时间的限制中去观察恐惧、嫉妒、争战和家庭（你竟然称这个狭隘封闭的东西为“家”？），然后想在这种情况下，解决生活所带来的挑战。你总是用旧有的那套来诠释新的事物，难怪你会永远陷入冲突而无法自拔。 观察者本身属于一种意象，同时他也在观察周遭及内心的其他各种意象。他总说“我喜欢这个意象，我要保留它”或者“我讨厌那个意象，我要除掉它”。殊不知，观察者的本身也是由他对各种意象的反应所形成的另一套意象。我们可以这么说：观察者也是一种意象，只不过他能把自已和所观之物分开罢了。这个由许多意象所组成的观察者认为自己是永恒不变的，于是他把自己和意象之间划清界线，形成时间的空隙。这促成了他和那些意象之间的冲突，可是他却一味归咎于那些意象，于是他说：“我非除掉这些冲突不可!” 这个想法一产生，却又创造了另一个意象。 对于上述一切的觉知就是真正的冥想，它披露出存在的真相，也就是各式各样的意象集合成一个意象中心，这个中心意象，就是观察者，也是检查者、经验者、评估者，这个法官总想征服其他的意象，甚至想把它们一举歼灭。 其他的意象，既是观察者的观念、判断和结论的统合，而观察者本身又是由这些其他意象所汇集而成的，所以观察者就是被观察者。 这份觉察已经披露了人心的不同状态，也揭发了人心各种的意象，以及意象之间所形成的矛盾，同时显示出矛盾所带来的冲突，以及对冲突的一筹莫展，还有那些逃避它们的各种企图。透过非常细心而谨慎的觉察，这一切真相都被揭发了！然后你才发现：原来观察者就是被观察之物。 但是这觉察的本身，并非另一个比较高级的本体，也没有更高的超我存在（更高的本体以及超我，不过是人类所发明出来的另种意象而已）。就是那觉性本身揭发了“观察者与被观察者不二”的真相。 如果你问自己一个问题：那么接受答案的那个本体是谁？那个发问的本体又是谁？如果这本体只是意识和思想的一部分，那么它根本就不可能找到答案。你所能找到的只是觉察的状态而已。如果在这觉察的状态中还有个本体在那里说“我必须觉察，我必须练习这种觉察力”，你就又开始制造另一个意象了。 觉察到观者与被观者不二，并不意味着一定要与那被观者认同。我们相当容易将自己与某些东西认同，例如家庭、丈夫或妻子以及国家等，因而招来极大的痛苦以及无止境的战争。我们此刻所探讨的，乃是另一种境界，我们不该在口头上，而应该从内心深处，从存在的根本去了解它。 据说中国古代有一位艺术家，他在画一棵树之前，一定要坐在那棵树前看上好几回、好几个月，甚至好几年，不论多久，总要看到他自己变成那棵树为止。他并不是在和那棵树认同，因为他就是那棵树了。这表示他与那棵树之间，观察者与被观察者之间，已经毫无时空隔阂，没有那个经验的主体在那里感受大树的美、活动、树阴、叶质以及色泽。他已经完全变成了那棵树，在这种境界之下，他才肯提笔作画。 如果他尚未领悟到观察者与被观察者不二的真理，则观察者的任何作为不过是在制造另一个意象而又使自己身陷其中。当观察者觉察出所谓的观察者也不过是被观者而已，接着又会怎么样（慢慢来，别急着答复，我们现在正进入一个相当复杂的问题）？ 究竟会怎么样？观察者就不再有任何活动了，不是吗？以前观察者总是说：“我必须解决这些意象，我必须压抑它们、改造它们。” 他所有的行动都和被观察者有关，这些行动和反应有时热情，有时漫不经心。这种好恶交战，也就是“我喜欢，因此我要抓紧它；我不喜欢，因此我得除掉它”的被动反应，居然被人们视为积极的行为。但是，观察者如果突然了悟他所应付的这种被动反应所产生的问题原来就是他自己，那么他和那些意象之间的冲突就消失了。他，就是那个东西，无二无别。当二者对立时，他只好忙着应付它；不过一旦体会他就是那个东西，也就没有什么喜欢或不喜欢的，于是内在的冲突就停止了。 如果那个东西就是你，你会怎么办？你既无法抗拒，也无法逃避，甚至连接受都没有必要，因为它就在那儿。于是那个受好恶之心所驱使的反应作用，便到此结束。 然后你会发现，你的觉知突然变得极为活泼，它不受制于任何事件或意象。从这种强烈的觉知中就会产生不同品质的专注力，这种专注力就会造成全然不同的心智状态。因为心智就是觉知的本身，它会因此而变得极度敏锐，而且有高度的智慧。 参阅资料 节选自 《Freedom from the known》 推荐阅读 没有疆界的觉知 — 肯·威尔伯 ","date":"2022-03-15","objectID":"/2022-03-15-observer-and-observed/:0:0","tags":["Advaita"],"title":"观察者与被观察者","uri":"/2022-03-15-observer-and-observed/"},{"categories":["Thinking"],"content":" 无名，天地之始。有名，万物之母。 —《道德经》 容我慎重地提醒你生与死是至高无上的。时光匆匆，机会转瞬即逝。我们每个人都应努力觉醒。觉醒。谨慎，不要浪费你的生命。人类已经深入物质领域，扎根于我们存在的精神与物质层面。如同卡尔荣格所说：“想要接触天堂，必须深入地狱”。从巴比伦的熔炉中浮出来的，是形象的彻底转变和新的人类潜能。东方的传统中说，觉醒的莲花出自轮回的迂泥，出离自苦。基督教则描述了伊甸园的没落。用很深奥的术语来说的话，这是一种独立于上帝旨意的个人自我或个人意志的创造。 伴随着这个分裂的自我，一个外在思想世界跟着出现。一个似乎与这个有限的自我分裂的形式世界。角色，或是小我（ego），是由我们的思想从投射出来的外在世界追求各种事物的模式所构成的。我们所渴求的外在事物是善恶的知识树，或二元对立树的果实。你可以说原罪是小我或二元意识的欲望。这就是幻象（maya），人类现在所处的境地。追求外在的果实意味着错过目标，错过当下。 从历史上看，人类意识偶尔会出现罕见的觉醒。圣人、瑜伽士、贤者和智慧的守护者。但是人类现在有了一个独特的机会，可以集体进行这次旅程；因为我们重新发现了更高的世界，并从受限自我的集体梦境中醒来，去展望和共创共享新的现实。 绝大多数人目前的生活，几乎完全认同于他们所存在的，粗略的身体和心理层面，完全不知道更高层次的存在。大多数人不知道，或怀疑他们的自我结构中，潜藏着灵性的能力，等待被启发。透过实现这些能力，我们可以连接到更微妙的存在层次，同时使自我结构渗透到我们的真实本性中；而不去认同所有层次的心智或幻象。如果我们检视历史上始终存在的灵性传统，我们会发现伟大的贤者、神秘主义者和先知都描述了一个连续的存在。 古老的吠陀教义描述了灵魂的五个能层（kosha），从粗糙的身体和精神领域，也就是大多数人今天生活在其中的受制约的世界，延伸到精微领域，包括充满活力的星光体和更高的精神领域，也就是实存的角色原型样板。最后到达没有思想或感觉的因果（causal）领域。原始意识的实现，灵魂内神识的觉醒，驱散了所有这些领域——所有幻象的层次。古老的传统包含许多概念和语言框架，指向从粗略到微妙到因果的连续统一体。无论是吠陀传统的脉轮系统或能层系统，还是道教的丹田，所有变化场域内的各个层次都是幻象；掩盖我们真实本性的螺旋却也是生命本身的展现。正是透过生命的螺旋，我们才能体验人类的生活。当我们意识到所有层次的幻象都是自性空的时候，就有可能体验到一种深不可测的非二元性或一种言语道断的神秘结合，包含并超越所有其他层次。 亨利·大卫·梭罗有句名言，大多数人过着平静的绝望生活。他们带着自己的歌声走进坟墓。他们的绝望来自于对自己无止境的探索。对「物」的追求；金钱、权力、人际关系、他人的认可。苦的根源在于对事物的执着心，而不是事物本身。你拥有什么不重要，重要的是你对你所拥有的东西的执着。 我们透过神经可塑性在感官层面形成依恋与执着。无论注意力在哪里，神经元都会激发并连接在一起，在脑中建立一个程序；一种倾向的模式，这模式也就是头脑本身。当我们有任何无意识的倾向或生活模式时，我们实际上并没有沉迷于事物本身。我们并非沉迷于毒品、酒精、性、食物或媒体，而是沉迷于它们在我们体内产生的感觉。 透过直接观察身体，观察在意识的根本层次上，有着不断改变现象的这个场域，我们可以重新得到自由。我们保持平等心，不做反应、不去判断任何感觉的好坏。为了获得自由，我们透过将意识带入微妙的内心世界来了解这些依恋与执着是如何形成的。我们开始将心理和感官现象视为一个变化的场域，而不是执着于那些带来认同和形式世界的创造的思想和感觉。这个变化场也被称为普拉纳（Prana）或内在能量；内在活力的感觉。 对物质主义态度的转变正带领我们前往一个新的世界。我们正在目睹的是旧范式的释放，同时还有想要无休止地获得更多的病态小我想法。现在你周遭看起来像是一片黑暗，像是一片疯狂。事实上这就是在我们的地球世界中看觉醒时的样子。你正在目睹旧模式的瓦解。 许多人对当前的政治、社会、经济和宗教制度感到失望。他们不再相信与期待媒体行业和所谓的灵修系统。他们不信任医疗机构或政府。人们失望（disillusion）了。这种幻象的驱散是看到真相的必要过程；与我们所生活的这个时代固有的精神疾病面对面，并从小我意识中走出来。我所说的小我意识是指无意识地运作的渴求和瞋恨的模式；集体轮回或条件模式创造了幻象的条件——对我们的角色、社会群体或我们定义自己的任何事物的深度认同以及我们在这一生中扮演的各种形象和角色原型。自我结构是与世界接轨的介面——我们不摆脱或破坏这个介面，而是从它那里去除认同。我们对“我”的感觉或存在感就不会被束缚在一个有限的形式上。这样我们就不会在形式世界发生变化时受苦。 人类的道路是从“前自我存在”（pre-egoic existence）也就是我们在孩提时代与母亲所经历的融合一体，到创造出一个人的旅程。我们成长，创造出一个角色。这是我们进化的必要部分。为的是产生自我意识，带来自我或“我”的感觉。我们实际上正处于发展的青春期。我们正处于自我认同阶段。但是超越自我意识的下一步，是实现自我的超个人层次。实现意识的共享层次；实现不同层次的逻各斯（Logos）或更高等的心智。或者说灵魂的层次，如果你喜欢这种说法。 我们的同情范围扩大了。这是透过爱的展现。 从旧模式的小我意识来看，这种瓦解是可怕的。如果你固守旧的模式，将会感到困惑和痛苦。那些觉醒实际上会被视为一种威胁。觉醒将被视为一场危机，因为它是对已知事物的瓦解。现在我们就像茧中的毛毛虫，正在蜕变。转变的过程中有一个时间点，毛毛虫既不是毛毛虫也不是蝴蝶。此时对于正在蜕变的那个旧自己，似乎已经失去了一切。但这只是过程的一部分。信仰是对进化冲击的臣服；深知我们正在走向本源。集体错觉，古代精神导师称之为幻象（maya），与我们对旧模式的集体依恋有关。它与人类的傲慢有关；相信我们知道我们要去哪里， 我们在做什么，以及我们是谁。 法国画家保罗·高更以其题为《我们从哪里来，我们是什么，我们要去哪里？》的一幅画而闻名。这三个问题需要谦虚。为了找出真相，我们首先必须承认我们不知道真相。如果我们想找到答案，我们就没有答案。必须有一种真正的探索和审视自己的意愿。就像但丁在《神曲》中的朝圣者一样，人们开始了在黑暗森林中认识自己的旅程，误入歧途，认识到我们迷路了。 在古老的吠陀传统中，存在和生成的维度由湿婆和夏克提来代表。夏克提代表了典型的女性、向下的流动或显化的流动。透过指向下的三角形，它指向由精神到形式世界的衰退。湿婆代表向上的流动或解放的流动。向上的三角形指向没有任何特性的纯粹意识；超越形式或超越世界的进化。只要我们在二元世界中运作，认同有限的心智，这两种潮流就构成了无路可走的道路。我们在显化之流和解脱之流中工作，做与不做，居住在时间限制和永恒之中。当这两个维度在神圣的结合中结合，实现一体性时，就是三摩地。当它们结合时，它们代表了这两个维度的平衡和共存，就像大卫之星或心脉轮（Anahata）符号，它是代表精神之心的古老符号，未击中的声音，原始“唵”的超然源泉，正在将宇宙舞蹈成实存。据说在三摩地中你会听到存在的天国音乐，或者克里希那的长笛，或者毕达哥拉斯所说的“天体音乐”。当然，这些都是觉醒于你的实存生命深处的东西，超越有限的思想和感官的东西的比喻。 有一些灵修系统会透过诸如观察呼吸、气或普拉那的感觉等练习来关注身体上细微的部份，运用可以透过有限心智学习的技巧实践和过程。为了实现三摩地而直接采用有限心智的一切，都是“正面方式”（via positiva）的一部分，这就是我们所说的夏克提路径。还有一些关于超越显化世界的灵修系统，我们称之为“负面方式”（via negativa）或湿婆路径。透过放下所有我们不是的一切，我们开始意识到我们超越了名称和形式。通往三摩地的道路被赋予了许多名称，例如冥想、自我探询或祈祷。 今天修练这些东西的人，大多是在修练一些技巧，但这种通向三摩地的古老禅定，其实并不是一种活动。它不是你做或修行的事情，它实际上是禅修者、求道者或行者的止息。真正的冥想是与实相的结合，只有当小我尝试冥想失败并意识到自己的局限性时，它才会开始发生。小我，也就是你所认为的你，必须在所有冥想尝试中失败，才能实现真正的冥想。我们越接近真理，就越接近三摩地，做的越少，技巧也就越少。这些技术都是过去的一部分。我们放弃做事和做事者。我们放弃寻求和寻求者，来到无条件的当下。有些老师过分强调技巧，而有些老师则低估了技巧。重要的是要了解该技术是垫脚石。我们不需要放弃这项技术，但也不执着于它。实现三摩地的经过时间考验的方法是透过长期的精神实践。无论你称这种练习为冥想、自我探询还是祈祷，都有一个必须唤醒的真理。 2500 年前编纂瑜伽经的瑜伽士和圣人帕坦伽利（Patanjali）教导说，瑜伽的整个努力都是为了让心的漩涡停止。你可以说是业障，支配一个人生活的深层无意识模式的停止。这些受限的模式在梵文中被称为 vritti’s。同样地，道元禅师说，禅定是身心逐渐的放下。在佛教中，它是涅槃或涅槃；是有限的自我心智波动的停止，导致对有限的自我意识的认同。在基督教中，我们发现相同的常年教导，但透过一个非常不同的比喻表达，使用当时历史上常见的语言。用基督教的术语来说，实现三摩地就是透过对罪的宽恕，实现基督自性，并达到神的国度。希伯来语中的「罪」这个词的字面意思是“没有达到目标”——意味着错过当下，追求外在世界的幸福，而不是实现真正满足的源泉。 进入当下，活在当下就是学会放弃受制约的心智的偏好。透过对变化场域中出现的任何事物保持不反应来解除对立的","date":"2022-02-01","objectID":"/2022-02-01-samadhi-3/:0:0","tags":["Samadhi"],"title":"无路之路","uri":"/2022-02-01-samadhi-3/"},{"categories":["Thinking"],"content":" 镜子互相反射，而影子又再次互相反射以至无穷，一个层面的变化会导致所有层面的同时变化。 — 纪录片《三摩地》 从古至今，世界上最伟大的精神导师都认为人类最本质的真相并不在于拥有某种特殊的宗教或精神文化。这个真相其实就在每个人的内心。诗人鲁米说：那个永不曾升起或落下的月亮在哪里？那个永不曾伴随或离开我们的灵魂在哪里？不要说它在这里或那里。 所有的创造都是“那个”，除了能看东西的眼睛。在“巴别塔”的故事中，人性碎裂成无数的语言、信念、文化和爱好。“巴别”的字面意思是“上帝之门”，这个门就是我们的思想意识，即我们局限性的自我架构。那些体悟到真实本性的人，他们的本质超越了名相，他们得以窥见大门之内那些神圣的秘密。 那则盲人摸象的古老寓言，常被用来比喻面对同一个真相却有各种各样不同观念的情形。一群盲人分别触摸一头大象的不同部位，然后得到一些对大象的认识。摸到象腿的人说大象就像一棵树。摸到大象尾巴的人说大象就像一根绳子。而摸到象牙的人说大象像一根长矛。摸到大象耳朵的人，又说大象像一面大扇子。摸到大象身体的人，坚持说大象就像一堵墙。问题在于我们只接触到了大象的一部分，却坚信自己了解到的就是真相。我们不承认或没有认识到每个人的经验只是对同一头大象不同部分的了解。永恒哲学就是已经认识到所有的精神或宗教文化都在阐述一个共同的宇宙真相，一个神秘的、超乎人类思维的真相，所有的精神类知识和信条都建立在它的基础之上。 斯瓦米•维韦卡南达针对永恒教义总结道：“所有宗教的尽头就是体悟灵魂之神，这是那个共同的宗教。”我们在这部影片中所说的“神”这个词就是指那个神秘的、超乎人类局限性思维的真相。要体悟“真我”或内在的“本我”，就要体悟人类殊胜的本性。每个灵魂都有显现更高层级觉知的潜力，都可以从沉睡和对形相的认同中觉醒。 身为作家和预言家的奥尔德斯•赫胥黎因《美丽新世界》一书而成名。他还写了另一本名为《长青哲学》的书。在书中他提到一则历史上不断重现的教义，这则教义以其所属文化的形式表达出来。他写道：永恒哲学以最简洁的方式在一个梵文习语中呈现出来，即“那就是你”。“本我”或那个永恒存在的“我”，就是梵心——所有客观存在的最高准则，每个人的终极任务就是亲自去探寻真相，明白自己到底是谁。每一种传统文化就像钻石的一面，从一个独特的视角反射着同一个真相。而同时，它们又互相共鸣，互相印证。不论是何种语言或概念体系，所有秉持永恒教义的宗教都在告诉我们，我们与一种更伟大的、超乎寻常的力量联结着。我们可以从一个或多个源头学习和领会关于真相的教导，而无须与它们产生自我认同。据说所有真正的精神教导都只像是指向终极真相的手指。如果我们过于执着于那些教义和信条，将会阻碍精神的进化。要体悟超乎所有概念的真相，就要放下所有的执着和依附，放下所有的宗教观念。从“自我”的视角来看，将你引向三摩地的那根手指则是直接指向了地狱。圣十字若望曾说：“如果一个人想确认自己脚下的路，他必须闭上双眼，在黑暗中行走。” 三摩地开始于面向未知的那一跃。据说在古代传统中，为了体悟三摩地，必须让知觉彻底远离所有事物、所有外在现象、所有局限性的思想和感知，从而走向觉醒，走向内在本源和人的本心或本质。在这部影片中，我们所说的“三摩地”指的那个是超乎人类思维的真相，也就是被称为“无余涅槃”的最高三摩地。 在“无余涅槃”的状态中，“自我”的活动以及所有探索行为都停止了。估且描述为：当接近它时，它远离了；当离开它时，它又回来了；没有知觉或无知觉的区分，没有存在或不存在的区分，也没有意识或无意识的区分。对思维来说，这绝对高深莫测、无法理解。当“自我”又重新浮现时，将是一种空白，一种重生，一切都将是新的。只剩下一种神圣的回味长久伴随着我们继续前行。 在古代文化中有很多种三摩地，随着语言的变迁造成了很多混淆。我们用“三摩地”这个词指的是那个超乎人类思维的联结状态，但我们也可以用其它文化中的词来表达。三摩地是一个古老的梵语词汇，在古印度吠陀、瑜伽和数论派文化中很常见，并渗透到许多其它的文化体系中。三摩地是帕坦伽利所传授的“瑜伽八支行法”的第八支，也是佛陀所说的“八正道”中的第八道，佛陀称之为“正定”，也就是“静脉”的止息，或自我思维的止息。帕坦伽利将瑜伽或三摩地称为“心念灭尽”，即“意识的旋涡停止盘旋”之意。也就是知觉从整个思维运作机制中解脱出来。三摩地并不意指任何概念，因为要想体悟三摩地就要放下所有概念性思维。 不同的宗教用不同的词汇来表述这种殊胜的联结状态。事实上，“宗教”这个词本身也是如此。在拉丁文中，“宗教”意指“重新绑定”或“重新联结”，与“瑜伽”涵义类似，“瑜伽”的本义就是“联结”，联结尘世与解脱的彼岸。在伊斯兰教，“伊斯兰”这个词在古阿拉伯语中是对神灵恭顺或祈求之意，意指“自我”彻底的谦恭或顺从。 基督教神秘主义者如圣方济、圣特雷莎和圣十字若望都描绘了与上帝、与内心神圣王国的殊胜联结，在《多马福音》中，基督说：“王国不在这里或那里，圣父的王国在地球上无处不在，而世人却看不到。”从永恒教义的角度来看，古希腊哲学家柏拉图、普罗提诺、巴门尼德和赫拉克利特的著作，都指向同一个真理。普罗提诺教导说人类最伟大的奋斗就是引导灵魂去往最高的完美境界，并与神联结。 拉科塔族圣人黑麋鹿曾说：“最高的，也是最重要的平和，就是体悟到自身与宇宙及其能量相通如一，体悟到宇宙的中心有伟大的灵魂，而这个宇宙中心其实无处不在，就在我们每个人的内心时，来自灵魂深处的那种平和。 在觉醒之路上，除非我们进入三摩地，否则永远会有两个极端或两扇门可以进入，也就是两个维度：一个通向纯粹的觉醒，而另一个通向表象世界。向上就会通向觉悟，而向下则通向迷失和一切或有形或无形的幻象。 至于相对和绝对之间的区别，可以用印度圣哲尼萨伽达塔的话来说明，“智慧就是知道自己一无所有，爱就是知道自己拥有一切，而我的生命，在这两者之间前行。”这种联结产生一种新的殊胜的觉知。这两个极端的联结或相通，或者说二元认知的瓦解产生出一些新的东西，然而，所生即是空，所生从未生。觉醒之花生出新的认知，你可以称之为永恒的“三位一体”。神、天父或那个超乎思维的、不可知的、永恒的状态，与神圣的阴性能量——即所有变化的事物相联结。这种联结导致一种魔力般的转换，一种死亡和重生。 在吠陀教义中，这种殊胜的联结体现于两种最基本的能量：湿婆和夏克提。在历史长河中，这种联结的名相虽多有变换，但其本质未变。这种联结导致一种新的殊胜的觉知，一种崭新的世间存在方式。两极汇合，成为一种没有中心、不受限制的宇宙能量，这就是纯粹的爱。不再有所谓得到或失去，因为已经空无一物，但又圆满至极。 无论是美索不达米亚的神秘学院、巴比伦人和亚述人的精神文化、古埃及的宗教、古非洲的努比亚和凯马特文化、全世界的萨满传统或土著文化、古希腊的神秘主义、亦或诺斯底教、非二元论者、佛教、道教、犹太教、拜火教、耆那教、穆斯林教、基督教，都可以发现其共通之处就是他们最高深的精神领悟，都能指引其信徒去体悟三摩地。 三摩地这个词的本义就是指那个体悟到万物同一的状态，也就是联结，你自身各方面的联结。但是不要将关于三摩地的真正体悟混淆为知识层面的理解。是你的寂静和空性联结了生命螺旋的各个层级。正是通过这些关于三摩地的古老教义，人类才能去了解所有宗教的共同根源，并再一次与生命螺旋、大灵、法或道达成一致，生命螺旋是从微观通向宏观的桥梁，也是从 DNA 通向内在的能量莲花，进而通过脉轮到达星系旋臂的桥梁。灵魂的各个层级都通过这个螺旋显现出来，如永恒的旋臂，存在着，探索着。真正的三摩地就是体悟到“自我”的各个层次和灵魂的各个层级都具有空性。生命螺旋就是二元纠缠和生死轮回的永恒运转。有时，我们忘记了自己与生命本源相联结。我们的眼界非常狭窄，把自己局限为一种在地球上爬动的生物，只是再一次完成了回到本源的旅程，回到那个无处不在的中心。 庄子说：“当没有了此和彼的对立，也就得到了道的精髓，站在了生命螺旋的中心，然后就可以目睹万物之无穷。”那则古老的咒语“唵嘛呢叭咪吽”蕴含着一种诗意。当一个人觉醒或体悟到莲花之中自有珍宝，则其本性就会从灵魂中醒来，从真相中醒来，这也就是真相本来的样子。用赫密斯公理“在上如在下，在下如在上”，我们可以类比理解思索和静止、相对和绝对之间的关系。 有一个方法可以理解三摩地的非概念性，那就是用黑洞来类比。在传统理论中，黑洞被描述为一个重力极强的空间，以至于光和所有物质都无法逃离。而新理论假定所有的物体，从最小的微观粒子到大的宏观构造如星系，在其中心都有一个黑洞或神秘的奇点。按这个新的理论，我们将那个无处不在的中心比作黑洞。在佛教的禅宗，有许多诗词和公案可以让我们直接面对那个无门之门。只有穿过那个无门之门，才能体悟三摩地。 黑洞的“事件视界”是一个时空界限，这个界限之内的事物无法被界限之外的观察者看到，也就是说，“事件视界”之内发生的一切对你来说都是未知。可以说黑洞的“事件视界”与无门之门非常类似，也就是“有我”和“无我”之间的临界。一旦穿过“事件视界”，就不再有“我”。在黑洞的中心就是一维的“奇点”，这个无穷小的点却拥有无数个太阳的质量。虽然拥有无穷大的质量，但它却是比沙粒还要小得多的极小宇宙。“奇点”是超越时空概念的深奥存在。按照物理学理论，那里没有运动，也不存在物质。 总之，它不属于知觉世界，但也不能简单描述为静止，它超越了运动和静止。当你体悟到这个中心无处不在又并不存在，二元对立就消失了，即空即有，即生即灭。这个玄妙至极的中心点，你可以称之为持续运动的静止，或包含万物的虚空。道家的老子曾说：“玄而又玄，众妙之门。”作家和比较神话学大师约瑟夫•坎贝尔描绘了一个轮回的图符，也属于永","date":"2021-12-03","objectID":"/2021-12-03-samadhi-2/:0:0","tags":["Samadhi"],"title":"非你所想","uri":"/2021-12-03-samadhi-2/"},{"categories":["Thinking"],"content":" 你永远不可能真正自由，因为无论你去哪里，你的监狱都如影随形。 — 纪录片《三摩地》 三摩地是一个古老的梵语词汇，现代没有与之含义相同的词了。要制作一部关于“三摩地”的影片，会遇到一个重大的挑战。“三摩地”指的是某种在思维层面无法表达的东西。这部影片只是我自己心路历程的展示。目的不是要给你讲解“三摩地”，也不是要给你洗脑，而是要启发你去直面你的本性。现在，“三摩地”比以往任何时候都更重要。在现在这个时代，我们不仅忘记了“三摩地”，而且已经忘记了我们曾忘记了什么。这种“忘记”是一种幻象，是自我的迷失。 身为人类，我们大部分人都淹没在日常生活中，很少想过我们是谁？我们为什么来到这里，我们要去往哪里？我们大部分人从没体会过真我、灵魂，或是佛陀所说的“了知”。它超越了各种名相，超越了思维。于是，我们就把“自我”局限于我们的身体。有意或无意地，我们会害怕我们这个肉身，也就是我们所理解的那个“我”，会死亡。 在当今世界，很多人进行宗教或精神的练习，借用瑜伽、祈祷、冥想、颂咒或其它仪式，这些人绝大部分是在进行某种局限性的技能练习。也就是说他们只是在建构“自我”。探寻和练习并不是问题所在，认为自己已经在这些外在形式上找到了答案才是问题所在。 大部分的精神追求在形式上与随处可见的病态想法并无二致。这是内心深处的一种焦虑。不只要生而为人，更要像人一样活着。“自我”在建构时想要更多金钱、更多权力、更多的爱、更多的一切。那些走在所谓精神追求道路上的人也想要更精神化、更清醒、更淡然、更平和，更觉醒。你观看此影片的危险之处就是你的思维想要获得“三摩地”，更危险的是，你认为自己已经获得了“三摩地”。每当你想要得到什么东西的时候，就可以确定这是“自我”建构在起作用。三摩地不是要帮你得到或增加什么。 要体悟到三摩地，就要在你死亡之前先学会死亡。生和死，如同阴和阳，是一个不可分割的连续体。持续地进行，没有开始，也没有结束。当我们拒绝死亡，也就拒绝了生存。当你直接体验到你到底是谁，也就不会再害怕生或死。 我们的社会和文化告诉我们自己是谁，同时，我们也在内心深处无意识中成了那些生理性的渴望或厌恶的奴隶，它控制着我们如何选择。自我建构不过是一种不断重复的冲动，是一种趋势。我们的精神一旦选择了一条路，就不断去重复那条路，不论它对我们的机体是有利还是有害。我们的记忆或意识有无数层级，盘旋再盘旋。当你的知觉认同了这种意识或自我建构，它就让你陷入了社会制约，或者说是一个矩阵。 我们可以意识到“自我”的某些方面，但实际上却是那些无意识的古老的路线，那些原始的生存恐惧，在驱动着整个矩阵运转。人们无休止的追求快乐和躲避痛苦的生存模式，演变为病态的行为…我们的工作…我们的关系…我们的信仰，我们的思想，以及我们的整个生活方式。就像牛一样，大多数人都在被动的奴役中生存和死亡，把他们的生命限制在矩阵之中。我们生活在狭隘的模式中。生活经常充满着巨大的痛苦，但我们从来没有想过，其实我们可以变得自由其实我们可以放弃从过去传承下来的生活方式，转而尝试内心深处埋藏已久的那种生活。 我们降生于这个世界，虽然拥有生理的身体结构，但却没有自我觉知。当你看着小孩儿的眼睛，里面没有自我的痕迹，只有清澈的空灵。长大后的人，变成了一个戴在自我意识上的面具。莎士比亚说:“世界是一个舞台，所有的男人和女人只是演员而已。”在一个觉醒的个体中，觉醒的光芒会穿越人性，穿过面具，当你一旦觉醒，就不再会认同自己的角色。你不再相信你只是自己所戴的面具。但你也不会放弃扮演你的角色。 在柏拉图完成《理想国》2400 年之后，人类仍在尝试走出柏拉图的洞穴。但事实上，我们可能比以往任何时候都更加痴迷于幻象。柏拉图曾让苏格拉底描述了一群人，他们一生都被锁在洞穴里，面向一面空墙。他们看到的只有他们背后的火光所照射的物品投射在墙上的影子。这木偶一般的影像就是他们的全部世界。据苏格拉底所说，这些影子就是囚徒们所看到的现实。即使告诉他们外面世界的样子，他们仍然继续相信那些影子就是全部世界。虽然他们也会怀疑外面还有更多的东西，但仍不愿意离开他们所熟悉的世界。 今天的人类就像洞穴里那些只能看到墙上投影的人。那些投影就像是我们的思想。思想的世界就是我们所唯一了解的世界。但是还有另一个世界，超越了思想，超越了二元思维。你愿意走出洞穴，摒弃所有已知，去发现你到底是谁吗？ 要体验三摩地的状态，就需要将注意力从那些影子上移开，从思想上移开，去面向光明。当一个人已经习惯了黑暗，那么他们必须逐渐地去适应光明。就像适应任何新模式一样，这需要时间和努力，需要心甘情愿的去探索新世界，摆脱旧世界。思维可以被比作意识的陷阱，迷宫或监狱。并不是说你在监狱里，而是你自己就是监狱。 监狱是一种幻象。如果你认同迷失的自我，那么你就是在沉睡。一旦你意识到了这个监狱，而试图逃离这种幻象，那么你还是将幻象当作了真实，你仍然在沉睡，只是现在梦幻变成了一场噩梦。你就会永远追逐或逃离那些影子。三摩地正是从分离的自我或自我建构的梦幻中觉醒。三摩地正是从对监狱的认同中觉醒，这个监狱就是“我”。你永远不可能真正自由，因为无论你去哪里，你的监狱都如影随形。 觉醒并不意味着摆脱思维或矩阵，恰恰相反当你不认同它时，你才能更充分地体验人生这出戏，享受这场表演，无欲无惧。在古代教义中，这被称为利拉的神圣游戏：二元世界中的游戏。 人类的意识是一个连续体。在一端，人类认同这个物质性的我。在另一端，就是三摩地——自我的终结。在这个连续体中，我们朝三摩地的方向所迈出的每一步，都会为我们减少一些痛苦。减少痛苦并非指生命没有痛苦了。三摩地超越了苦与乐的二元对立。也就是说，减少了思维，减少了自我臆造的对各种遭遇的抗拒，正是这种抗拒导致了痛苦。即使是短暂地体会三摩地，也能让你看到连续体的另一端有什么。看到除了这个物质世界和自我利益之外，还有另外的东西。 当在三摩地中确实终结了自我的架构时，就不再有自我思维、自我概念，和二元对立，但还有”本我“、”乐知“或”无我“。于此空性，即现般若或智慧之光，体悟到内在的我远远超越二元世界，超越整个连续体。这个内在的我是永恒的，不生不灭，不增不减。觉醒就是生命的原始螺旋、不断变化的外在世界或承载时间的莲花，与永恒本我的融合。当你不再认同自我，你内在的能量就如同持续展开的花朵一样生长，并成为时间维度与无时间维度之间的生命桥梁。 体悟到本我，只是进入觉醒之路的开始。在成功地将三摩地融入生活的其他方面之前，大部分人将会在冥想中，无数次地体验与失去三摩地。有一种情况并不罕见：在冥想或自我探寻中，洞察到自我本性，然后发现自己又再次落入旧的模式，忘记了自己到底是谁。 要在生命中每一个方面和自我的每一个方面都体悟到寂静或空性，就要让内心变得空寂，随万物舞动。寂静并不是与运动相分离的某种事物。也不是运动的对立面。在三摩地中，寂静与运动是同一的，形相与空性是同一的。这对思维而言是不可理解的，因为思维的世界是二元的。 西方哲学之父勒奈·笛卡尔有句著名的格言：“我思故我在。”这句话最清楚不过地概括了文明的衰落，以及对洞穴墙壁上投影的绝对认同。笛卡尔的错误，就像几乎所有人类的错误一样，将思想与存在画上等号。 笛卡尔在他最著名论文的开篇写道，几乎所有的事情都可以被怀疑；可以怀疑感官，也可以怀疑思想。如同佛陀在《迦罗摩经》中所说，为了探究真相，人们必须怀疑所有的传统、经典、教义，以及思维和感观中的所有内容。这两个人都是以极大的怀疑论开始探索，但不同的是，笛卡尔在思想层面便停止探究，而佛陀却更深入，他的探究穿越了，思维的最深层。或许，如果当时笛卡尔超越了他的思维层面，他或许就能体悟到真实本性，那么当今的西方意识也就完全是另外一个样子了。 但事实是，笛卡尔描述了一个邪恶的魔鬼，它使我们困在幻象的面纱之下。笛卡尔并没有认识到这个邪恶的魔鬼是什么。如同《黑客帝国》这部电影所描述的，我们全都被连接在某种精心制作的程序中，从而只看到一个虚幻的世界。在这部电影里，人类生活在矩阵之中，在另一个层面上，他们只是电池，把自己的生命之能输送给机器，机器则用人类的能量维持自己的运转。 人们总是想把世界的状况或自己的不悦归咎于自身之外的事物。或许是某个人，或某个团体、某个国家、宗教或某个掌控者，比如笛卡尔的恶魔，或《黑客帝国》中的智能机器。讽刺的是，笛卡尔正是用他所设想出来的恶魔来定义他自己的。当你体悟到三摩地，你就会明白，的确有一个掌控者，的确有一台机器和一个恶魔在日复一日地过滤你的生活。这台机器就是你。 你的自我结构是由许多微小的制约性子程序或小心魔组成的。一个小心魔渴望食物，另一个渴望金钱，还有的渴望身份、地位、权力、性、亲昵。还有一个心魔想要得到他人的注意或重视。欲望是无止境的，永远不会满足。 我们花很多的时间和精力粉饰我们的监狱，屈服于外界压力而改善我们的面具，满足着这些小心魔，使他们越来越壮大。像吸毒者一样，我们越是想要满足这些小心魔，我们的心魔也越来越多。解脱之道不是自我提升，也不是满足自己的各种心魔，而是完全放弃自己的所有心魔。 有些人担心，唤醒自己的真实本性，将意味着失去自己的独特个性以及对生活的享受。其实恰恰相反，只有自我的束缚被接触时，灵魂的独特个性才能显露出来。因为我们还在矩阵中沉睡，所以我们大部分人从来都不知道灵魂真正想表达什么。 通往三摩地之路需要冥想，既要观察这个变化无常的被束缚的自我，又要体悟你恒常不变的真实本性。当你达到寂静的状态，也就是你存在的本源时，就安静地等待进一步的指示，而不必要求外在世界必须改变。不是自我的意志，而是更高的意志会自动执行。 如果你的思维只是试着改变外在世界来符合你所认为的探寻之路应有的样子，这像为了改变镜中","date":"2021-11-30","objectID":"/2021-11-30-samadhi-1/:0:0","tags":["Samadhi"],"title":"自我迷失","uri":"/2021-11-30-samadhi-1/"},{"categories":["Coding"],"content":"区块链是一个分布式数据库，任何人都可以读取的它的区块数据。区块链是不可变的，意味着一旦将区块添加到链中，就只能在使链的其余部分无效的情况下才能对其进行更改，这就是加密货币基于区块链来实现的原因。 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:0:0","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"区块和链 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:1:0","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"区块 区块链允许我们检测何时有人操纵了任何先前的区块，如何确保完整性呢？每个区块都根据前一个区块的哈希值，结合区块内的其他内容计算出自己的哈希值，作为该区块的唯一标识。 const SHA256 = require(\"crypto-js/sha256\"); class Block { constructor(timestamp, data, previousHash = \"\") { this.timestamp = timestamp; this.data = data; this.previousHash = previousHash; this.hash = this.calculateHash(); } calculateHash() { return SHA256( this.timestamp + JSON.stringify(this.data) + this.previousHash ).toString(); } } ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:1:1","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"链 但第一个区块是特殊的，它没有前一个区块，我们称它为创世区块。 class Blockchain { constructor() { this.chain = [this.createGenesisBlock()]; } createGenesisBlock() { return new Block(\"01/01/2021\", \"Genesis block\", \"0\"); } getLatestBlock() { return this.chain[this.chain.length - 1]; } addBlock(newBlock) { newBlock.previousHash = this.getLatestBlock().hash; newBlock.hash = newBlock.calculateHash(); this.chain.push(newBlock); } isChainValid() { for (let i = 1; i \u003c this.chain.length; i++) { const currentBlock = this.chain[i]; const previousBlock = this.chain[i - 1]; if (currentBlock.hash !== currentBlock.calculateHash()) { return false; } if (currentBlock.previousHash !== previousBlock.hash) { return false; } } return true; } } isChainValid 方法用于验证区块链是否被篡改。若有人想要篡改区块链上的某个区块，他必须要更改这个区块之后的所有区块，才能确保区块链仍是完整的。 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:1:2","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"工作量证明 现在，我们来总结上面的区块链中的问题： 添加区块非常容易，攻击者可大量添加垃圾区块 篡改区块并不会耗费多少时间 结合上面两条可造出最长链 … 如果区块的添加需要付出大量的算力成本，就可以在动机层面就杜绝攻击，区块链中这种机制叫工作量证明。简单来说，就是只添加哈希值满足特定条件的区块。 如果你想添加一个区块，首先需要付出算力，让你的区块的哈希值满足特定条件： class Block { constructor(timestamp, data, previousHash = \"\") { this.timestamp = timestamp; this.data = data; this.previousHash = previousHash; this.hash = this.calculateHash(); this.nonce = 0; } calculateHash() { return SHA256( this.timestamp + JSON.stringify(this.data) + this.previousHash + this.nonce ).toString(); } mineBlock(difficulty) { while ( this.hash.substring(0, difficulty) !== Array(difficulty + 1).join(\"0\") ) { this.nonce++; this.hash = this.calculateHash(); } console.log(\"BLOCK MINED: \" + this.hash); } } mineBlock 可筛选出的区块是哈希值的前 difficulty 位均为 0 的区块。通过调整 difficulty 的值，可以控制添加新区块的时间间隔： constructor() { this.chain = [this.createGenesisBlock()]; this.difficulty = 2; } addBlock(newBlock) { newBlock.previousHash = this.getLatestBlock().hash; newBlock.mineBlock(this.difficulty); this.chain.push(newBlock); } 在比特币中，大约每 10 分钟才会添加一个新的区块，而这个计算有效哈希的过程被称为挖矿。 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:2:0","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"交易和矿工奖励 当区块链中储存的信息为转账信息时，区块链就成 \u0008 了分布式账本。 class Block { constructor(timestamp, transactions, previousHash = \"\") { this.timestamp = timestamp; this.transactions = transactions; this.previousHash = previousHash; this.hash = this.calculateHash(); this.nonce = 0; } calculateHash() { return SHA256( this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce ).toString(); } } class Transaction { constructor(fromAddress, toAddress, amount) { this.fromAddress = fromAddress; this.toAddress = toAddress; this.amount = amount; } } 我们的区块链中只能在一个区块中存储 1 个交易，并且矿工没有任何奖励，我们来解决这个问题。 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:3:0","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"数字签名 之前写完的，这部分内容不知啥时候弄丢了，打算重写。。。 ","date":"2021-05-25","objectID":"/2021-05-25-blockchain/:4:0","tags":["Blockchain"],"title":"单机版区块链","uri":"/2021-05-25-blockchain/"},{"categories":["Coding"],"content":"Docker 包括三个基本概念: Image(镜像)、Container(容器)、Repository(仓库)，理解了这三个概念，就理解了 Docker 的整个生命周期。 ","date":"2021-05-02","objectID":"/2021-05-02-docker/:0:0","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"基本概念 Docker 里的基本概念: Docker里的基本概念Docker里的基本概念 \" Docker里的基本概念 Image(镜像): 镜像类似于创建虚拟机时只读的系统镜像文件 Container(容器): 容器可类比于可以运行的虚拟机，容器可以被创建、启动、停止、删除、暂停等。 Repository(仓库): 仓库是集中存放镜像文件的地方 tar 文件: 类似于 vmware 中的 vmdk 文件 Dockerfile: 定义镜像如何构建的配置文件 镜像与容器类似对象与实例的关系，一个镜像可以创建多个容器 ","date":"2021-05-02","objectID":"/2021-05-02-docker/:1:0","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"实战 在 Docker 官网注册好账号后，进入 play-with-docker 添加一个新的实例，就会进入 ssh 页面。 ","date":"2021-05-02","objectID":"/2021-05-02-docker/:2:0","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"创建容器 搜索远程仓库中的 nginx 镜像 $ docker search nginx 从远程仓库拉取 nginx 镜像, 可以在 dockerhub 中查指定版本的拉取命令 $ docker pull nginx 查看本地已有的镜像: $ docker images 用镜像创建容器, -d 指定后台运行, -p 指定外，内端口映射 $ docker run -d -p 80:80 nginx play-with-docker 的网页中出现了可点击的 80 字段，可以再启动一个外部 81 端口的映射 $ docker run -d -p 81:80 nginx ","date":"2021-05-02","objectID":"/2021-05-02-docker/:2:1","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"修改容器 查看正在运行的容器信息 $ docker ps 通过容器 ID 进入外部 81 端口的容器 $ docker exec -it 80fca9b9217d bash $ cd usr/share/nginx/html \u0026\u0026 ls 里面的 index.html 就是外部 81 端口网页中显示的 html, 修改这个文件 cat index.html echo hello \u003e index.html 强制刷新浏览器，网页内容为 “hello” 修改成功 $ exit 退出容器后，删除外部 80 端口容器，我们不用这个未修改的容器 $ docker rm -f 42a0565b5ba8 commit 构建镜像 将修改后的 81 端口容器重新保存为镜像后，启动新的 82 端口容器 docker commit 80fca9b9217d m1 docker images $ docker run -d -p 82:80 m1 这是对 commit 的实践，符合预期，另一种构建镜像的方式是使用 Dockerfile Dockerfile 构建镜像 $ vim Dockerfile 按照 dockerfile 语法写配置，FROM 指定新镜像的基础镜像，ADD 将当前文件夹下的所有文件拷贝到指定目录 FROM nginx ADD ./ /usr/share/nginx/html/ $ vim index.html hello, 83 $ ls Dockerfile index.html 以当前目录的 Dockerfile 作为镜像构建配置文件 $ docker build -t m2 . $ docker run -d -p 83:80 m2 容器启动后就可以网页查看了效果了, 网页内容为 “hello, 83” ","date":"2021-05-02","objectID":"/2021-05-02-docker/:2:2","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"导出镜像 $ docker save m2 \u003e m2.tar 删除镜像 m2 $ docker rmi m2 提示 container 0618f427bb2b 正在用这个镜像, 需要先删除容器 $ docker rm -f 0618f427bb2b $ docker rmi m2 $ docker images m2 镜像删除了，用 m2.tar 重新生成 m2 镜像 $ docker load \u003c m2.tar $ docker images ","date":"2021-05-02","objectID":"/2021-05-02-docker/:2:3","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Coding"],"content":"补充 到这里，我们已入门 docker，其他内容待补充。。。 参阅资料 10 分钟，快速学会 docker Docker 从入门到实践 ","date":"2021-05-02","objectID":"/2021-05-02-docker/:2:4","tags":["Docker"],"title":"Docker 极速入门","uri":"/2021-05-02-docker/"},{"categories":["Theory"],"content":" 在可计算性理论中，如果一系列操作数据的规则(如指令集、编程语言、细胞自动机)可以用来模拟任何图灵机，则称该系统是「图灵完备」的或能做「通用计算」的。 – wikipedia 通用计算(图灵完备)是计算能力的体现，意味着解决所有可计算问题的能力。在理论上却不难实现，可能的一个原因是计算能力是传递关系：如果 A 能模拟图灵机，而 B 能模拟 A，则 B 能模拟图灵机。 ","date":"2021-01-30","objectID":"/2021-01-30-tag-system/:0:0","tags":["Recursion","Turing Machine"],"title":"一些通用计算模型","uri":"/2021-01-30-tag-system/"},{"categories":["Theory"],"content":"标签系统 图灵机由纸带，读写头，控制规则，状态表四个部分组成。标签系统(tag system)是一个类似图灵机的计算模型，它是一套字符串的转换规则：反复在一个字符串的末尾添加部分字符并在开头处删除部分字符(控制规则)。于是，标签系统会朝着字符串的末尾“移动”(读写头)。 标签系统可表示为三元组 (m, A, P)，其中： m 是删除数 A 是有限的符号字母表(状态表)，其中有特殊的停机符号 P 是添加字符的规则集合 Tag system m: 2 A: {1,2,3,H} P: 1 --\u003e 3321H 2 --\u003e 331 3 --\u003e 33 Computation Initial word: 211 1331 313321H 3321H33 21H3333 H3333331(halt). 当初始全为 3 的字符串时，程序永不停机，这意味着标签系统是图灵完备的。 ","date":"2021-01-30","objectID":"/2021-01-30-tag-system/:1:0","tags":["Recursion","Turing Machine"],"title":"一些通用计算模型","uri":"/2021-01-30-tag-system/"},{"categories":["Theory"],"content":"循环标签系统 循环标签系统(cyclic tag system)是一类有额外限制的标签系统： 循环标签系统的字符只有 0 和 1 规则只在当前字符串以 1 开始时才生效 删除数是 1 这些约束对于支持通用计算来说过于苛刻了，作为补偿，允许循环尝试生成规则： Cyclic tag system m: 1 A: {0, 1} P: 1 --\u003e 011, 10, 101 Computation Initial word: 1 P word -------- -------- 011 1 10 011 101 11 011 1101 10 101011 101 0101110 011 101110 ... ... 字符串为空时，程序才会停机。而这个程序永不停机，因为 word 中一直有 1，这意味着循环标签系统也是图灵完备的。它的规则非常简单，不过它的行为却很复杂：接下来发生什么并不明显，字符串何时扩张，何时收缩？只能运行程序，然后观察它的行为。 ","date":"2021-01-30","objectID":"/2021-01-30-tag-system/:2:0","tags":["Recursion","Turing Machine"],"title":"一些通用计算模型","uri":"/2021-01-30-tag-system/"},{"categories":["Theory"],"content":"Rule 110 一维元胞自动机建立在一行无限长的格子序列上，它的规则是： 每个格子有黑白两种状态 每个格子下一刻的状态由此刻的自身状态和左右邻居的状态共同决定 依照上述规则，有 256 种可能情况，若规定黑色为 1，白色为 0： Rule110Rule110 \" Rule110 上图对应 01101110(二进制)，这就是 Rule 110(十进制)，它也是图灵完备的，因为它被证明可以模拟循环标签系统。下面做简单解释： 在元胞自动机中，有的结构会随时间做周期性地“移动”，它们被称为“滑翔机”或“飞船”： Rule110中的滑翔机Rule110中的滑翔机 \" Rule110中的滑翔机 上图是 Rule 110 中已发现的所有滑翔机，以及一个滑翔机枪：每周期发射一次 A 和 B 滑翔机。这里 展示了用通过特定排列的滑翔机来模拟 P: 1 --\u003e 11, 10 的循环标签系统，这不是完成通用计算的高效方式，但对简单的细胞自动机来说这仍是一项令人印象深刻的技术成果。比起二进制的字符串，图像可能更容易让人观察计算行为的普遍规律。 如果我们建立了宇宙的完整模型，是否意味着我们没有自由意志了呢？“Computational irreducibility ” 意味着，就算你知道了一切规则，你可能也无法提前预测这些规则将会做什么 — 唯一的办法是运行这些规则看看它们到底会做出什么来。 推荐阅读 《The Recursive Universe》- William Poundstone Universality in Elementary Cellular Automata Cyclic Tag System in Rule 110 - escom 从冯·诺依曼“自复制自动机”到生命雏形 复杂的极限在哪里 ","date":"2021-01-30","objectID":"/2021-01-30-tag-system/:3:0","tags":["Recursion","Turing Machine"],"title":"一些通用计算模型","uri":"/2021-01-30-tag-system/"},{"categories":["Theory"],"content":"本文翻译自 stereobooster 的博客文章：metaprogramming ，少量删改。完整内容参阅原文。 ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:0:0","tags":["AST"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Theory"],"content":"什么是元编程 不好的是，没有一个达成共识的单一定义。让我们参阅一下： 元编程是一种编程技术，指计算机程序具有将其他程序视为其数据的能力。 – wikipedia 元编程是指程序具有了解自身或操纵自身的多种方式。 – stackoverflow 上的流行答案 “支持元编程”意味着用户可以有效修改该语言内置语法(例如 Lisp 的宏)或扩展该语言常规语法(例如 C 的预处理程序)。 – rosettacode 没有一个很好的定义，让我们看一些例子。当人们谈论元编程时，他们可能指的是： macros in Lisp (1960) preprpcessor in C (1973) hygenic macros in Scheme (1986) C++ templates (1986) “Dynamic” metaprogramming in Smalltalk (1980) and Ruby (1995-2005?) Reflections in Java (1997) ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:1:0","tags":["AST"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Theory"],"content":"两类元编程 元编程大致分为两类： 一种是(编译时)作为源代码(例如宏，预处理器，模板)，通常称为“宏” 另一种是(运行时)基于“OOP 技巧”(例如动态调度和反射)以支持其他行为，这没有名字，我把它称为“动态” compile time runtime macros in Lisp ? + Preprocessor, templates + Dynamic metaprogramming + ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:2:0","tags":["AST"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Theory"],"content":"动态元编程 元编程是编写在运行时操纵(自身)语言结构的代码。 – Ruby 元编程 元编程在 Ruby 中比在其他的动态类型语言中更常用，尤其是在 Rails 中，例如：Path and URL Helpers 。动态元编程的缺点是“事物”没有源代码：你看到了一个函数，但是你不知道它的定义位置，这破坏了“grep test ”。另一个缺点是它趋向于变慢，例如，参见 Rails / DynamicFindBy 。 编程语言： Ruby JavaScript Python 2 , Python 3 主要用法： 消除重复代码(DRY)，例如，David Beazley 在演讲中 展示了很多例子。 创建嵌入式领域特定语言(EDSL)，Martin Fowler 称它们为内部 DSL 。例如，Sass (能转换为 CSS 的 Ruby EDSL)，Haml (能转换为 HTML 的 Ruby EDSL)，Active Record 查询接口(能转换为 SQL 的 Ruby EDSL)，最重要的是 Rake(替代 Make 的 Ruby EDSL)。 “扩展语言” 关于扩展语言 如何扩展语言？可以添加更多关键字(扩展词法)，也可以添加更多关键字的组合规则(扩展语法)。 我们很容易添加更多关键字，例如，定义新的函数、模块、变量，但并不是所有种类 – 仅限于语言语法允许使用的标识符(例如，我不能定义 :?:)。在 Ruby 和 Python 中，可以重载运算符(+,-,\u003e,\u003c 等)，但不能定义新的运算符。据我所知，这些语言均不允许我定义新的语法规则，例如，我无法定义自己的 if/else 版本。 但程序员们总能找到一种方法来解决这个问题 – 可以重用现有的语法，让它看起来像是另一种语法。例如，在函数式语言中，有一个漂亮的“模式匹配”的概念。OCaml: match value with | pattern -\u003e result | pattern -\u003e result 或是 Scheme: (let ((l '(hello (world)))) (match l ((x y) (values x y)))) 这是在 JavaScript 中的实现： const { matches } = require(\"z\"); const result = matches(1)( (x = 2) =\u003e \"number 2 is the best!!!\", (x = Number) =\u003e `number ${x}is not that good`, (x = Date) =\u003e \"blaa.. dates are awful!\" ); 这是一个旧语法，但如果你细心，它看起来就像 OCaml 中的模式匹配。在幕后，它使用 toString 检查实际的代码，因为以前没有一等公民的反射对象。另一个值得注意的技术是“链式”(例如 jQuery 和 Active Record 查询接口)。 ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:2:1","tags":["AST"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Theory"],"content":"Macros(宏) 宏是一个宽泛的范畴，让我们看一下使用示例来了解这一点。 语法扩展 在 Lisp 中 if/else 表达式像这样： (if condition (print 1) (print 2)) 定义具有相同结构的函数很容易： (my-if condition (print 1) (print 2)) 关键在于，Lisp 中的函数是立即执行的。这意味着在将参数传递给函数之前，它就会执行 then 和 else 两个分支，这就是宏的作用。有了宏，就可以定义自己的 if 版本，像你期望的那样。 另请参阅： Idris Syntax Extensions Racket Module Syntax , Racket Macros DSL JSX 是 ECMAScript 中类似 XML 的语法扩展，没有任何定义的语义 – Draft: JSX Specification 它本质上是一个 DSL。而负责编译它的 Babel 插件是一个预处理器。你可以使用其他的元编程技术来实现同样的结果 – 参见 JSX 的替代方案 。 多态性 …多态语言，其中一些值和变量可能有一个以上的类型。多态函数是指其操作数(实际参数)可以有一个以上类型的函数。多态类型是指其操作可以适用于一种以上类型的值的类型。 – On Understanding Types, Data Abstraction, and Polymorphism 令我惊讶的是: 动态类型语言，是非常灵活的(但也很容易给自己找麻烦)。 静态类型的语言，具有完全的多态性支持，如 OCaml，Haskell 等。 没有多态性或在多态性上有一定限制的静态类型语言(Pascal，Go)。 最后一类编程语言可以使用元编程来实现类似多态性的东西(“提高灵活性”)。在 GO 中，没有参数多态(或类型参数，或泛型)，于是人们创造了解决方法，例如，gengen (类似的解决方案 genny ，generic ，gen )。 package list import \"github.com/joeshaw/gengen/generic\" type List struct { data generic.T next *List } 然后，您需要运行预处理器： $ gengen github.com/joeshaw/gengen/examples/list string 你会得到类型准确的代码: package list type List struct { data string next *List } 另请参阅：Who needs generics? Use … instead! , The Next Step for Generics. DRY 模板元程序员利用这种机制来提高：源代码的灵活性和运行时性能。 – Walter E. Brown “Modern Template Metaprogramming: A Compendium, Part I” 在 C++中，有函数重载(即一种多态)，但它会产生很多重复： double abs(double x) { return (x \u003e= 0) ? x : -x; } int abs(int x) { return (x \u003e= 0) ? x : -x; } 你可以编写函数模板： template\u003ctypename T\u003e T abs(T x) { return (x \u003e= 0) ? x : -x; } ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:2:2","tags":["AST"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Theory"],"content":"性能 通常认为，在编译时进行宏扩展可以提高性能。对我来说这很合理，但我没有很好的例子。 相关：Compile-time reflection and compile-time code execution in Zig. ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:2:3","tags":["AST"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Theory"],"content":"宏和类型 Lisp(和 Scheme)宏非常强大，但它们不能与静态类型检查器一起很好地工作。假设我们有确保能够终止的宏，并且能在编译时扩展(语法糖)并进行类型检查生成的代码，下一个问题是在生成的代码中报告类型错误，这也会很混乱。 有多种尝试使宏与静态类型更好地配合使用，例如： Hackett Inferring Type Rules for Syntactic Sugar 参阅资料 Metaprogramming 谈元编程与表达能力 Emacs 之魂：宏与元编程 ","date":"2021-01-21","objectID":"/2021-01-21-metaprogram/:2:4","tags":["AST"],"title":"[译]元编程","uri":"/2021-01-21-metaprogram/"},{"categories":["Theory"],"content":"TCP 在不可靠的 IP 协议之上实现了可靠性，使得我们在开发上层应用时，不必关注网络传输的种种复杂性。可靠，指的是采用一系列技术来保障数据在发送方和接收方是一致的。我们了解下 TCP 如何实现可靠性。 ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:0:0","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Theory"],"content":"信道不可靠 需要解决的问题是，数据在信道上传输时，不总是符合预期，例如出现以下情况： 损坏：发送 10，11，接收到 10，10 乱序：发送 10，11，接收到 11，10 丢失：发送 10，11，只接收到 10 …… 我们看 TCP 是怎么解决这些问题的，学习它的做法，这可以作为一类问题的处理思路。 TCP报文头TCP报文头 \" TCP报文头 解决问题的办法其实写在了 TCP 报文头上，下面具体分析： ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:1:0","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Theory"],"content":"数据损坏 检验和机制：Checksum 用于校验报文是否在传输过程中发生了变化，计算方法： 1.将报文中的 Checksum 置零 2.基于整个报文(头部 + 数据部分)计算出 Checksum 接收方收到报文后，计算出 Checksum 并与报文中的 Checksum 对比。若一致，数据没有损坏。不一致，数据损坏，丢掉数据包。 ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:1:1","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Theory"],"content":"乱序和冗余 字节编号机制：建立连接时，发送方和接收方各自初始化一个seq(Seq...) 值，并且让对方知道，这就是为什么 TCP 连接时需要三次握手。发送方每次发送数据，都是在自己前一次的 seq 值上加本报文的 data 字节数，得到本报文的 seq 值。接收方接收到多个报文后，按 seq 的值对所有数据包进行升序排列，就能得到有序的报文。并且接收方可以判断接收的数据包之间是否有间隔或冗余。 ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:1:2","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Theory"],"content":"数据丢失 确认应答机制：接收方收到发送方的报文后，将 ack(Ack) 传递给对方，ack 的值表示接收方期望收到的下一次 seq 值。ack 的计算与发送方报文的 ack，ACK 无关(对\"确认\"进行再确认无意义，在不可靠的信道上，双方不可能达成一致性确认，两军问题 )，这下再看 TCP 三次握手的图就清晰多了。 超时重传机制：报文在信道中丢失了，发送方就收不到对方的 ack。发送方在发送报文后，启用定时器(RTO)。一定时间没有返回就重传报文，就要知道报文在两方的往返时间(RTT)，根据 RTT 设计 RTO。而 RTT 实际上是波动的，当 RTO \u003c RTT 时，就造成了数据冗余。 快速重传机制：以数据驱动重传，例如发送方发送了 seq=1、 seq=2、 seq=3、 seq=4 的报文，其中 seq=1 的报文丢失了，发送方会收到三个连续的 ack=1，此时就触发快速重传机制，重传 seq=1。 ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:1:3","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Theory"],"content":"基本可靠 上面的设计在简单场景中是基本可靠的，即确保了字节流在通信双方完全相同。在复杂的场景中，TCP 还有很多其他的机制来实现可靠性。例如，造成数据丢失的原因有很多： 发送方对数据的处理效率高于接收方，接收方达到处理能力极限，而发送方无法感知，依然大量传递数据，就造成了数据丢失。(流量太快) 发送太多的数据造成数据在信道中过于拥堵，也会造成数据丢失。(流量太多) 这两种情况都会触发 TCP 的重传机制，而重传只会丢失更多数据，应对这两种情况，我们需要更多的机制： 流量控制机制：找到 TCP 两方中效率低的一方一次能处理的数据峰值，用 Window 表示，发送方根据 Window 的大小发送数据包，直到接收方收到所有数据包再进行下一次数据发送。 拥塞控制机制：找到信道一次能容纳的数据峰值，具体的实现涉及很多复杂的算法。 可靠性其实是一个很大的话题，有很多细节值得深究，本文只是让读者对可靠性有个基本的认识。 参阅资料 车小胖的知乎回答 seq 和 ack 号的正确理解 图解 TCP 重传、滑动窗口、流量控制、拥塞控制 ","date":"2021-01-08","objectID":"/2021-01-08-tcp/:2:0","tags":["Network"],"title":"关于 TCP, 我学到什么","uri":"/2021-01-08-tcp/"},{"categories":["Theory"],"content":"学习函数式编程总是给人一种学习哲学的错觉，Haskell 不仅定义了程序运算需要的类型，还给输入输出(IO)这样动作也定义了类型，并且把运行程序时的外部状态(RealWorld)当成函数的参数。 ","date":"2020-12-28","objectID":"/2020-12-28-monad/:0:0","tags":["Recursion","Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Theory"],"content":"IO haskell 中 IO 的类型定义： newtype IO a = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld -\u003e (# GHC.Prim.State# GHC.Prim.RealWorld, a #)) 简化表示如下， type IO a = GHC.Types.IO (World -\u003e (# World, a #)) 程序运行时，输入值需要参与到程序运算中。用函数表示输入动作： World -\u003e (# World, a #) 输出值不能再参与程序运算。用函数表示输出动作： World -\u003e (# World, () #) 在 GHCi 中用 :l 加载下面的程序文件： {-# LANGUAGE UnboxedTuples #-} import GHC.Types noExec (GHC.Types.IO a) = a inStr = noExec (getLine) outStr = noExec (putStrLn \"hello world!\") exec = GHC.Types.IO 然后用 :t inStr，:t outStr 查看类型，确实是我们说的那样。 ","date":"2020-12-28","objectID":"/2020-12-28-monad/:1:0","tags":["Recursion","Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Theory"],"content":"Monad 考虑函数与单个数值或字符之间的运算： (i -\u003e o) -\u003e i -\u003e o ghci\u003e ((+4) 2) + ((*2) 3) 12 ghci\u003e (\\x -\u003e(\\y -\u003e if x \u003e y then x else y)) 8 6 8 调用函数就能计算结果，不过这样做计算对人来说太麻烦了。 简化计算的办法是将值放在上下文环境(e)中，例如 [1,2,3]，(1,'a',3.14) 等。怎么在不破坏值的上下文前提下，应用函数完成计算呢？ f -\u003e e(i) -\u003e e(o) 换句话说，考虑 f 可能的情况，定义通用计算模型？ f = (i -\u003e o) f = e(i -\u003e o) f = e(i -\u003e e(o)) f = (e(i) -\u003e o) ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:0","tags":["Recursion","Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Theory"],"content":"Maybe 后面的讨论会用到 Maybe 类型： data Maybe a = Nothing | Just a ghci\u003e :t Nothing Nothing :: Maybe a ghci\u003e :t Just 2 Just 2 :: Num a =\u003e Maybe a ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:1","tags":["Recursion","Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Theory"],"content":"Functor 处理函数暴露，值处于上下文的情况： (i -\u003e o) -\u003e e(i) -\u003e e(o) ghci\u003e (+3) (Just 2) error ghci\u003e fmap (+3) (Just 2) Just 5 fmap 怎么实现的？模式匹配： fmap f Nothing = Nothing fmap f (Just x) = Just (f x) fmap 的动作是将上下文中的值取出，用函数处理后，重新放回上下文： class Functor f where fmap :: (a -\u003e b) -\u003e f a -\u003e f b instance Functor Maybe where fmap f Nothing = Nothing fmap f (Just x) = Just (f x) 只要能被 fmap 处理，这种上下文就是 Functor，Maybe 是 Functor ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:2","tags":["Recursion","Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Theory"],"content":"Applicative 处理函数与值处于同一种上下文的情况： e(i -\u003e o) -\u003e e(i) -\u003e e(o) ghci\u003e (Just (+3)) (Just 2) error ghci\u003e (Just (+3)) \u003c*\u003e (Just 2) Just 5 实现 \u003c*\u003e 同样用模式匹配： fmap f Nothing = Nothing fmap f (Just x) = Just (f x) Nothing \u003c*\u003e _ = Nothing (Just f) \u003c*\u003e x = fmap f x \u003c*\u003e 的动作是直接从上下文中取出函数，之后就是 Functor 的情况了，用 fmap 处理 class Functor f =\u003e Applicative f where pure :: a -\u003e f a (\u003c*\u003e) :: f (a -\u003e b) -\u003e f a -\u003e f b instance Applicative Maybe where pure = Just Nothing \u003c*\u003e _ = Nothing (Just f) \u003c*\u003e x = fmap f x 只要能被 \u003c*\u003e 处理，这种上下文就是 Applicative，Maybe 是 Applicative ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:3","tags":["Recursion","Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Theory"],"content":"Monad 处理值与函数的返回值处于同一种上下文的情况： e(i) -\u003e (i -\u003e e(o)) -\u003e e(o) 这里交换了函数和值的顺序，数据流向是从左往右的。 ghci\u003e (Just (+3)) \u003c*\u003e (Just 2) Just 5 ghci\u003e (\\x -\u003e Just (x + 3)) (Just 2) error ghci\u003e (Just 2) \u003e\u003e= (\\x -\u003e Just (x + 3)) Just 5 实现 \u003e\u003e= (发音为 bind) 同样用模式匹配： Nothing \u003e\u003e= f = Nothing Just x \u003e\u003e= f = f x \u003e\u003e= 的动作是直接从上下文中取出值，应用到函数上 class Applicative m =\u003e Monad m where (\u003e\u003e=) :: m a -\u003e (a -\u003e m b) -\u003e m b (\u003e\u003e) :: m a -\u003e m b -\u003e m b return :: a -\u003e m a instance Monad Maybe where return x = Just x Nothing \u003e\u003e= _ = Nothing Just x \u003e\u003e= f = f x 能被 \u003e\u003e= 处理，并且实现 Applicative 的行为就是 Monad。每种 Monad 至少能处理三种函数： f = (i -\u003e o) f = e(i -\u003e o) f = e(i -\u003e e(o)) 我们可以利用 \u003e\u003e= 的性质实现链式操作： ghci\u003e let add3 = (\\x -\u003e Just (x + 3)) ghci\u003e (Just 2) \u003e\u003e= add3 \u003e\u003e= add3 \u003e\u003e= add3 \u003e\u003e= add3 Just 14 IO 类型也被 Haskell 定义为一种 Monad： ghci\u003e getLine \u003e\u003e= readFile \u003e\u003e= putStrLn Haskell 为我们提供了一些用于 Monad 的语法糖，称为 do 语法： foo = do filename \u003c- getLine contents \u003c- readFile filename putStrLn contents 在这篇 文章中，我们用函数模拟了一阶逻辑， 而 Monad 是函数对结构化程序的模拟。 ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:4","tags":["Recursion","Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Theory"],"content":"补充 处理值与函数的参数处于同一种上下文的情况： (e(i) -\u003e o) -\u003e e(i) -\u003e e(o) class Func f where comp :: (f a -\u003e b) -\u003e f a -\u003e f b instance Func Maybe where comp f Nothing = Nothing comp f x = Just (f x) ghci\u003e comp (\\x -\u003e if x == (Just \"pwd\") then \"true\" else \"false\") (Just \"pwd\") Just \"true\" 这里 查阅 Maybe 的相关实现, 有时间再补充。 推荐阅读 Your easy guide to Monads, Applicatives, \u0026 Functors 关于 Monad 的学习笔记 Primitive Haskell Haskell Tutorial hackage.haskell.org ","date":"2020-12-28","objectID":"/2020-12-28-monad/:2:5","tags":["Recursion","Lambda","Haskell"],"title":"IO 和 Monad","uri":"/2020-12-28-monad/"},{"categories":["Coding"],"content":"如果你没有听说过 λ 演算，可以阅读我的这篇文章 。如果你没有编译原理相关知识，可以阅读我的这篇文章 。首先介绍调度场算法，后面的实现中会用到。 ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:0:0","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Coding"],"content":"调度场算法 调度场算法是一种将中缀表达式转换为后缀表达式的经典算法，由 Dijkstra 提出，因其操作类似于火车调车场而得名。将中缀表达式转换为后缀表达式为了处理运算符的优先级，如图： 调度场算法转换示例调度场算法转换示例 \" 调度场算法转换示例 之后，程序处理后缀表达式 output 就像玩消消乐。 ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:1:0","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Coding"],"content":"处理括号 首先后缀表达式里没有括号，所以括号不应该被输出。由于括号里一定是一个完整的表达式，可以这样修改算法。把左括号的优先级当作最低，这样括号就不会立即出栈： 1.依次按顺序读入， 读到数字：直接输出； 读到一般运算符：如果栈顶的运算符优先级不低于该运算符，则输出栈顶运算符并使之出栈，直到栈空或不满足上述条件为止；然后入栈； 读到左括号：直接入栈； 读到右括号：输出栈顶运算符并使之出栈，直到栈顶为左括号为止；令左括号出栈。 2.当读入完毕时，依次输出并弹出栈顶运算符，直到栈被清空。 这样处理后，就能让括号内的运算符优先级最高。 除括号外，在 λ 演算有语义的运算符只有 . 和函数与参数之间的空格。. 用于区分函数变量和函数体，空格表示将参数作用于函数。它们都是中缀表达式，我们用调度场算法把它们转换为后缀表达式。 ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:1:1","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Coding"],"content":"词法分析 对任意的 λ 演算表达式，只保留函数间的空格。 /** remove any space that isn't in one of the following spots: )_(, x_(, )_x, x_x, x_\\, )_\\ */ function remove_extra_spaces(str) { return str .trim() .replace(/\\s+([^\\(\\wλ])/g, \"$1\") .replace(/([^\\)\\w])\\s+/g, \"$1\"); } // all spaces are lambda application =\u003e whitespace matters function lex(str) { let tokens = remove_extra_spaces(str) .split(/(\\)|\\(|λ|\\.|\\w+|\\s+)/) .filter((t) =\u003e t != \"\"); return tokens; } lex(\" ( λ a. λ b. a ) a b \"); // [\"(\", \"λ\", \"a\", \".\", \"λ\", \"b\", \".\", \"a\", \")\", \" \", \"a\", \" \", \"b\"] ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:2:0","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Coding"],"content":"语法分析 按照调度场算法处理运算符，空格的优先级高于 .，因为函数的参数是函数。设计如下递归下降解析器 ： // shunting yard algorithm function parse(tokens) { let output = []; let stack = []; while (tokens.length \u003e 0) { let current = tokens.shift(); if (current.match(/\\w+/)) { output.push(new Var(current)); } else if (current.match(/\\s+/)) { // swap if both o1 and o2 are application stack_to_output(stack, output, () =\u003e stack[stack.length - 1].match(/\\s+/) ); stack.push(current); } else if (current == \"(\" || current == \".\") { stack.push(current); } else if (current == \")\") { stack_to_output(stack, output, () =\u003e stack[stack.length - 1] != \"(\"); if (stack.length == 0) { console.log(\"mismatched parenthesis\"); } stack.pop(); // pop off left paren } } if (stack.indexOf(\"(\") != -1 || stack.indexOf(\")\") != -1) { console.log(\"mismatched parenthesis\"); } else { stack_to_output(stack, output, () =\u003e true); } return output.pop(); } 加入运算符到后缀表达式 output function stack_to_output(stack, output, condition) { while (stack.length \u003e 0 \u0026\u0026 condition()) { let top = stack.pop(); let s = output.pop(); let f = output.pop(); output.push(top == \".\" ? new Abs(f, s) : new App(f, s)); } } 这里用到了 AST 节点，给出定义： function Var(id) { this.type = \"var\"; this.id = id; this.free_vars = new Set([id]); } function App(func, arg) { this.type = \"app\"; this.func = func; this.arg = arg; this.free_vars = new Set([...func.free_vars, ...arg.free_vars]); } function Abs(v, expr) { this.type = \"abs\"; this.var = v; this.expr = expr; this.free_vars = new Set([...expr.free_vars]); this.free_vars.delete(this.var.id); } 只有 abs 类型里的参数 var 是约束变量，例如 (λa.b) 生成的 AST 如下 Abs { type: 'abs', var: Var { type: 'var', id: 'a', free_vars: Set(1) { 'a' } }, expr: Var { type: 'var', id: 'b', free_vars: Set(1) { 'b' } }, free_vars: Set(1) { 'b' } } (λa.b) c 生成的 AST 如下 App { type: 'app', func: Abs { type: 'abs', var: Var { type: 'var', id: 'a', free_vars: [Set] }, expr: Var { type: 'var', id: 'b', free_vars: [Set] }, free_vars: Set(1) { 'b' } }, arg: Var { type: 'var', id: 'c', free_vars: Set(1) { 'c' } }, free_vars: Set(2) { 'b', 'c' } } ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:3:0","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Coding"],"content":"实现解释器 在每个 AST 节点上封装一个 stepped 布尔值，表示对应的表达式是否能够 β 规约。只有在调用函数时，才能进行 β 规约，替换掉函数里的约束变量。代码的实现思路是观察 AST 的结构，例如 (λa.b) c 能够被替换的是 (λa.b)，对应的 AST 结构是 app 里的 abs var redexes = 0; function stepper(node) { switch (node.type) { case \"var\": return { stepped: false, node: node }; case \"app\": switch (node.func.type) { case \"var\": case \"app\": let func_evaled = stepper(node.func); if (func_evaled.stepped) { return { stepped: true, node: new App(func_evaled.node, node.arg) }; } let arg_evaled = stepper(node.arg); return { stepped: arg_evaled.stepped, node: new App(node.func, arg_evaled.node), }; case \"abs\": // redex redexes++; return { stepped: true, node: substitute(node.arg, node.func.var, node.func.expr), }; } break; case \"abs\": let new_expr = stepper(node.expr); return { stepped: new_expr.stepped, node: new Abs(node.var, new_expr.node), }; } } 实现替换函数 substitute，代码的实现思路同样是观察 AST 的结构 // substitute e for x (variable) in expr function substitute(e, x, expr) { switch (expr.type) { case \"var\": return expr.id == x.id ? e : expr; case \"app\": return new App(substitute(e, x, expr.func), substitute(e, x, expr.arg)); case \"abs\": if (expr.var.id == x.id) { return expr; } else if (!e.free_vars.has(expr.var.id)) { return new Abs(expr.var, substitute(e, x, expr.expr)); } else { do { var z = rename(expr.var.id); } while (e.free_vars.has(z) || variables(expr.expr).has(z)); return new Abs( new Var(z), substitute(e, x, substitute(new Var(z), expr.var, expr.expr)) ); } } } 进行 β 规约时，约束变量的名字可能重复，这就需要使用 α 变换重命名约束变量 function rename(variable) { let [match, prefix, num] = /^(.*?)([\\d]*)$/.exec(variable); return prefix + (num == \"\" ? 1 : parseInt(num) + 1); } function variables(expr) { switch (expr.type) { case \"var\": return new Set([expr.id]); case \"app\": return new Set([...variables(expr.func), ...variables(expr.arg)]); case \"abs\": return new Set([...variables(expr.expr), expr.var.id]); } } 最后实现一个由 AST 节点重新生成 λ 演算表达式的函数 // unnecessary parenthesises uses in some abstractions function ast_to_expr(expr) { switch (expr.type) { case \"var\": return expr.id; case \"abs\": return `(λ${expr.var.id}.${ast_to_expr(expr.expr)})`; case \"app\": return ( ast_to_expr(expr.func) + \" \" + (expr.arg.type == \"app\" ? \"(\" + ast_to_expr(expr.arg) + \")\" : ast_to_expr(expr.arg)) ); } } 现在可以自顶向下的解释 λ 演算表达式的计算规则了 let expr = \"(λn. (λf. (λx. (f ((n f) x))))) (λf. (λx. x))\"; function run(expr) { let t = new Date().getTime(); let ast = parse(lex(expr)); let new_expr = stepper(ast); while (new_expr.stepped) { console.log(redexes + \": \" + ast_to_expr(new_expr.node)); new_expr = stepper(new_expr.node); } let delay = new Date().getTime() - t; console.log(\"delay: \" + delay); console.log(\"redexes: \" + redexes); console.log(\"final: \" + ast_to_expr(new_expr.node)); } run(expr); expr 中第一个表达式是数字的后继函数，第二个表达式是数字 0 1: (λf.(λx.f ((λf.(λx.x)) f x))) 2: (λf.(λx.f ((λx.x) x))) 3: (λf.(λx.f x)) delay: 10 redexes: 3 final: (λf.(λx.f x)) 可以看到经过 3 次计算后，最终的表达式是数字 1，我们实现了 λ 演算解释器！ 附：源码地址 参阅资料 算法学习笔记: 调度场算法 parkertimmins/lambda_interpreter ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:4:0","tags":["AST","Lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Theory"],"content":"程序的解释和编译通常需要经过词法分析，语法分析和生成抽象语法树等阶段。 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:0:0","tags":["AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Theory"],"content":"前置知识 算术表达式根据运算符所在的位置可以分为三种表示方法： 前缀表达式(波兰式)，如 (- (+ 3 (* 2 4)) 1)，Lisp 语言就是使用这种表示方法 中缀表达式，如 3 + 2 * 4 - 1，最适合人阅读的表示方法 后缀表达式(逆波兰式)，如 3 2 4 * + 1 -，计算机处理起来比较方便 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:1:0","tags":["AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Theory"],"content":"编译原理 为了讲清楚程序解释与编译，我们自定义一种类似 Lisp 的前缀表达式： mul 3 sub 2 sum 1 3 4 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:0","tags":["AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Theory"],"content":"语法和语义 为了完整地定义编程语言，我们需要： 语法(Syntax) ，就是程序看起来的样子(我们已经定义了)。 语义(semantics ，描述程序的含义。一些编程语言有官方的书面规范。而另一些只有一个可用的解释器或者编译器，它们的语义是 “靠实现规范” 的。 我们用 JS 代码来规范前缀表达式的语义： const OpMapper = { sum: (args) =\u003e args.reduce((a, b) =\u003e a + b, 0), sub: (args) =\u003e args.reduce((a, b) =\u003e a - b), div: (args) =\u003e args.reduce((a, b) =\u003e a / b), mul: (args) =\u003e args.reduce((a, b) =\u003e a * b, 1), }; 按照我们规范的语义，前缀表达式等价为如下 JS 代码： mul(3, sub(2, sum(1, 3, 4))); // or 3 * (2 - (1 + 3 + 4)); ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:1","tags":["AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Theory"],"content":"词法分析 词法分析将源代码中每一个有语义的字符(token)提取出来，用数组表示。 const lex = (str) =\u003e str .split(\" \") .map((s) =\u003e s.trim()) .filter((s) =\u003e s.length); const tokens = lex(\"mul 3 sub 2 sum 1 3 4\"); // tokens = [\"mul\", \"3\", \"sub\", \"2\", \"sum\", \"1\", \"3\", \"4\"] ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:2","tags":["AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Theory"],"content":"语法分析 语法描述 用 EBNF 来描述我们的程序语法： digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 num = digit+ op = sum | sub | mul | div expr = num | op expr+ 抽象语法树 确定了语法后，一开始定义的前缀表达式可以表示为如下程序树(AST)： 程序树(AST)程序树(AST) \" 程序树(AST) 尝试用 JS 代码解析这种逻辑： const Op = Symbol(\"op\"); const Num = Symbol(\"num\"); const parse = (tokens) =\u003e { let c = 0; const peek = () =\u003e tokens[c]; const consume = () =\u003e tokens[c++]; const parseNum = () =\u003e ({ val: parseInt(consume()), type: Num }); const parseOp = () =\u003e { const node = { val: consume(), type: Op, expr: [] }; while (peek()) node.expr.push(parseExpr()); return node; }; const parseExpr = () =\u003e (/\\d/.test(peek()) ? parseNum() : parseOp()); return parseExpr(); }; 程序树中每个节点都被表示为了 JS 对象，我们完成了程序的解析！ 实际上，我们开发了一个简单的递归下降解析器 。每个对象的值其实是它的 val 属性，可以通过分治法 自顶向下地对整个前缀表达式进行求值。 const evaluate = (ast) =\u003e { if (ast.type === Num) { return ast.val; } else { // Op needs parameters to be evaluated return OpMapper[ast.val](ast.expr.map(evaluate)); } }; const value = evaluate(parse(tokens)); console.log(value); // -18 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:3","tags":["AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Theory"],"content":"解释和编译 将程序转换为 AST，然后直接对 AST 求值就是程序的解释(Interpreted)，还有一种求值方式是由 AST 生成中间代码，再由别的解释器或编译器对中间代码求值，就是程序的编译(Compiled)。通过 AST 完成代码转换非常方便，只需设计转换前后的映射表，代码转换就是查表替换。 const compile = (ast) =\u003e { const opMap = { sum: \"+\", mul: \"*\", sub: \"-\", div: \"/\" }; const compileNum = (ast) =\u003e ast.val; const compileOp = (ast) =\u003e `(${ast.expr.map(compile).join(\" \" + opMap[ast.val] + \" \")})`; const compile = (ast) =\u003e ast.type === Num ? compileNum(ast) : compileOp(ast); return compile(ast); }; const newCode = compile(parse(tokens)); console.log(newCode); // (3 * (2 - (1 + 3 + 4))) 这里生成的中间代码就可以被直接被低级一些的语言解释或编译。 参阅阅读 Implementing a Simple Compiler on 25 Lines of JavaScript 解谜计算机科学 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:4","tags":["AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Theory"],"content":"由邱奇创造的 λ 演算(λ-calculus) 是世界上最小的程序设计语言。λ 演算中没有数(number)，字符串(string)，布尔型(boolean) 或任何非函数的数据类型，它只用匿名单参函数就能模拟图灵机。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:0:0","tags":["Recursion","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Theory"],"content":"λ 演算 λ 演算仅由 3 种元素组成：变量、函数 和 应用 λ演算的程序结构λ演算的程序结构 \" λ演算的程序结构 最基本的函数是恒等函数：$ λx.x $，等同于 $ f(x) = x $，第一个 x 是函数参数，第二个是函数体。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:0","tags":["Recursion","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Theory"],"content":"变量 λ 演算中的变量分为自由变量和约束变量： 在函数 $ λx.x $ 中 x 被称为约束变量，x 被称为约束变量，因为它既在函数体中又是形参。 在 $ λx.y $ 中 y 被称为自由变量，因为它没有被预先声明。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:1","tags":["Recursion","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Theory"],"content":"求值 求值通过 β 规约(β-Reduction) 完成，它将替换作用于应用，简单理解就是函数调用。例如对表达式 $ (λx.x)a $ 求值时，我们把函数体中所有的 x 都替换为 a： $ (λx.x) \\ a = a $ $ (λx.y) \\ a = y $ 你可以这样表示高阶函数： $ (λx.λy.x) \\ a = λy.a $ 为了简化表示，λx.λy. 与 λxy. 等价： $ (λxy.x) \\ a = λy.a $ 图灵机的逻辑操作实际上是二进制的 0 1 比较，而 λ 演算中连数字都没有，怎么定义程序逻辑？既然没有数，那就用 λ 函数来表示数！ ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:2","tags":["Recursion","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Theory"],"content":"Church 编码 邱奇数 邱奇数 是用 λ 函数表示的自然数。某个程序过程(函数) f 和它的执行次数 n，存在对应关系： $ 0 = λf.λx.x $ $1 = λf.λx.f x$ $ 2 = λf.λx.f (f x) $ $ 3 = λf.λx.f ( f (f x)) $ … 于是， $ n = λf.λx.f^nx $ 由 β 规约得出：$ n \\ f \\ x = (λf.λx.f^nx) \\ f \\ x = f^nx $ 由恒等式 $ f^{m+n}x = f^m(f^nx) $ 推出加法定义： $ plus = λm.λn.λf.λx.m \\ f \\ (n \\ f \\ x) $ 由恒等式 $ f^{m*n}x = (f^n)^mx $ 推出乘法定义： $ mult = λm.λn.λf.m (n \\ f) $ 其他的运算都能用类似的方法推出。 布尔逻辑 布尔逻辑可被看做一种选择，ture 和 false 可以被编码为有两个参数的函数： ture — 选择第一个参数 $ true = λa.λb.a $ false — 选择第二个参数 $ false = λa.λb.b $ 布尔函数本身是条件分支，那 if-else 语句就成语法糖了。因为判定条件最终是布尔函数，直接能将 if-else 的条件分支作为布尔函数的参数(if-else 语句有三个参数，第一个是判定条件)： $ ifelse = λp.λt.λf. p \\ t \\ f $ (p = true or p = false) 接着定义与、或、非的逻辑运算符： $ and = λp.λq. p \\ q \\ p $ $ or = λp.λq. p \\ p \\ q $ $ not = λp. p \\ false \\ true $ 若要图灵完备，必然能实现无限递归。而 λ 演算中只有匿名单参函数，也就是没有提前的函数声明，这能实现无限递归？真的能！ ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:3","tags":["Recursion","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Theory"],"content":"不动点组合子 不动点 函数 $ f $ 的不动点指的是将函数应用在输入值 x 时，会传回与输入值相同的值，使得 $ f(x) = x $。例如，0 和 1 是函数 $ f(x) = x^2 $ 的不动点。现在，假设有某个函数 Y 和任意函数 g，满足： Y g = g (Y g) 就是说将 g 作为 Y 的参数时，得到的新函数 Y g 是 g 的不动点。那神奇的事情就发生了： Y g = g (Y g) = g (g (Y g)) = g (…g (Y g)…) 一旦调用 Y g 就会产生新的 g，任意函数 g 的无限递归不就产生了吗？Amazing！ Y combinator 数学家 Haskell Curry 发现了这个 Y 的存在： $ Y := λf.(λx.f(x \\ x))(λx.f(x \\ x)) $ 证明过程： \r例如我们用匿名函数表达求阶乘时，我们暂称它为 g，实际的 g 和 Y 没有名字， g = λf. λx. (iszero x) 1 (mult x (f (pred x))) 当调用 Y g 时，得到 g(Y g)，由 β 规约得出： g(Y g) = λx. (iszero x) 1 (mult x ((Y g) (pred x))) 于是，Y g 就成为了递归函数： Y g = λx. (iszero x) 1 (mult x ((Y g) (pred x))) Y 能够组合一个匿名函数成为递归函数，因此被称为 Y combinator(Y 组合子)。由于 lambda 表达式是惰性求值 ，而很多编程语言例如 JS 中使用严格求值 ，因此 Y 组合子在 JS 中这样表示： let Y = (f) =\u003e ((x) =\u003e f((y) =\u003e x(x)(y)))((x) =\u003e f((y) =\u003e x(x)(y))); Church 编码和不动点组合子表明了程序不用其他原始数据类型就能模拟图灵机。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:4","tags":["Recursion","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Theory"],"content":"实践 代码实践参考了计算的本质 一书，原文是 Ruby 代码，我把它翻译为 JS 代码了： const Y = (f) =\u003e ((x) =\u003e f((y) =\u003e x(x)(y)))((x) =\u003e f((y) =\u003e x(x)(y))); const F = (a) =\u003e (b) =\u003e b; const T = (a) =\u003e (b) =\u003e a; const zero = (f) =\u003e (x) =\u003e x; const one = (f) =\u003e (x) =\u003e f(x); const two = (f) =\u003e (x) =\u003e f(f(x)); const three = (f) =\u003e (x) =\u003e f(f(f(x))); const four = (f) =\u003e (x) =\u003e f(f(f(f(x)))); const five = (f) =\u003e (x) =\u003e f(f(f(f(f(x))))); const pair = (x) =\u003e (y) =\u003e (z) =\u003e z(x)(y); const left = (p) =\u003e p((x) =\u003e (y) =\u003e x); const right = (p) =\u003e p((x) =\u003e (y) =\u003e y); const empty = pair(T)(T); const ushift = (l) =\u003e (x) =\u003e pair(F)(pair(x)(l)); const is_empty = left; const first = (l) =\u003e left(right(l)); const rest = (l) =\u003e right(right(l)); const if_else = (b) =\u003e b; const is_zero = (f) =\u003e f((x) =\u003e F)(T); const is_less_or_equal = (m) =\u003e (n) =\u003e is_zero(minus(m)(n)); const succ = (n) =\u003e (f) =\u003e (x) =\u003e f(n(f)(x)); const slide = (p) =\u003e pair(right(p))(succ(right(p))); const pred = (n) =\u003e left(n(slide)(pair(zero)(zero))); const plus = (m) =\u003e (n) =\u003e n(succ)(m); const minus = (m) =\u003e (n) =\u003e n(pred)(m); const mult = (m) =\u003e (n) =\u003e n(plus(m))(zero); const div = Y( (f) =\u003e (m) =\u003e (n) =\u003e if_else(is_less_or_equal(n)(m))((x) =\u003e succ(f(minus(m)(n))(n))(x))(zero) ); const a = two; const b = succ(a); const aa = ushift(ushift(empty)(a))(a); const ab = ushift(ushift(empty)(b))(a); const abaa = ushift(ushift(aa)(b))(a); const to_boolean = (p) =\u003e if_else(p)(\"T\")(\"F\"); const to_char = (c) =\u003e if_else(is_zero(c))(\"0\")( if_else(is_zero(pred(c)))(\"1\")(if_else(is_zero(two(pred)(c)))(\"a\")(\"b\")) ); const fold = Y( (f) =\u003e (l) =\u003e (x) =\u003e (g) =\u003e if_else(is_empty(l))(x)((y) =\u003e g(f(rest(l))(x)(g))(first(l))(y)) ); const pushs = (l) =\u003e (x) =\u003e fold(l)(ushift(empty)(x))(ushift); const to_digits = Y( (f) =\u003e (n) =\u003e pushs( if_else(is_less_or_equal(n)(pred(two)))(empty)((x) =\u003e f(div(n)(two))(x)) )(mod(n)(two)) ); const mod = Y( (f) =\u003e (m) =\u003e (n) =\u003e if_else(is_less_or_equal(n)(m))((x) =\u003e f(minus(m)(n))(n)(x))(m) ); const range = Y( (f) =\u003e (m) =\u003e (n) =\u003e if_else(is_less_or_equal(m)(n))((x) =\u003e ushift(f(succ(m))(n))(m)(x))(empty) ); const maps = (k) =\u003e (f) =\u003e fold(k)(empty)((l) =\u003e (x) =\u003e ushift(l)(f(x))); const twenty = mult(four)(five); const my_list = maps(range(one)(twenty))((n) =\u003e if_else(is_zero(mod(n)(succ(five))))(abaa)( if_else(is_zero(mod(n)(three)))(aa)( if_else(is_zero(mod(n)(two)))(ab)(to_digits(n)) ) ) ); // The above code only uses functions to compconste all calculations, // and the calculation result is a single-character linked list // But the above code does not encode the characters related to the output format, // so use an array to store the result to change the output format const to_array = (proc) =\u003e { const arr = []; while (to_boolean(is_empty(proc)) != \"T\") { arr.push(first(proc)); proc = rest(proc); } return arr; }; const to_string = (s) =\u003e to_array(s) .map((c) =\u003e to_char(c)) .join(\"\"); console.log(to_array(my_list).map((v) =\u003e to_string(v))); // If you don’t use arrays, you can also use functions to simulate const fact = Y((f) =\u003e (n) =\u003e is_zero(n)(one)((x) =\u003e mult(n)(f(pred(n)))(x))); const arr = (s) =\u003e to_char(first(s)); const s1 = to_digits(fact(four)); const s2 = rest(s1); const s3 = rest(s2); const s4 = rest(s3); const s5 = rest(s4); // console.log(arr(s1) + arr(s2) + arr(s3) + arr(s4) + arr(s5)); 附：源码地址 推荐阅读 康托尔、哥德尔、图灵——永恒的金色对角线 Church encoding Learn Lambda Calculus in Y minutes Lambda 演算系列 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:2:0","tags":["Recursion","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Theory"],"content":"图灵机是英国数学家图灵于 1936 年提出的一种将人的计算行为抽象化的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:0:0","tags":["Recursion","Turing Machine"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Theory"],"content":"基本思想 图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作： 在纸上写上或擦除某个符号； 把注意力从纸的一个位置移动到另一个位置； 而在每个阶段，人要决定下一步的动作，依赖于此人当前所关注的纸上某个位置的符号和此人当前思维的状态。为了模拟人的这种运算过程，图灵构造出一台假想机器，该机器由以下几个部分组成： 图灵机的组成结构图灵机的组成结构 \" 图灵机的组成结构 一条无限长的纸带(tape)，纸带由很多个格子构成，用于输入输出信息。每个格子中包含一个来自有限字母表的符号，字母表中有一个特殊符号表示空白。纸带上一端的格子从 0 开始编号，另一端无限延伸一直到无穷大。 一个读写头(head)，读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。 一套控制规则(table)，根据当前机器状态和纸带内容来确定下一步的动作： 写入或擦除当前格子内容 移动读写头，向左、向右、或不动 保持当前状态或转移到另一状态 一个状态寄存器(state register)，用于保存机器状态。图灵机的状态个数有限，并且有一个特殊的状态：停机状态。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:1:0","tags":["Recursion","Turing Machine"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Theory"],"content":"图灵完备 只要能模拟单带图灵机，就是图灵完备(递归可枚举)的。这意味着其计算能力与通用图灵机等同。不是图灵完备的情况: 递归或循环有限，无法写不终止的程序(如 while(true){}) 不能模拟无限长纸带(没有足够的空间来完成计算) 但图灵完备也有可能带来坏处，有些场景我们需要限制语言的表达能力，通过限制无限循环却保程序一定是可终止的。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:2:0","tags":["Recursion","Turing Machine"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Theory"],"content":"极简实现 Brainfuck 是一种极小化的图灵完备的程序语言，它仅由八种运算符构成。 它的工作机制与单带图灵机高度一致，它用一个一维数组存取数据，数组元素初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一元素。指针可以向左/右移动，也可以读取/修改当前值。如果你了解 C 语言，那么一看表格便明白它每个运算符的含义： Brainfuck C \u003e ++ptr; \u003c --ptr; + ++*ptr; - --*ptr; . putchar(*ptr); , *ptr = getchar(); [ while (*ptr) { ] } 不了解也没关系，它每个运算符的含义如下： \u003e 指针右移一格 \u003c 指针左移一格 + 使指针当前格数值加一 - 使指针当前格数值减一 . 把当前格数值按 ASCII 表输出到终端 , 从终端接收一字节的数据，存储其 ASCII 数值到当前格 [ 当指针当前值为 0 时，程序跳转至与之对应的 ] 之后；否则程序正常执行 ] 程序跳转回与之对应的 [ 处 有了这些工具，我们可以很快写出一个计算乘法的程序。因为 ASCII 表中 ‘A’ 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 ‘A’。 +++++ [ \u003e +++++++++++++ \u003c - ] \u003e . 把 Brainfuck 的一维数组命名为 arr，则开始的数组元素为 arr[0]，arr[0] 右边的数组元素为 arr[1]。第一句代码将 arr[0] 的数值递增 5 次变为 5。 然后，循环执行“右移指针，递增 13 次，左移指针，递减 1 次”。当 arr[0] 的值最终被递减为 0 的时候，循环结束。此时 arr[1] 的值执行了 5 次“递增 13 次”的操作，即 65。最后指针右移至 arr[1]，输出它对应的 ASCII 值即为 A。 结合 网站 1 和 网站 2 思考一下这门八个字符的编程语言是怎样模拟图灵机的每个组成部分的。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:3:0","tags":["Recursion","Turing Machine"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Theory"],"content":"“我是谁？”，这种对指代自身的疑问每个人都会有。在自然语言和形式语言中，如果一个句子直接或间接提及自身，就称为自指 (Self-reference)，自指的语句常常会造成悖论。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:0:0","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Theory"],"content":"不可判定怪圈 “这句话在说谎”，那么引号中的话是真话吗？你会发现，你若判定真，就会推出假。而你若判定假，又会推出真。不停的判定下去，就会陷入怪圈： 艺术表现自我指涉艺术表现自我指涉 \" 艺术表现自我指涉 在程序中，这就是无穷递归。与意识的自指相似的是别洛索夫发现的B-Z 反应 。意识中的悖论竟在自然界中有对应，这不禁让人疑惑：我们真的有自由意志 吗？ ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:1:0","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Theory"],"content":"崩塌的数学大厦 在 1900 年巴黎数学家大会上，希尔伯特提出了他的 23 个著名数学问题。以希尔伯特为首的很多数学家，打算让数学矗立在一个坚实的地基(公理体系)上，一劳永逸地解决所有对数学可靠性的疑问，这可是一项宏图大志。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:2:0","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Theory"],"content":"第二个问题 这 23 个问题中的第 2 个问题是完成数学家们理想计划的关键一步，它包含如下三个问题： 数学是完备的吗？(正确的数学陈述，是否总能被证明？) 数学是一致的吗？(数学是否前后一致，没有内部矛盾？) 数学是可判定的吗？(能否仅通过计算判定数学陈述的真假？) 在数学中，不证自明的事实被归纳为公理。公理是数学推演(计算)的起点，对公理的陈述就是命题，已被证明成立的重要命题被称为定理。那么一个可靠的数学系统至少应该满足以下性质： 有效性：在系统中如果前提为真，那么结论也为真 可靠性：系统中的所有定理都为真 一致性：系统中所有公理，定理之间没有矛盾 完备性：系统中不存在无法证明或无法证伪的命题 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:2:1","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Theory"],"content":"哥德尔不完备定理 这个想法非常美好，然而不久后，哥德尔用两条不完备定理 将数学家们拍醒了： 第一定理：任何包含了算术的数学系统不可能同时拥有一致性和完备性(这里算术指皮亚诺算术(PA)的公理 ，这说明任何一个允许自然数加法和乘法的体系必定是不完备的，通过数学推演无法得到体系中所有真命题)。 第二定理：任何包含了算术的数学系统，如果它是一致的，那么它就不能证明自身的一致性。 哥德尔不完备定理说的是算术系统中“正确”与“可证”是两码事。他的证明是在算术系统 T 中构造出了命题 P：“P 不可在算术系统 T 内证明”(我不可被证明)。这让我们意识到只要一个系统的表达力强到可以自指，那么就是不完备的。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:2:2","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Theory"],"content":"图灵机的由来 哥德尔得到了第二个问题中前两个问题的答案。不久之后，图灵给出了其中最后一个问题的答案：数学是不可判定的。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:0","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Theory"],"content":"图灵对计算的思考 什么是计算？计算就是由输入(前提)到输出(结论)的过程。什么是可计算的？可计算就是一定能在有限步骤内完成的计算。为了给可计算 一个精确定义，图灵提出了一种叫图灵机的数学模型，并提出了可计算函数 (算法)的概念。(为什么可计算就是图灵机可判定，请看邱奇－图灵论题 ) 图灵对计算的思考让他解决了希尔伯特的问题，他的证明过程分两步: 1.停机问题不可判定 2.停机问题到判定问题的归约 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:1","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Theory"],"content":"停机问题不可判定 停机问题 ：是否存在一个程序 P，对于有任意输入参数的程序 w，能够判断 w 会在有限时间内结束或者死循环。图灵用对角论证法证明了，不存在解决停机问题的通用算法。本文用自指做一个反证法证明(程序中的自指就是递归)： 假设存在可以判定任意程序是否停机的程序，我们姑且称它为上帝程序 那么一定存在一个撒旦程序，首先让上帝程序判定自己，然后根据上帝判定结果，相反地运行程序 伪代码描述如下： def P(w, input): if w halts on input: return true else: return false def oppose_P(): if P(oppose_P): while (1): pass else: pass 在撒旦程序中，上帝程序的判断都是错的，所以不存在这样的上帝程序。停机问题是不可判定问题，这响应了哥德尔不完备定理。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:2","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Theory"],"content":"到判定问题的规约 现在一定存在某个数学陈述能够做为程序 w 的输入参数，而前面的停机问题证明了，不存在能够判定任意程序 w 能否在有限时间内结束的上帝程序，因此数学是不可判定的。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:3","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Theory"],"content":"自指与自复制 美国哲学家蒯因(Quine)创造了一种不使用代词就能构造自指语句的方法，称为蒯因技巧。如下句子便采用了蒯因技巧： 把“把中的第一个字放到左引号前面，其余的字放到右引号后面，并保持引号及其中的字不变”中的第一个字放到左引号前面，其余的字放到右引号后面，并保持引号及其中的字不变 当你按照该句子的指示操作后，便得到了它自身。该句子仅用动作(数学推演)便完成了一次自复制，数学家克林(Kleene)将蒯因这种语言的操作技巧进行数学化得到了一种更加普适的递归定理 。有了这个递归定理以后，数学家就可以在严格的数学公理体系中构造各种自指游戏。哥德尔和图灵也是用递归定理来完成他们的伟大证明。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:4:0","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Theory"],"content":"思考总结 回到皮亚诺公理的第五条：对于无穷无尽具有相同性质的多米诺骨牌序列，已知第一块会倒下，并且每一块多米诺骨牌的倒下都会导致后一块倒下，是否每一块多米诺骨牌都会倒下？数学给出的假设是会，你觉得呢？数学是建立在有限假设之上的学科，当已知假设无法推导某些与无穷相关的性质时，就会在判定结果中显现出这种无穷无尽。一阶逻辑的逻辑归结是半可判定的，无法用有限归纳描述无穷过程。 自指太神秘了，对它的研究涉及到复杂性科学 ，作为门外汉的我只能无限感慨。想了解相关知识的读者，可阅读下面的参阅资料。 推荐阅读 计算的极限(零)：逻辑与图灵机 系统中的观察者——被科学遗忘的角色 混沌理论本质一切复杂源于简单 量子力学与相对论矛盾且同时合理: 引力的自我指涉 艺术家埃舍尔和他的函数世界 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:5:0","tags":["Recursion","Turing Machine"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Coding"],"content":"在前端开发的过程中，我们经常需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等，然而有些时候我们并不希望在事件持续触发的过程中频繁地去执行函数，这时候就会用到函数防抖(Debounce)与节流(Throttle)： 防抖：在触发事件 n 秒后才执行函数，如果在 n 秒内又触发了事件，则重新计算时间。 节流：连续触发事件时在 n 秒中只执行一次函数，节流的目的是稀释函数的执行频率。 下面我们简单地了解这两种限制函数执行次数的具体实现方式。首先看这个例子： \u003cbutton type=\"submit\" id=\"btn\"\u003e提交\u003c/button\u003e \u003cscript\u003e var btn = document.getElementById(\"btn\"); btn.addEventListener(\"click\", submit, false); function submit() { console.log(\"submit\"); } \u003c/script\u003e 每次 button 的点击事件都会执行 submit 函数，我们如何限制 submit 的执行次数？ ","date":"2020-11-10","objectID":"/2020-11-10-debounce/:0:0","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-debounce/"},{"categories":["Coding"],"content":"Debounce 防抖是在事件多次触发时让函数只执行一次，有非立即执行和立即执行两种实现。 ","date":"2020-11-10","objectID":"/2020-11-10-debounce/:1:0","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-debounce/"},{"categories":["Coding"],"content":"闭包实现防抖 用闭包可以实现一个简单的 debounce 函数来包装 submit 函数，实现防抖效果。 var btn = document.getElementById(\"btn\"); btn.addEventListener(\"click\", debounce(submit, 1000), false); function submit() { console.log(\"submit\"); } function debounce(fn, timer) { let t = null; return function () { // 计时未到 timer 的定时器会被清理，函数就不会执行 if (t) { clearTimeout(t); } t = setTimeout(fn, timer); }; } 连续点击时，始终从最新一次点击开始计时。直到不再点击的 1s 后，才会执行一次 submit。 ","date":"2020-11-10","objectID":"/2020-11-10-debounce/:1:1","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-debounce/"},{"categories":["Coding"],"content":"传递 this 和 event 当我们在事件监听中绑定 submit 时，this 指向 button，并且可以拿到 MouseEvent 事件。 var btn = document.getElementById(\"btn\"); btn.addEventListener(\"click\", submit, false); function submit() { console.log(\"submit\"); console.log(this); // \u003cbutton type=\"submit\" ... console.log(arguments); // Arguments [MouseEvent ... } 现在我们的 submit 被 debounce 包装，此时 this 和事件参数要从 debounce 传递给 submit。 var btn = document.getElementById(\"btn\"); btn.addEventListener(\"click\", debounce(submit, 1000), false); function submit() { console.log(\"submit\"); console.log(this); // \u003cbutton type=\"submit\" ... console.log(arguments); // Arguments [MouseEvent ... } function debounce(fn, timer) { let t = null; return function () { let context = this; let args = arguments; if (t) clearTimeout(t); t = setTimeout(() =\u003e { fn.apply(context, args); }, timer); }; } 这就是一个非立即执行的防抖实现，缺陷是第一次点击也需要等待 1s 后才会有反馈。 ","date":"2020-11-10","objectID":"/2020-11-10-debounce/:1:2","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-debounce/"},{"categories":["Coding"],"content":"立即执行版本 第一次点击时让函数立即执行。不再点击的 1s 后，新的点击将成为第一次点击，再次执行函数。 function debounce(fn, timer) { let t = null; return function () { let context = this; let args = arguments; let firstClick = !t; if (t) clearTimeout(t); if (firstClick) { fn.apply(context, args); } t = setTimeout(() =\u003e { t = null; }, timer); }; } ","date":"2020-11-10","objectID":"/2020-11-10-debounce/:1:3","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-debounce/"},{"categories":["Coding"],"content":"Throttle 节流的实现方式是减少函数的触发频率，同样有非立即执行和立即执行两种实现。 ","date":"2020-11-10","objectID":"/2020-11-10-debounce/:2:0","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-debounce/"},{"categories":["Coding"],"content":"定时器版本 非立即执行我们自然想到用定时器实现： function throttle(fn, timer) { let t = null; return function () { let context = this; let args = arguments; // 计时未到 timer 时不会执行函数 if (!t) { t = setTimeout(() =\u003e { fn.apply(context, args); t = null; }, timer); } }; } ","date":"2020-11-10","objectID":"/2020-11-10-debounce/:2:1","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-debounce/"},{"categories":["Coding"],"content":"时间戳版本 立即执行我们要计算时间差，所以用时间戳实现： function throttle(fn, timer) { let begin = 0; return function () { let now = new Date().getTime(); if (now - begin \u003e timer) { fn.apply(this, arguments); begin = now; } }; } 实际上，结合非立即执行和立即执行的两种实现方式，你可以构造出具有更多功能的防抖函数和节流函数，满足业务需求。 参阅资料 性能优化之防抖和节流 ","date":"2020-11-10","objectID":"/2020-11-10-debounce/:2:2","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-debounce/"},{"categories":["Coding"],"content":"以 useEffect 为圆心，其他 Hooks 为半径，构建 React Hooks 的知识圆环。为什么会想出这样一个标题呢？Hooks 的知识点过于分散，很多朋友在读过 React 官方文档后，还是不知道 Hooks 如何在实际项目中使用。本文希望从 useEffect 的具体用法中引出其他 Hooks，从而构建出完整的 React Hooks 知识体系。 React 的核心原理：当数据发生变化时，UI 随之更新，就是所谓的数据驱动。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:0:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"函数式编程 在 函数式编程 中，函数是 头等对象 即 头等函数 ，这意味着一个函数，既可以作为其它函数的输入参数值，也可以从函数中返回值，被修改或者被分配给一个变量。λ 演算 是这种范型最重要的基础，λ 演算的函数可以接受函数作为输入参数和输出返回值。 顺带提一句，由邱奇创造的 λ 演算 (λ-calculus) 是世界上最小的程序设计语言。λ 演算中没有数(number)，字符串(string)，布尔型(boolean) 或任何非函数的数据类型，它只用匿名单参函数就能模拟图灵机，具体实现过程可阅读我的这篇 文章 。 比起指令式编程 ，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:1:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"心智模型 学习 Hooks 的使用，重点是心智模型的转变。useEffect 的心智模型是实现状态同步，而不是响应生命周期事件。每次触发时 useEffect，它都会捕获本次调用时组件中的数据，也就是所谓的 Capture Value 特性：组件每次渲染都有自己的数据，组件内的函数(包括 effects，事件处理函数，定时器或者 API 调用等)会捕获该次渲染的组件数据。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:2:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"状态同步 首先看这段代码，请判断最终计时器中的 count 和 组件中的 count 分别是多少？ function Counter() { const [count, setCount] = useState(0); console.log(\"组件中的count\", count); useEffect(() =\u003e { console.log(\"触发useEffect\"); const id = setInterval(() =\u003e { console.log(\"计时器中的count\", count); setCount(count + 1); }, 1000); return () =\u003e { console.log(\"销毁了定时器\"); clearInterval(id); }; }, []); return \u003ch1\u003e{count}\u003c/h1\u003e; } 答案分别是 0 和 1，多少有点基础的人都能想通或者猜对。现在更改需求，让组件中的 count 每秒加 1。我们有两种写法： 不对依赖数组撒谎 // 每次因 count 变化触发的重渲染都会触发 useEffect function Counter() { const [count, setCount] = useState(0); console.log(\"组件中的count\", count); useEffect(() =\u003e { console.log(\"触发useEffect\"); const id = setInterval(() =\u003e { console.log(\"计时器中的count\", count); setCount(count + 1); }, 1000); return () =\u003e { console.log(\"销毁了定时器\"); clearInterval(id); }; }, [count]); return \u003ch1\u003e{count}\u003c/h1\u003e; } 每次重渲染创建 Counter 组件时都会触发 useEffect，销毁上一次的计数器，并创建新的计数器。因此组件中的 count 和计时器中的 count 是同步的。 让 Effect 自给自足 // 移除 useEffect 的非必需的依赖，减少不必要的触发。 function Counter() { const [count, setCount] = useState(0); console.log(\"组件中的count\", count); useEffect(() =\u003e { console.log(\"触发useEffect\"); const id = setInterval(() =\u003e { console.log(\"计时器中的count\", count); // 这里接收的函数描述 count 如何变化(action) setCount((c) =\u003e c + 1); }, 1000); return () =\u003e { console.log(\"销毁了定时器\"); clearInterval(id); }; }, []); return \u003ch1\u003e{count}\u003c/h1\u003e; } 通过控制台我们发现，计时器中的 count 始终为 0，怎么解释？useEffect 只在组件初次渲染后触发一次，它创建了计时器，计时器记住了当时的 count。既然计时器中的 count 始终为 0，那么 setCount 是怎样让组件状态同步的呢？想搞清楚这一点就不得不提 useReducer 了。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:3:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"useReducer 事实上，useState 是预置了如下 reducer 的 useReducer，相关 源码 ： function basicStateReducer\u003cS\u003e(state: S, action: BasicStateAction\u003cS\u003e): S { return typeof action === \"function\" ? action(state) : action; } 也就是说，setCount 接收的 action 函数是在下一次函数组件渲染时，在 useState 中调用的。描述动作和执行动作分开进行，感觉有 Redux 的内味了？没错，React 还为 useReducer 提供了配套的 dispatch 方法： const [state, dispatch] = useReducer(reducer, initialArg, init); 再次更改需求，我们不让计时器每秒加 1，而是由输入的 step 控制。还是对比两种写法： 不对依赖数组撒谎 function Counter() { const [count, setCount] = useState(0); const [step, setStep] = useState(0); useEffect(() =\u003e { const id = setInterval(() =\u003e { setCount(count =\u003e count + step); }, 1000); return () =\u003e clearInterval(id); }, [step]); ... } 让 Effect 自给自足 const initialState = { count: 0, step: 0, }; function reducer(state, action) { const { count, step } = state; if (action.type === 'tick') { return { count: count + step, step }; } else if (action.type === 'step') { return { count, step: action.step }; } else { throw new Error(); } } function Counter() { const [state, dispatch] = useReducer(reducer, initialState); const { count, step } = state; useEffect(() =\u003e { const id = setInterval(() =\u003e { dispatch({ type: 'tick' }); }, 1000); return () =\u003e clearInterval(id); }, []); return ( \u003cdiv\u003e \u003ch1\u003e{count}\u003c/h1\u003e \u003cinput value={step} onChange={e =\u003e { dispatch({ type: 'step', step: Number(e.target.value) }); }} /\u003e \u003cdiv/\u003e ); } 移除 useEffect 的非必需的依赖，就能减少不必要的触发，是一种性能优化思路。还有一种思路是保持 useEffect 的依赖不变，也能减少不必要的触发，这会用到 useCallback 和 useMemo。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:4:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"useCallback React 判断组件中的数据是否发生改变时使用了 Object.is 进行比较。当 useEffect 的依赖数组的元素为引用数据类型时，每次的比较结果都是发生改变，这就失去了依赖数组本身的意义(条件式地触发 useEffect)。看这段代码，我们希望复用网络请求逻辑，这样可行吗？ function SearchResults() { const getFetchUrl = (query) =\u003e { return 'https://hn.algolia.com/api/v1/search?query=' + query; }; useEffect(() =\u003e { const url = getFetchUrl('react'); // Fetch data and do something ... }, [getFetchUrl]); useEffect(() =\u003e { const url = getFetchUrl('redux'); // Fetch data and do something ... }, [getFetchUrl]); ... } 当我们写这段代码时，我们发现网络请求将无限重复，因为函数调用会生成不同引用。一个可能的解决办法是把 getFetchUrl 从依赖中去掉，前提是你能确保它不受数据流变化的影响，否则就会出现意想不到的 bugs。 然而 useEffect 的设计意图就是要强迫你关注数据流的变化，然后去同步状态。当不能把函数从依赖中去掉时，我们可以使用 useCallback 来包装函数从而确保函数的引用相等： /** useCallback 在其依赖变化时，才生成新的函数 * 现在依赖为空，getFetchUrl 永远调用同一个函数 */ const getFetchUrl = useCallback((query) =\u003e { return \"https://hn.algolia.com/api/v1/search?query=\" + query; }, []); 更改 getFetchUrl 后就能避免网络请求重复的问题了。useCallback 本质上是对函数添加了一层依赖检查，让函数只在需要改变的时候才改变。 useCallback 的另一个使用场景：当父组件传递函数给子组件的时候，由于父组件的更新会导致该函数重新生成，从而传递给子组件的函数引用发生变化，这就会导致子组件也会更新，这时我们可以通过 useCallback 来缓存该函数，然后传递给子组件同一个函数避免子组件更新(子组件需用 memo 包装)，看这篇 文章 的例子。 useMemo 扩展了 useCallback 的功能，useCallback 只能缓存函数，而 useMemo 可以缓存任何类型的值，同样是为了确保引用相等。除此之外，useMemo 还可以用于避免重复计算。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:5:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"useRef 现在来看这个例子，我们连续点击 Add count 按钮时，3s 后会发生什么？ function Counter() { const [count, setCount] = useState(0); useEffect(() =\u003e { setTimeout(() =\u003e { console.log(count); }, 3000); }); return ( \u003cdiv\u003e \u003ch1\u003e{count}\u003c/h1\u003e \u003cbutton onClick={()=\u003esetCount(count+1)}\u003eAdd count\u003c/button\u003e \u003cdiv/\u003e ); } 3s 后会在控制台依次打印 count 的值 1，2，3 …，然而在一些场景中，我们只想得到最新的 count 值，该怎么做？这就会用到 useRef，useRef 返回一个可变的 ref 对象，它的属性 current 被初始化为传入的参数，并且 useRef 始终返回同一个 ref 对象。 function Counter() { const [count, setCount] = useState(0); const latestCount = useRef(count); useEffect(() =\u003e { latestCount.current = count; setTimeout(() =\u003e { console.log(latestCount.current); }, 3000); }); return ( \u003c\u003e \u003ch1\u003e{count}\u003c/h1\u003e \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eAdd count\u003c/button\u003e \u003c/\u003e ); } 现在我们连续点击会发现 3s 后控制台将多次打印最新的 count 值，这证明我们修改的是同一个 ref 对象。除了用来缓存变量，useRef 还能获得 DOM 元素，需要在元素上绑定 ref 属性： function RefDemo() { const titleRef = useRef(); function changeDOM() { titleRef.current.innerHTML = \"hello world\"; titleRef.current.style.color = \"red\"; } return ( \u003cdiv\u003e \u003ch2 ref={titleRef}\u003eRefDemo\u003c/h2\u003e \u003cbutton onClick={changeDOM}\u003e修改DOM\u003c/button\u003e \u003c/div\u003e ); } ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:6:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"思考 暂时就先这样吧，后面还会再补充。 参阅资料 A Complete Guide to useEffect 推荐阅读 二十分钟掌握 React 核心理念 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:7:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"现在，我们遵循 React 16.8 的代码体系结构，一步一步地构建我们自己的 mini React。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:0:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"基础回顾 开始之前，我们先回顾 React 是怎么将 JSX 转换成 DOM 节点的： const element = \u003ch1 title=\"foo\"\u003eHello\u003c/h1\u003e; const container = document.getElementById(\"root\"); ReactDOM.render(element, container); 第一行使用 JSX 来创建元素，但 JSX 不是有效的 JS 代码。React 用 Babel 将 JSX 代码转换为原生 JS 代码。转换过程就是调用 createElement 函数，并将 JSX 的元素类型、props 属性和 childen 元素作为参数依次传入： const element = \u003ch1 title=\"foo\"\u003eHello\u003c/h1\u003e; // Babel 调用 createElement 函数完成转换 const element = React.createElement(\"h1\", { title: \"foo\" }, \"Hello\"); // createElement 根据参数生成 object const element = { type: \"h1\", props: { title: \"foo\", children: \"Hello\", }, }; 这就是 React 元素的本质，包含 type 和 props 属性的对象(还有其他属性，我们只关注这两个)。现在我们就能用 element 生成 DOM 节点了。 ​const container = document.getElementById(\"root\") ​ const node = document.createElement(element.type) node[\"title\"] = element.props.title ​ const text = document.createTextNode(\"\") text[\"nodeValue\"] = element.props.children ​ node.appendChild(text) container.appendChild(node) ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:1:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"渲染阶段 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"createElement 现在我们来实现自己的 createElement 函数。注意一个细节，JSX 叶子节点可能是基本数据类型。我们把它包装为对象，统一数据类型(React 不会包装基本类型值或创建空数组，我们这样做是为了数据判断和修改的方便)。 function createElement(type, props, ...children) { return { type, props: { ...props, children: children.map((child) =\u003e typeof child === \"object\" ? child : createTextElement(child) ), }, }; } function createTextElement(text) { return { type: \"TEXT_ELEMENT\", props: { nodeValue: text, children: [], }, }; } ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:1","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"render 创建 DOM 节点并添加元素的 props 属性。 function render(element, container) { const dom = element.type == \"TEXT_ELEMENT\" ? document.createTextNode(\"\") : document.createElement(element.type); const isProperty = (key) =\u003e key !== \"children\"; Object.keys(element.props) .filter(isProperty) .forEach((name) =\u003e { dom[name] = element.props[name]; }); element.props.children.forEach((child) =\u003e render(child, dom)); container.appendChild(dom); } 现在将我们的库取名 Didact，让 Babel 调用我们的库转换 JSX。 const Didact = { createElement, render, }; /** @jsx Didact.createElement */ const element = ( \u003cdiv style=\"background: salmon\"\u003e \u003ch1\u003eHello World\u003c/h1\u003e \u003ch2 style=\"text-align:right\"\u003efrom Didact\u003c/h2\u003e \u003c/div\u003e ); const container = document.getElementById(\"root\"); Didact.render(element, container); 这样就实现了 JSX 的转换和渲染，在 codesandbox 中试试看。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:2","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Concurrent 在我们加入更多特性之前我们先对代码进行一次重构。因为递归调用存在一个问题：渲染开始就会一直阻塞主进程。如果浏览器需要处理一些高优先级的任务(像用户输入或者保持动画流畅)，需要等到所有元素渲染完成之后再进行处理，这是不好的用户体验。 let nextUnitOfWork = null ​ function workLoop(deadline) { let shouldYield = false while (nextUnitOfWork \u0026\u0026 !shouldYield) { // 迭代子任务 nextUnitOfWork = performUnitOfWork( nextUnitOfWork ) shouldYield = deadline.timeRemaining() \u003c 1 } requestIdleCallback(workLoop) } ​// 主进程空闲时才会调用回调函数 requestIdleCallback(workLoop) ​// 执行当前子任务并返回下一个子任务 function performUnitOfWork(nextUnitOfWork) { // TODO } 现在我们拆分整个任务为一个个小的子任务，浏览器可以在执行完每个小任务后中断渲染流程去处理其他事情。因为我们使用 reqeustIdleCallback 来创建一个循环任务(React 现在使用 scheduler )，它在主进程空闲时才会执行回调函数，它为回调函数提供一个 deadline 参数，据此我们可以知晓还剩多少时间浏览器会拿回控制权。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:3","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Fibers 我们使用 fiber 树连接所有子任务，为每个元素创建一个 fiber，每个 fiber 对应一个子任务。假如我们渲染如下一颗元素树： Didact.render( \u003cdiv\u003e \u003ch1\u003e \u003cp /\u003e \u003ca /\u003e \u003c/h1\u003e \u003ch2 /\u003e \u003c/div\u003e, container ); 生成对应的 fiber 树： Fiber TreeFiber Tree \" Fiber Tree 在渲染中，我们将 container 创建为 root 并将其设置为 nextUnitOfWork。而元素的 fiber 由 performUnitOfWork 生成，我们将为每个 fiber 做三件事： 1.将元素添加到 DOM 中。 2.为元素的子元素创建 fiber。 3.寻找下一个子任务。 现在我们从 render 中提取出创建 DOM 节点的逻辑，稍后我们会使用它。 function createDom(fiber) { const dom = fiber.type == \"TEXT_ELEMENT\"? document.createTextNode(\"\"): document.createElement(fiber.type) const isProperty = key =\u003e key !== \"children\" Object.keys(fiber.props) .filter(isProperty) .forEach(name =\u003e { dom[name] = fiber.props[name] }) ​ return dom } 在 render 函数中，我们将 nextUnitOfWork 的 DOM 属性设置为 container。 function render(element, container) { nextUnitOfWork = { dom: container, props: { children: [element], }, } } ​ let nextUnitOfWork = null 接下来在 performUnitOfWork 中完成每个 fiber 的三件事。 function performUnitOfWork(fiber) { // 需要与父节点的 DOM 连接时才创建 DOM 节点 if (!fiber.dom) { fiber.dom = createDom(fiber) } ​ if (fiber.parent) { fiber.parent.dom.appendChild(fiber.dom) } ​ // 为子元素创建 newFiber，dom 属性为空 const elements = fiber.props.children let index = 0 let prevSibling = null ​ while (index \u003c elements.length) { const element = elements[index] ​ const newFiber = { type: element.type, props: element.props, parent: fiber, dom: null, } if (index === 0) { fiber.child = newFiber } else { prevSibling.sibling = newFiber } ​ prevSibling = newFiber index++ } // 寻找下一个子任务，优先级依次是子节点、兄弟节点、叔叔节点。 if (fiber.child) { return fiber.child } let nextFiber = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent } } ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:4","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Commit 处理元素时我们每次向 DOM 添加一个新节点。但浏览器是会中断渲染过程的，这样用户会看到不完整的 UI。我们怎么避免这种情况呢？答案是重构操作 DOM 的代码。 首先在删除 performUnitOfWork 中添加 DOM 节点的代码： // if (fiber.parent) { // fiber.parent.dom.appendChild(fiber.dom) // } 然后在 render 中用 wipRoot 保存 fiber root 节点。 function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, } nextUnitOfWork = wipRoot } ​ let nextUnitOfWork = null let wipRoot = null 直到本次全部元素渲染结束时，我们才将整个 fiber 树提交到 DOM 中。 function commitRoot() { // 将所有元素的 fiber 递归附加到 DOM commitWork(wipRoot.child) wipRoot = null } ​ function commitWork(fiber) { if (!fiber) { return } const domParent = fiber.parent.dom domParent.appendChild(fiber.dom) commitWork(fiber.child) commitWork(fiber.sibling) } function workLoop(deadline) { let shouldYield = false while (nextUnitOfWork \u0026\u0026 !shouldYield) { nextUnitOfWork = performUnitOfWork( nextUnitOfWork ) shouldYield = deadline.timeRemaining() \u003c 1 } ​ // 直到没有下一个子任务，将整个 fiber 树提交到 DOM 节点中 if (!nextUnitOfWork \u0026\u0026 wipRoot) { commitRoot() } requestIdleCallback(workLoop) } ​// 主进程空闲时才会调用回调函数 requestIdleCallback(workLoop) ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:5","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"更新阶段 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:3:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Reconciliation 到目前为止，我们只是将元素添加到了 DOM 中，但是我们怎么去更新或者删除节点呢？(diff) 在每个 fiber 中添加 alternate 属性保存上一次提交到 DOM 中的 fiber。先在 wipRoot 中添加： function commitRoot() { commitWork(wipRoot.child) // 渲染结束时存储当前的 fiber root currentRoot = wipRoot wipRoot = null } ​ function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, alternate: currentRoot, } nextUnitOfWork = wipRoot } ​ let nextUnitOfWork = null // 增加 currentRoot 用于保存当前提交到 DOM 中的 fiber 树 let currentRoot = null let wipRoot = null 将 performUnitOfWork 中创建新 fiber 的逻辑移到 reconcileChildren 函数中，给每个子 fiber 添加 alternate 和 effectTag 属性(effectTag 属性用于 Commit 阶段)： // 协调(比较和复用)当前 fiber 的所有子 fiber function reconcileChildren(wipFiber, elements) { let index = 0; let oldFiber = wipFiber.alternate \u0026\u0026 wipFiber.alternate.child; let prevSibling = null; while (index \u003c elements.length || oldFiber != null) { const element = elements[index]; let newFiber = null; const sameType = oldFiber \u0026\u0026 element \u0026\u0026 element.type == oldFiber.type; // 需要添加新的 fiber if (element \u0026\u0026 !sameType) { newFiber = { type: element.type, props: element.props, dom: null, parent: wipFiber, alternate: null, effectTag: \"PLACEMENT\", }; } // 需要更新原来的 fiber if (sameType) { newFiber = { type: oldFiber.type, props: element.props, dom: oldFiber.dom, parent: wipFiber, // oldFiber 被替换时才需要用 alternate 保存 alternate: oldFiber, effectTag: \"UPDATE\", }; } // 需要删除原来的 fiber if (oldFiber \u0026\u0026 !sameType) { oldFiber.effectTag = \"DELETION\"; } if (oldFiber) { oldFiber = oldFiber.sibling; } if (index === 0) { wipFiber.child = newFiber; } else if (element) { prevSibling.sibling = newFiber; } prevSibling = newFiber; index++; } } ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:3:1","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Commit 现在我们需要修改 commitWork 函数完成 DOM 的修改。 function commitWork(fiber) { if (!fiber) { return; } const domParent = fiber.parent.dom; if (fiber.effectTag === \"PLACEMENT\" \u0026\u0026 fiber.dom != null) { domParent.appendChild(fiber.dom); } else if (fiber.effectTag === \"UPDATE\" \u0026\u0026 fiber.dom != null) { updateDom(fiber.dom, fiber.alternate.props, fiber.props); } else if (fiber.effectTag === \"DELETION\") { domParent.removeChild(fiber.dom); } commitWork(fiber.child); commitWork(fiber.sibling); } 这里的 updateDom 就是用来更新 DOM 节点的属性。 const isProperty = (key) =\u003e key !== \"children\" \u0026\u0026 !isEvent(key); const isEvent = (key) =\u003e key.startsWith(\"on\"); const isNew = (prev, next) =\u003e (key) =\u003e prev[key] !== next[key]; const isGone = (prev, next) =\u003e (key) =\u003e !(key in next); function updateDom(dom, prevProps, nextProps) { // 删除旧的属性 Object.keys(prevProps) .filter(isProperty) .filter(isGone(prevProps, nextProps)) .forEach((name) =\u003e { dom[name] = \"\"; }); // 删除旧的事件监听 Object.keys(prevProps) .filter(isEvent) .filter((key) =\u003e !(key in nextProps) || isNew(prevProps, nextProps)(key)) .forEach((name) =\u003e { const eventType = name.toLowerCase().substring(2); dom.removeEventListener(eventType, prevProps[name]); }); // 设置新的属性 Object.keys(nextProps) .filter(isProperty) .filter(isNew(prevProps, nextProps)) .forEach((name) =\u003e { dom[name] = nextProps[name]; }); // 添加新的事件监听 Object.keys(nextProps) .filter(isEvent) .filter(isNew(prevProps, nextProps)) .forEach((name) =\u003e { const eventType = name.toLowerCase().substring(2); dom.addEventListener(eventType, nextProps[name]); }); } 在 codesandbox 中查看完整代码。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:3:2","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"函数组件 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:4:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Commit 现在，我们考虑在已有代码的基础上，增加对函数组件和 Hooks 的支持。看这个函数组件： /** @jsx Didact.createElement */ function App(props) { return \u003ch1\u003eHi {props.name}\u003c/h1\u003e; } const element = \u003cApp name=\"foo\" /\u003e; const container = document.getElementById(\"root\"); Didact.render(element, container); 如果我们将 jsx 转换为 js，Babel 的解析方式会是这样： function App(props) { return Didact.createElement(\"h1\", null, \"Hi \", props.name); } // 这里虽然会调用 createElement，但并不会调用 App 获取子元素 const element = Didact.createElement(App, { name: \"foo\" }); 观察 Babel 的解析后会发现： 我们不能为函数 App 创建 DOM 节点，因为没有 html 标签，只能渲染它的子元素。 子元素不会通过 createElement 的第三个参数传递，子元素需手动调用函数获取。 为函数创建子 fiber 我们可以这样做： function updateFunctionComponent(fiber) { // 由于 Babel 调用 createElement，得到的 fiber.type 就是函数名 const children = [fiber.type(fiber.props)]; reconcileChildren(fiber, children); } 我们需要修改 commitWork，因为函数的 fiber 没有 DOM 节点。我们要考虑如果在 fiber 树中存在无 DOM 节点的 fiber 时，如何连接 DOM： 要找到一个 DOM 节点的父节点，我们需要找到一个包含 DOM 节点的 fiber。 当需要移除一个 fiber 节点时，我们需要找到一个包含 DOM 节点的子节点。 function commitWork(fiber) { if (!fiber) { return } // 寻找到包含 DOM 的父节点 let domParentFiber = fiber.parent while (!domParentFiber.dom) { domParentFiber = domParentFiber.parent } const domParent = domParentFiber.dom ​ if ( fiber.effectTag === \"PLACEMENT\" \u0026\u0026 fiber.dom != null ) { domParent.appendChild(fiber.dom) } else if ( fiber.effectTag === \"UPDATE\" \u0026\u0026 fiber.dom != null ) { updateDom( fiber.dom, fiber.alternate.props, fiber.props ) } else if (fiber.effectTag === \"DELETION\") { // 寻找到包含 DOM 的子节点 commitDeletion(fiber,domParent); } commitWork(fiber.child) commitWork(fiber.sibling) } function commitDeletion(fiber, domParent) { if (fiber.dom) { domParent.removeChild(fiber.dom) } else { commitDeletion(fiber.child, domParent) } } ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:4:1","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Hooks 最后一步，既然我们使用了函数组件，那么就要给它加上状态。 首先更新为函数创建子 fiber 的函数： let wipFiber = null let hookIndex = null ​ function updateFunctionComponent(fiber) { wipFiber = fiber // 记录当前 hook 的索引 hookIndex = 0 // 支持在同一个组件中多次调用 useState 函数 wipFiber.hooks = [] const children = [fiber.type(fiber.props)] reconcileChildren(fiber, children) } 然后我们写自己的 useState 函数： function useState(initial) { const oldHook = wipFiber.alternate \u0026\u0026 wipFiber.alternate.hooks \u0026\u0026 wipFiber.alternate.hooks[hookIndex] // 如果存在旧的 hook，我们从旧的 hook 中拷贝状态到新的 hook const hook = { state: oldHook ? oldHook.state : initial, queue:[] } // 拿到 action(更新状态的回调函数) 处理 state const actions = oldHook ? oldHook.queue : [] actions.forEach(action =\u003e { hook.state = action(hook.state) }) // setState 将 action 添加到 hook 的 queue 中 ​ const setState = action =\u003e { hook.queue.push(action) wipRoot = { dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot, } // 重新渲染这颗 fiber tree nextUnitOfWork = wipRoot } wipFiber.hooks.push(hook) hookIndex++ // 返回 state 和 setState return [hook.state, setState] } 就这样，我们构建出了我们自己的 mini React，在 codesandbox 中查看完整代码。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:4:2","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"经验总结 本文的目的之一是让你更轻松地深入学习 React，这就是我们在几乎所有地方都使用与 React 相同的变量和函数名称的原因。但是我们构建的代码库并没有包含很多的 React 特性以及优化，以下是 React 与我们的实现做得不同的地方： 我们的渲染阶段会遍历整棵树，而 React 会跳过那些没有发生改变的子树。 我们会在提交阶段遍历整个树，而 React 只会保留产生影响的 fiber 节点。 我们为每个 fiber 创建一个新的对象，而 React 会复用之前树上的 fiber 节点。 我们在渲染阶段收到一个新的更新时，会丢弃之前的工作树，从根节点重新开始。而 React 给每一个更新标记一个过期时间戳，通过这个时间戳来决定各个更新之间的优先级。 除此之外还有很多… 参阅资料 Build your own React ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:5:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"本文是我最近阅读一篇英文技术文章后写的小结。阅读前请注意，本文不涉及任何 Recoil 源码。仿写的代码并不是 Recoil 真正的实现方式，本文只仿造实现了 Recoil 中两个重要的 API 接口：Atom 和 Selector。 如果你不熟悉 Recoil，请先阅读我的这篇 文章 或者阅读它的 官方文档 。然后新建 React 项目： npx create-react-app recoil-clone --typescript 在根目录下新建 coiled.tsx 文件，下面的代码都在这个文件中实现。 ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:0:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"状态基类 定义一个 Stateful 表示共享状态的基类，Atom 和 Selector 需继承这个基类。为了监听状态的变化，我们使用观察者模式。这种设计模式在 RxJS 之类的库中很常见，我将从头开始编写一个简单的同步版本。 interface Disconnect { disconnect: () =\u003e void; } export class Stateful\u003cT\u003e { // Set 是 callback 的集合 private listeners = new Set\u003c() =\u003e void\u003e(); constructor(protected value: T) {} // 取值函数 snapshot(): T { return this.value; } // 此处才会调用所有的监听者 private emit() { for (const listener of Array.from(this.listeners)) { console.log(\"调用监听者: \" + listener); listener(); } } // update 方法可以被 Stateful 的子类 Atom 和 Selector 继承 protected update(value: T) { if (this.value !== value) { this.value = value; console.log(\"新值: \" + this.value); this.emit(); } } // 订阅就加入监听者的 Set 集合，此方法接收 callback，返回也是 callback subscribe(callback: () =\u003e void): Disconnect { console.log(\"注册监听者：\" + callback); this.listeners.add(callback); return { disconnect: () =\u003e { console.log(\"注销监听者：\" + callback); this.listeners.delete(callback); }, }; } } ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:1:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"自定义 hook 下面是只读 hook 的实现方式。atom 和 selector 均可读，因此参数只需满足 Stateful 类型。这里注册的监听者 updateState 巧妙地利用了函数组件的重渲染机制，因为 useState 的参数为引用数据类型，{} === {} 的值为 false，因此只要调用 updateState 函数就会重渲染组件。关于 React 组件何时会重渲染可以读这篇 文章 。 export function useCoiledValue\u003cT\u003e(value: Stateful\u003cT\u003e): T { // 只要调用 updateState 就会触发重渲染 const [, updateState] = useState({}); useEffect(() =\u003e { console.log(\"渲染结束调用 useEffect, 添加监听者\"); // 注册 updateState 为监听者, 监听者是 callback 的 Set 集合 const { disconnect } = value.subscribe(() =\u003e updateState({})); return () =\u003e disconnect(); }, [value]); console.log(\"此时 useCoiledValue 的值: \" + value.snapshot()); return value.snapshot(); } 下面是读写 hook 的实现方式，这里的读写 hook 只适用于 atom，默认 selector 不可写。 export function useCoiledState\u003cT\u003e(atom: Atom\u003cT\u003e): [T, (value: T) =\u003e void] { const value = useCoiledValue(atom); return [value, useCallback((value) =\u003e atom.setState(value), [atom])]; } ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:2:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"Atom Atom 继承 Stateful，需要一个默认的写值方法。 export class Atom\u003cT\u003e extends Stateful\u003cT\u003e { public setState(value: T) { super.update(value); } } 暴露的接口函数是仿写 Recoil 中的 atom 函数。 export function atom\u003cV\u003e(value: { key: string; default: V }): Atom\u003cV\u003e { return new Atom(value.default); } ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:3:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"Selector Selector 继承 Stateful，Selector 是 Atom 或其他 Selector 的派生值，因此需要添加依赖。 export class Selector\u003cT\u003e extends Stateful\u003cT\u003e { // 将 dep 加入 Set 集合 private registeredDeps = new Set\u003cStateful\u003cany\u003e\u003e(); private addDep\u003cV\u003e(dep: Stateful\u003cV\u003e): V { if (!this.registeredDeps.has(dep)) { // 注册 updateSelector 为监听者，并将 dep 加入 Set 集合 dep.subscribe(() =\u003e this.updateSelector()); this.registeredDeps.add(dep); } return dep.snapshot(); } // 调用 generate 直接返回当前的 dep 值 private updateSelector() { this.update(this.generate({ get: (dep) =\u003e this.addDep(dep) })); } constructor(private readonly generate: SelectorGenerator\u003cT\u003e) { super(undefined as any); this.value = generate({ get: (dep) =\u003e this.addDep(dep) }); } } // selector 接收 atom 或者其他 selector 作为依赖 type SelectorGenerator\u003cT\u003e = (context: { get: \u003cV\u003e(dep: Stateful\u003cV\u003e) =\u003e V }) =\u003e T; 暴露的接口函数是仿写 Recoil 中的 selector 函数。 export function selector\u003cV\u003e(value: { key: string; get: SelectorGenerator\u003cV\u003e; }): Selector\u003cV\u003e { return new Selector(value.get); } ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:4:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"使用 将 index.tsx 作如下修改后，启动项目 yarn start，查看浏览器的 cosole 面板，项目成功运行。 import React from \"react\"; import ReactDOM from \"react-dom\"; import { atom, useCoiledState, useCoiledValue, selector } from \"./coiled\"; import \"./App.css\"; const textState = atom \u003c string \u003e { key: \"textState\", default: \"\", }; const charCountState = selector \u003c number \u003e { key: \"charCountState\", get: ({ get }) =\u003e { const text = get(textState); return text.length; }, }; function TextInput() { const [text, setText] = useCoiledState(textState); const onChange = (event: any) =\u003e { setText(event.target.value); }; return ( \u003cdiv\u003e \u003cinput type=\"text\" value={text} onChange={onChange} /\u003e \u003cbr /\u003e Echo: {text} \u003c/div\u003e ); } function CharacterCount() { const count = useCoiledValue(charCountState); return \u003c\u003eCharacter Count: {count}\u003c/\u003e; } function App() { return ( \u003cdiv className=\"App\"\u003e \u003cTextInput /\u003e \u003cCharacterCount /\u003e \u003c/div\u003e ); } ReactDOM.render(\u003cApp /\u003e, document.getElementById(\"root\")); 在 codesandbox 中查看完整代码。 ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:5:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"思考 我们仿造 Recoil 实现了自己的状态共享。但请思考以下内容： Selectors 不会取消对 atoms 的监听。这意味着当你不再使用他们时，会造成内存泄漏。 Selectors 和 Atoms 在重渲染前仅做一个浅比较。在某些场景下，使用深比较更加合理。 Recoil 使用唯一 key 值标识每一个 atom 或 selector，并且它被用作支持 “App-wide observation” 的元数据。这里的实现仅仅是为了保持 API 相似。 Recoil 在 selectors 里支持异步，这里没有实现这个特性。 我在 github 上发现了 jotai 项目。它与我的仿写非常相似，并且支持异步。 参阅资料 Rewriting Facebook’s “Recoil” React library … ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:6:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"Next.js Reddit Memehttps://www.reddit.com/r/nextjs/comments/17iy9sx/nextjs_server_action_is_crazy \" Next.js Reddit Meme 我们知道，如今流行的前端框架都是 SPA(单页应用)，在投入生产时会出现中首屏加载慢，不利于 SEO 等问题。于是，现代前端同构框架应运而生。Next.js 是 React 的同构框架，它的页面由 React 组件构成。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:0:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"路由系统 Next.js 的路由系统基于文件路径自动映射，一般约定在根目录的 pages 文件夹内： pages/index.js –\u003e / pages/about.js –\u003e /about pages/blog/[slug].js –\u003e /blog/:slug( slug 是动态生成的) pages/post/[...all].js–\u003e /post/*(匹配 /post,/post/a,/post/a/b 等) Next.js 创建的是多页应用，pages 内的每个文件都是单个页面。Next.js 中用形如 [params] 文件(文件夹)表示动态路由页面。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:1:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"路由跳转 Next.js 中路由跳转方式有两种，使用的 api 分别是 next/link 和 next/router。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"next/link 从 next/link 导入的 \u003cLink\u003e 是 React 组件，可接收以下属性: href 是导航到的路径，是页面跳转的必需属性，href 可以是字符串或者对象 \u003cLink href=\"/about?name=jackylin\"\u003e //这里 href 有两层 {}, github page 无法识别语法，只能写为一层了 \u003cLink href={ pathname: \"/about\", query: { name: \"jackylin\" },}\u003e as 是浏览器 url 栏显示的路径，当 href 中包含动态页面 ([param]) 时使用 const pids = [\"id1\", \"id2\", \"id3\"]; { pids.map((pid, index) =\u003e ( \u003cLink href=\"/post/[pid]\" as={`/post/${pid}`} key=\"index\"\u003e \u003ca\u003ePost {pid}\u003c/a\u003e \u003c/Link\u003e )); } passHref 将 \u003cLink\u003e 的 href 传递给子项，当子项是包装 \u003ca\u003e 的组件时，此属性必需 prefetch 预加载，将页面提前加载到本地缓存 官方文档还有一些其他 属性 和用法示例，需要注意的是 \u003cLink\u003e 只能有一个子项。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"next/router 相较于 next/link，next/router 能自定义配置复杂的路由跳转。next/router 提供如下 api： useRouter 是 React hook，只能用于函数组件 withRouter 是高阶组件，可用于类组件和函数组件 他们的实例对象 router 具有以下的属性，方法，事件等。 属性：pathname 是文件名，query 是查询参数，asPath 是浏览器中显示的路径。 方法：router.push(url, as, options) 是路由跳转方法，跳转的页面路径(url)必需。url 可以是字符串形式，也可以是对象形式。在需路由跳转的元素上绑定点击事件。 export default function ReadPost({ post }) { const router = useRouter(); return ( \u003cspan onClick={() =\u003e { router.push({ pathname: \"/post/[pid]\", query: { pid: post.id }, }); }} \u003e 查看文章 \u003c/span\u003e ); } 对比前面讲的 \u003cLink\u003e 组件，能看出 \u003cLink\u003e 组件其实是封装了 router，点击事件等。 事件：Next.js 在路由跳转的生命周期内置了一些的钩子事件，若我们有监听路由变化的需求，可订阅这些钩子事件来实现需求。具体用法请参阅 官方文档 。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"路由传参 Next.js 支持查询字符串格式的参数传递，参数以字符串或者对象的格式传递: \u003cLink\u003e 的 href 属性或者 router.push 中的 url。参数的接收可以用 useRouter 或 withRouter: // router 直接读取参数 const Post = () =\u003e { const router = useRouter(); return \u003cdiv\u003e文章编号：{router.query.pid}\u003c/div\u003e; }; export default Post; //使用 withRouter 接收参数时，router 作为组件参数 const Post = ({ router }) =\u003e { return \u003cdiv\u003e文章编号：{router.query.pid}\u003c/div\u003e; }; export default withRouter(Post); ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"获取数据 Next.js 中获取数据的方法有 getServerSideProps，getStaticProps 和 getStaticPaths。还有一个 getInitialProps，官方文档已不推荐使用。这些方法都是服务端的异步方法，只能在 pages 文件夹内使用。 Next.js 有两种预渲染形式： 服务端渲染(SSR)：html 在每次访问路由时都会重新生成。对应的数据获取方法：getServerSideProps。由于“服务端渲染”比“静态生成”慢，因此常用于数据频繁更新的页面。 静态生成(SSG)：html 是在构建时生成的，并且会在每次请求时重用。对应的数据获取方法： getStaticProps 和 getStaticPaths。这对于可以在用户请求之前就预渲染的页面非常有用，可以将其与客户端渲染结合使用以引入其他数据。 Next.js 引入了自动静态优化的功能，就是说如果页面中没有使用 SSR 方法，Next.js 在 build 阶段就会生成 html，访问页面路由直接返回生成的 html，以此来提升性能。 选择 SSR 还是 SSG？ 如果页面内容真动态(例如来源数据库且经常变化)，使用 SSR。 如果是静态页面或者伪动态(来源数据库但是不变化)，使用 SSG。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"getServerSideProps 在数据频繁更新的页面使用，每次访问路由时都会调用。getServerSideProps 方法是升级了 9.3 之前的 getInitialProps 方法。 const Blog = ({ data }) =\u003e { return \u003cdiv\u003etitle: {data.title}\u003c/div\u003e; }; // 在每次页面请求时才会运行，在构建时不运行。 export async function getServerSideProps() { const res = await fetch(\"https://jsonplaceholder.typicode.com/todos/1\"); const data = await res.json(); return { props: { data } }; } export default Blog; ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"getStaticProps 页面内容取决于外部数据时使用。 // posts 依赖外部数据 const Blog = ({ posts }) =\u003e { return \u003cdiv\u003etitle: {posts.title}\u003c/div\u003e; }; // 此函数只在构建时被调用一次，后面不会再次调用 export async function getStaticProps() { // 调用外部 API 获取内容 const res = await fetch(\"https://jsonplaceholder.typicode.com/todos/1\"); const posts = await res.json(); // 在构建时将接收到 `posts` 参数 return { props: { posts, }, }; } export default Blog; ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"getStaticPaths 页面路径取决于外部数据时使用，结合 getStaticProps 使用。 const Post = ({ post }) =\u003e { return ( \u003cdiv\u003e 文章id: {post.id}, 文章标题: {post.title} \u003c/div\u003e ); }; // 此函数只在构建时被调用一次，后面不会再次调用 export async function getStaticPaths() { // 取全部文章数据 const res = await fetch(\"https://jsonplaceholder.typicode.com/todos\"); const posts = await res.json(); const paths = posts.map((post) =\u003e `/posts/${post.id}`); // fallback为 false，表示不在 getStaticPaths 的路径是 404 页面。 return { paths, fallback: false }; } // params 来自 paths: [{ params: { ... } }] export async function getStaticProps({ params }) { // 取具体文章数据 const res = await fetch( `https://jsonplaceholder.typicode.com/todos/${params.id}` ); const post = await res.json(); return { props: { post } }; } export default Post; api 的更多细节用法请阅读 官方文档 。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"其他功能 ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"自定义配置 Next.js 在 pages 文件夹内的默认配置文件有 _app.js,_document.js,404.js 等。 以 _app.js 为例，它的功能是初始化当前路由的页面组件，接口如下： /** * Component 是当前路由的页面组件，每次路由切换时，Component 都会更新 * pageProps 是初始属性，该初始属性由某个数据获取方法预先加载到你的页面中，否则它将是一个空对象 */ function MyApp({ Component, pageProps }) { return \u003cComponent {...pageProps} /\u003e; } export default MyApp; 比如我们要使用 recoil 进行状态管理，所有页面组件都应该为 \u003cRecoilRoot\u003e 的子组件。 import { RecoilRoot } from \"recoil\"; export default function MyApp({ Component, pageProps }) { return ( \u003cRecoilRoot\u003e \u003cComponent {...pageProps} /\u003e \u003c/RecoilRoot\u003e ); } 其他配置文件的作用请阅读 官方文档 。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"自定义构建 Next.js 根目录 next.config.js 可配置项目构建。例如扩展默认 webpack 配置，接口如下： module.exports = { webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) =\u003e { // Note: we provide webpack above so you should not `require` it config.plugins.push(new webpack.IgnorePlugin(/\\/__tests__\\//)); // Important: return the modified config return config; }, }; 例如在 Next.js 默认的 babel 配置中添加一个 loader： // https://github.com/vercel/next.js/tree/canary/packages/next-mdx module.exports = { webpack: (config, options) =\u003e { config.module.rules.push({ test: /\\.mdx/, use: [ options.defaultLoaders.babel, { loader: \"@mdx-js/loader\", options: pluginOptions.options, }, ], }); return config; }, }; ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"api 路由 Next.js 提供简单的后端 api 能力，在 pages/api 内的文件都将映射为 /api/* 的后端接口。它们不会和页面一起打包。 // pages/api/post.js import { getPosts } from \"lib/posts\"; const Posts = async (req, res) =\u003e { const posts = await getPosts(); res.statusCode = 200; res.setHeader(\"Content-Type\", \"application/json\"); res.end(JSON.stringify(posts)); }; export default Posts; 目前 Next.js 没有提供数据库和测试相关的功能，需自行配置或与其他框架配合使用。 参阅资料 Next.js 官方文档 Next.js 简明教程 手把手带你入门 NextJs 进阶阅读 Next.js Severless 全栈开发: 使用 Next.js、Prisma 和 Vercel Postgres 构建全栈应用程序 使用 Next、Prisma 和 MongoDB 进行身份验证和数据库访问 ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":" 在计算机科学中，函数式编程 是一种编程范式，其中通过应用和组合函数来构造程序。它是一种声明式编程范式，其中函数定义是每个返回一个值的表达式树，而不是一系列更改程序状态的命令性语句。 – wikipedia ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:0:0","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"声明式与命令式 假设我们有个需求：把下面字符串变成每个单词首字母大写。 const string = \"functional programming is great\"; ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:0","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"命令式 如果你没有听说过函数式编程，用传统的编程思路，很自然的写出如下 命令式编程 代码： const string = \"functional programming is great\"; let arrays = string.split(\" \"); let newArray = []; for (let i = 0; i \u003c arrays.length; i++) { let str = arrays[i].slice(0, 1).toUpperCase() + arrays[i].slice(1); newArray.push(str); } const newString = newArray.join(\" \"); 这样当然能完成任务，结果是产生了一堆临时变量。光是变量名就不好想，同时过程中掺杂了大量逻辑，一个函数需要从头读到尾才知道它具体做了什么，并且一旦出问题很难定位。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:1","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"声明式 声明式编程 被看做是形式逻辑的理论，把计算看做推导。常见的声明式编程有数据库查询(SQL 语句)，正则表达式，函数式编程等。函数式编程倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 const string = \"functional programming is great\"; const newString = string .split(\" \") .map((str) =\u003e str.slice(0, 1).toUpperCase() + str.slice(1)) .join(\" \"); 函数式编程的核心思想：通过函数转换数据，组合多个函数来求结果。 对比两种编程思想：命令式编程考虑我该如何做，而声明式编程考虑我要做什么。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:2","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"核心概念-纯函数 函数式编程中的“函数”指满足以下特性的函数，也被称为 纯函数 ： 输出仅取决于输入(无状态，每次的执行结果都是可预测和易测试的) 不产生副作用(只计算输出值，不修改输入值，不做其他任何操作) 因此纯函数更像数学中的函数，只是描述输入与输出之间映射关系的表达式。 一个典型的纯函数设计是 redux 中的 reducer。好的我懂了，但是为什么要强调纯函数呢？因为纯函数的特性决定了它的众多优点： ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:0","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"易读易推理 纯函数容易阅读和推理，因为所有依赖关系都由参数提供。这意味着我们只需阅读函数的声明即可快速了解函数的作用及其依赖关系，而不用担心函数内有其他行为(副作用)。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:1","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"移植性 对于常见的普通函数，同一函数不能直接在移植到别的上下文中使用，通常会为了实现同一类功能而编写不同的函数。 // 普通函数 const signUp = function(attrs) { let user = saveUser(attrs); welcomeUser(user); }; // 依赖 Db const saveUser = function(attrs) { let user = Db.save(attrs); ... }; // 依赖 Email const welcomeUser = function(user) { Email(user, ...); ... }; 编写纯函数的好处是它需要的东西都在输入参数中已经声明，所以它方便移植到别的地方，因为它的依赖关系是很清晰的。 // 纯函数 const signUp = function(Db, Email, attrs) { return function() { let user = saveUser(Db, attrs); welcomeUser(Email, user); }; }; const saveUser = function(Db, attrs) { ... }; const welcomeUser = function(Email, user) { ... }; ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:2","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"引用透明性 因为纯函数内部没有全局引用，所以在任何使用纯函数的地方中把纯函数替换成它的执行结果，都不会对程序的整体运行产生影响，不会产生隐性问题。 const greet = (name) =\u003e { return `hello, ${name}`; }; console.log(greet(\"beijing\")); // 可做如下等价替换 console.log(\"hello, beijing\"); ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:3","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"可缓存 纯函数对相同输入总有相同输出，可以根据输入来做缓存，相同的输入可以不做重新计算。 // 下面的代码我们可以发现相同的输入，再第二次调用的时候都是直接取的缓存 let squareNumber = memoize((x) =\u003e { return x * x; }); squareNumber(4); //=\u003e 16 squareNumber(4); // 从缓存中读取输入值为 4 的结果 //=\u003e 16 squareNumber(5); //=\u003e 25 squareNumber(5); // 从缓存中读取输入值为 5 的结果 //=\u003e 25 这是怎么实现的呢? 请看下面的代码: const memoize = (f) =\u003e { // 由于使用了闭包，所以函数执行完后 cache 不会立刻被回收 const cache = {}; return () =\u003e { let arg_str = JSON.stringify(arguments); // 利用 cache 做一个简单的缓存，当这个参数之前使用过时，我们立即返回结果就行 cache[arg_str] = cache[arg_str] || f.apply(f, arguments); return cache[arg_str]; }; }; ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:4","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"并行处理 纯函数不会访问共享的内存，因此不用担心线程的执行顺序，对任何纯表达式的求值都是线程安全的。 const x = f(a); const y = g(b); const z = h(c); // 线程安全 const result = x + y + z; 前三个表达式之间没有数据依赖关系，它们的执行顺序可以颠倒，或者并行执行也互不干扰。只要它们能在分配给 result 之前执行。 说了这么多优点，其实纯函数的优秀的原因是因为它不使用全局引用： 大神语录 Shared mutable state is the root of all evil(共享的可变状态是万恶之源) – Pete Hunt ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:5","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"应用和组合函数 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:0","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"高阶函数 在数学和计算机科学中，高阶函数 是至少执行以下一项的函数： 将一个或多个函数作为参数(即过程参数) 返回一个函数作为其结果 ES6 中常用的高阶函数包括：map，filter，reduce，find，some，every 等。 // 数组求和 const arr = [5, 7, 1, 8, 4]; // 不使用高阶函数 let sum = 0; for (let i = 0; i \u003c arr.length; i++) { sum = sum + arr[i]; } console.log(sum); //25 // 使用高阶函数 const sum = arr.reduce( (accumulator, currentValue) =\u003e accumulator + currentValue, 0 ); console.log(sum); //25 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:1","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"闭包 通常情况下我们说的 闭包 指的是函数内部的函数。闭包的形成条件： 存在内、外两层函数 内层函数对外层函数的局部变量进行了引用 闭包的用途：定义一些作用域局限的持久化变量，这些变量可用来做缓存或者计算的中间量等。 闭包的弊端：持久化变量不会被正常释放，持续占用内存造成内存浪费，所以需要额外的手动清理机制。 // 匿名函数创造了一个闭包，实现简单的缓存工具 const cache = (function () { const store = {}; return { get(key) { return store[key]; }, set(key, val) { store[key] = val; }, }; })(); console.log(cache); //{get: ƒ, set: ƒ} cache.set(\"a\", 1); cache.get(\"a\"); // 1 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:2","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"柯里化 柯里化 是一种将多参函数拆解为多个单参函数序列的技术。 function curryIt(fn) { // 参数fn函数的参数个数 let n = fn.length; let args = []; return function (arg) { args.push(arg); if (args.length \u003c n) { return arguments.callee; // 返回这个函数的引用 } else { return fn.apply(this, args); } }; } function add(a, b, c) { return [a, b, c]; } // c 是内部匿名函数 const c = curryIt(add); // 可以分步传参 const c1 = c(1); // 将 1 加入 args 中，返回 c 的引用 const c2 = c1(2); const c3 = c2(3); // [1, 2, 3] // 也可以直接调用 const c3 = c(1)(2)(3); // [1, 2, 3] 可以看出，柯里化是一种函数的“预加载”技术，可以通过闭包实现对参数的缓存。 类似的概念有将多参函数拆解为任意参数个数的部分函数应用 ： // Currying f(a)(b)(c) const f = (a) =\u003e (b) =\u003e (c) =\u003e a + b + c; // Partial application f(a)(b,c) const f = (a) =\u003e (b, c) =\u003e a + b + c; ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:3","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"函数组合 柯里化是函数的拆解，函数组合就是多个函数组合为一个函数。compose 简单实现： const compose = (f, g) =\u003e (x) =\u003e f(g(x)); const g = (x) =\u003e x + 1; const f = (x) =\u003e x * 5; const fg = compose(f, g); fg(2); // 15 我们要合成的函数可能不止两个，更通用的 compose 实现： function compose(...args) { return function (x) { let composeFun = args.reduceRight(function (first, second) { //从右边开始迭代，这里实际是把右边放入左边 return second(first); }, x); return composeFun; }; } // 简化为箭头函数 const compose = (...args) =\u003e (x) =\u003e args.reduceRight((f, s) =\u003e s(f), x); 现在我们可以自由组合函数： function addHello(str) { return \"hello \" + str; } function toUpperCase(str) { return str.toUpperCase(); } function reverse(str) { return str.split(\"\").reverse().join(\"\"); } const composeFn = compose(reverse, toUpperCase, addHello); composeFn(\"ttsy\"); // YSTT OLLEH 最后，软件工程没有银弹。每种编程范式各有利弊，我们要根据实际需求选择合适的编程范式。 参阅资料 维基百科 JavaScript 函数式编程入门经典 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:4","tags":["JavaScript"],"title":"浅析函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"如果你想了解 Javascript 的编译原理，那么你就得了解 AST(Abstract Syntax Tree)，目前前端常用的一些插件或者工具，比如 JS 转译、代码压缩、CSS 预处理器、ESLint、Prettier 等功能的实现，都是建立在 AST 的基础之上的。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:0:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"JS 编译流程 首先是 JS 引擎读取 JS 文件中的字符流，然后通过 词法分析 生成 tokens，之后再通过 语法分析 生成 AST，最终 JS 引擎将 AST 编译成字节码或机器码，然后再运行。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"词法分析 词法分析，也称为扫描(scanner)，简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的 Token。Token 是 JS 代码在语法含义上不可分割的最小单元。除此之外，还会过滤掉源程序中的注释和空白字符(换行符、空格、制表符等)。 最终，整个代码被分割进一个 tokens 的数组中。如下代码： const href = \"https://github.com/\"; 经过词法分析生成类似这样的 tokens： [ { \"type\": \"Keyword\", \"value\": \"const\" }, { \"type\": \"Identifier\", \"value\": \"href\" }, { \"type\": \"Punctuator\", \"value\": \"=\" }, { \"type\": \"String\", \"value\": \"'https://github.com/'\" } ] ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:1","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"语法分析 语法分析会将词法分析出来的 tokens 转化成有语法含义的 AST 结构。同时，验证语法，如果语法有错，抛出语法错误。 { \"type\": \"Program\", \"body\": [ { \"type\": \"VariableDeclaration\", \"declarations\": [ { \"type\": \"VariableDeclarator\", \"id\": { \"type\": \"Identifier\", \"name\": \"href\" }, \"init\": { \"type\": \"Literal\", \"value\": \"https://github.com/\", \"raw\": \"'https://github.com/'\" } } ], \"kind\": \"const\" } ], \"sourceType\": \"script\" } 这里 可以看到代码的转换。这里 有 tokens 和 AST 的简单 JS 实现。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:2","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"AST 节点规范 业界已经有很多成熟的解析库，常用的库都集成在 AST Explorer 中，可以实现代码与符合 The ESTree Spec 的 AST 之间的相互转换。下面对规范里的 ES5 的 API 做简要说明。 ESTree AST 中每个节点都要实现以下的 Node 接口，loc 字段表示相关代码的位置信息： interface Node { type: string; loc?: SourceLocation; } interface SourceLocation { source: string | null; start: Position; end: Position; } interface Position { line: number; // \u003e= 1 column: number; // \u003e= 0 } ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Programs 根节点 interface Program \u003c: Node { type: \"Program\"; body: [ Statement ]; } AST 的顶部， body 包含了多个 Statement(语句)节点。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:1","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Patterns 模式 interface Pattern \u003c: Node { } 在 ES6 的解构赋值中有意义，如 let {name} = user，其中{name}部分为 ObjectPattern, 对于 ES5，唯一的子类是 Identifier ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:2","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Expression 表达式 interface Expression \u003c: Node { } 表达式，子类很多，有二元表达式(n*n)、函数表达式(var fun = function(){})、数组表达式(var arr = [])、对象表达式(var obj = {})、赋值表达式( a=1)等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:3","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Identifier 标识符 interface Identifier \u003c: Expression, Pattern { type: \"Identifier\"; name: string; } 写代码时自定义的名称，如变量名，函数名，属性名等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:4","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Literal 字面量 interface Literal \u003c: Expression { type: \"Literal\"; value: string | boolean | null | number | RegExp; } 从 value 的类型可以看出，字面量就是值，他的类型有字符串，布尔，数值，null 和正则。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:5","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Statement 语句 interface Statement \u003c: Node { } 语句，子类有很多， 块语句、 if/switch 语句、 return 语句、 for/while 语句、 with 语句等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:6","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Declaration 声明 interface Declaration \u003c: Statement { } 声明，子类主要有变量申明、函数声明。 ES6，7，8，… 的更多类型补充可以看这一篇 文章 。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:7","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"AST 的运用 将原代码转化为 AST，修改 AST，再重新转化为新代码就能完成代码转译。Babel 将最新语法的 JS 代码转化为 ES5 的原理就是这样的。 Babel原理示意图Babel原理示意图 \" Babel原理示意图 Babel 操作 AST 会用到以下工具包： @babel/parser 用于将代码转换为 AST @babel/traverse 用于对 AST 的遍历，包括节点增删改查、作用域等处理 @babel/generator 用于将 AST 转换成代码 @babel/types 用于 AST 节点操作的 Lodash 式工具库,各节点构造、验证等 更多 api 详见 Babel 手册 。 下面是用一个例子讲述具体操作步骤： var obj = { fn() { console.log(\"hello\"); }, }; 我们需要把以上代码转换成下面这样： const obj = { fn() { console.log(\"hello\", \"world\"); }, }; 将两份代码在 AST Explorer 中打开。选择 @babel/parser 为解析器，右边有选项隐藏不需要的属性。对比两颗 AST 发现差异是 kind 和 arguments，因此代码如下： const parser = require(\"@babel/parser\"); const traverse = require(\"@babel/traverse\").default; const generate = require(\"@babel/generator\").default; const t = require(\"@babel/types\"); let sourceCode = ` var obj = { fn(){ console.log(\"hello\") } } `; let ast = parser.parse(sourceCode); traverse(ast, { VariableDeclaration(path) { let { kind } = path.node; if (kind === \"var\") { kind = \"const\"; } }, CallExpression(path) { let { callee, arguments } = path.node; if ( t.isMemberExpression(callee) \u0026\u0026 callee.object.name === \"console\" \u0026\u0026 callee.property.name === \"log\" ) { arguments.push(t.stringLiteral(\"world\")); } }, }); console.log(generate(ast).code); 这里 还有更多例子。 参阅资料 JS 之 执行过程 JS 语法树学习 Javascript 抽象语法树 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:3:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Webpack 是一个前端构建工具，前端构建工具的作用就是把开发环境的代码转化成运行环境代码。一般来说，开发环境的代码是为了更好的阅读，而运行环境的代码则是为了能够更快地执行。因此开发环境和运行环境的代码形式也不相同。比如，开发环境的代码，要通过混淆压缩后才能放在线上运行，这样代码体积更小，但对代码执行不会有任何影响。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:0:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"应用场景 一般的构建工具可以处理但不限于以下场景： 代码压缩 将 JS、CSS 代码混淆压缩，让代码体积更小，加载更快。 语法编译 编写 CSS 时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等，这些标准目前都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。 模块化处理 CSS 和 JS 的模块化语法，目前无法被浏览器兼容。因此开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如使用 Webpack、Rollup 等处理 JS 模块化。 使用 webpack，构建的前端项目是高度可配置的(替换 react，vue 默认 cli 工具)。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:1:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"核心概念 以下概念提取自 webpack 的官方文档，学习更多细节请参阅官方文档 。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Entry 入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。 进入入口起点后, webpack 会找出有哪些模块和库是入口起点(直接和间接)依赖的。 每个依赖项随即被处理,最后输出到称之为 bundles 的内存文件中。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:1","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Output output 属性指定 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。 基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:2","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Module 模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:3","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Chunk 代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:4","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Loader loader 让 webpack 能够去处理那些非 JS 文件(webpack 自身只理解 JS)。 loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。 本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图(和最终的 bundle)可以直接引用的模块。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:5","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Plugin loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。 插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:6","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"构建流程 Webpack 在启动后，会从 Entry 开始，递归解析 Entry 依赖的所有 Module，每找到一个 Module，就会根据 Module.rules 里配置的 Loader 规则进行相应的转换处理，对 Module 进行转换后，再解析出当前 Module 依赖的 Module，这些 Module 会以 Entry 为单位进行分组，即为一个 Chunk。因此一个 Chunk 就是一个 Entry 及其所有依赖的 Module 合并的结果。最后 Webpack 会将所有的 Chunk 转换成文件输出 Output。在整个构建流程中，Webpack 会在恰当的时机执行 Plugin 里定义的逻辑，从而完成 Plugin 插件的优化任务。 简单的解释就是这样，详细构建流程请看这篇文章 。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:3:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"配置入门 下面以一个配置一个 react 开发环境为例，学习 webpack 的基本配置方法。 新建文件夹 webpack-demo，终端进入文件夹执行 npm init 初始化项目。 安装 react: yarn add react react-dom 安装 webpack: yarn add webpack webpack-cli webpack-dev-server -D webpack-cli 提供了一组用于运行和设置 webpack 的命令 Webpack-dev-server 提供 http 服务，实时重载(hot 模式)，cors 配置，端口配置等 安装 babel: yarn add @babel/core @babel/preset-react @babel/preset-env babel-loader -D @babel/core 是核心依赖项 @babel/preset-react 添加对 JSX 支持 @babel/preset-env 添加对 ES6 的支持 babel-loader 使用 Babel 和 webpack 转换 react 代码为 JS 安装 CSS Loaders: yarn add css-loader style-loader -D css-loader 从收集 CSS 并将 CSS 转化为字符串 style-loader 将从 css-loader 中获得的字符串嵌入在 html 中的 style 标签中 安装插件: yarn add html-webpack-plugin -D html-webpack-plugin 用于将生成的 output 文件嵌入到指定 html 文件 准备文件: 在根文件夹下创建 src 和 dist 文件夹，在 src 文件夹下创建 main.js，app.js，index.css， 在 dist 文件夹下创建 index.html。 创建 webpack.config.js，这是默认的 webpack 配置文件： //webpack.config.js const path = require(\"path\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); module.exports = { entry: \"./src/main.js\", output: { path: path.join(__dirname, \"/dist\"), filename: \"bundle.js\", }, devServer: { port: 8080, }, module: { rules: [ { test: /\\.jsx?$/, exclude: /node_modules/, loader: \"babel-loader\", }, { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"], }, ], }, plugins: [ new HtmlWebpackPlugin({ template: \"./dist/index.html\", }), ], }; “entry”: 这是入口 js，webpack 将从此处开始打包。 “output”: 打包的文件将位于 “/dist/bundle.js”。 “devServer”: 它定义了 weback-dev-server 的配置，开发服务器的默认端口是 8080。 模块规则-这些是转译规则： “test”: 正则表达式，指定哪种文件需要通过 loader 转译。 “exclude”: 指定 loader 应忽略的文件。 “use”: 应用 loader 的数组，注意是从右往左加载 loader。 babel 转译的配置文件 .babelrc： { \"presets\":[\"@babel/preset-env\", \"@babel/preset-react\"] } 在 package.json 中添加脚本： \"start\": \"webpack-dev-server --mode development --open --hot\", \"build\": \"webpack --mode production\" 将创建的空文件补充完整： \u003c!-- dist/index.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003eReact Web\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c!-- html-webpack-plugin 插件生成如下标签 \u003cscript src='bundle.js'\u003e\u003c/script\u003e --\u003e \u003c/body\u003e \u003c/html\u003e // src/main.js import React from \"react\"; import ReactDOM from \"react-dom\"; import App from \"./App.js\"; ReactDOM.render(\u003cApp /\u003e, document.getElementById(\"root\")); // src/app.js import React, { Component } from \"react\"; import \"./index.css\"; class App extends Component { render() { return ( \u003cdiv\u003e \u003ch1\u003eHello!!\u003c/h1\u003e \u003ch2\u003eWelcome to your React App..!\u003c/h2\u003e \u003c/div\u003e ); } } export default App; /* src/index.css */ * { margin: 0; padding: 0; } 运行代码: yarn start，打包文件: yarn run build，动手试试吧！ 参阅资料 webpack 官方文档 webpack 打包原理? 看完这篇你就懂了! 实现一个简单的 Webpack ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:4:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"WebSocket 是一种服务端和客户端之间的双向通信协议，和 HTTP 一样是基于 TCP 协议的应用层协议，并且 WebSocket 在握手阶段依赖于 HTTP 连接。 WebSocket 广泛应用于多用户实时交流，服务端数据持续变化的场景。比如社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等需要高实时的场景。 学习 WebSocket，请看这篇教程 。在 node.js 中，通常使用 socket.io 这个库。socket.io 封装了 WebSocket 服务端 JS 库，同时也提供客户端的 JS 库。Socket.IO 支持以事件为基础的实时双向通讯。它可以兼容各种浏览器或移动设备，从而让开发者可以聚焦到功能的实现而不是平台的兼容性。 ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:0:0","tags":["Network"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"Socket.IO 常用 api 常用服务端 api： socket.on(\"eventName\", (msg) =\u003e {}); /*服务器端监听客户端emit的事件，事件名称可以和客户端是重复的，但是并没有任何关联。 socket.io内置了一些事件比如connection，disconnect，exit事件*/ socket.emit(\"eventName\", msg); //服务端各自的socket向各自的客户端发送数据 socket.broadcast(\"eventName\", msg); //服务端向其他客户端发送消息，不包括自己的客户端 socket.join(channel); //创建一个频道（非常有用，尤其做分频道的时候，比如斗地主这种实时棋牌游戏） io.sockets.in(channel); //加入一个频道 io.to(channel).emit(\"eventName\", msg); //向一个频道发送消息，包括自己的客户端 socket.broadcast.to(channel).emit(\"eventName\", msg); //向一个频道发送消息，不包括自己的客户端 io.emit(\"eventName\", msg); //向所有客户端发送数据 io.sockets.adapter.rooms; //获取所有的频道 常用客户端 api： //客户端 io.connect(url); //客户端连接上服务器端，可简写为 io(url)，无跨域时为 io() socket.on(\"eventName\", (msg) =\u003e {}); //客户端监听服务器端事件 socket.emit(\"eventName\", msg); //客户端向服务器端发送数据 socket.disconnect(); //客户端断开链接 更多的 api 请参阅 Socket.IO 的官方文档 。这里有一篇搭建实时聊天室的文章 ，注意文中的 index.html 和 client.js 中的线上服务器地址 realtime.plhwin.com:3000 已经没有了，改为本地地址 localhost:3000 就能运行代码了。index.html 里的 \u003cscript src=\"/socket.io/socket.io.js\"\u003e\u003c/script\u003e 指向的文件是其实是 \u003cscript src=\"../server/node_modules/socket.io-client/dist/socket.io.js\"\u003e\u003c/script\u003e 整体的开发思路就是服务端和客户端其中一端触发事件，另一端就监听事件。文中的示例程序只用到了事件触发 socket.emit 和事件监听 socket.on。下文的示例程序展示了 Socket.IO 中更多 api 的用法。用户进入聊天室时需要选择房间，进入相同房间的用户才能内部交流，不同房间之间的内部信息不能互通。 ChatCord实时聊天室ChatCord实时聊天室 \" ChatCord实时聊天室 ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:1:0","tags":["Network"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"服务端实现 WebSocket 依赖于 http，这里需要安装 socket.io 和 express // server.js const path = require(\"path\"); const http = require(\"http\"); const express = require(\"express\"); const socketio = require(\"socket.io\"); const formatMessage = require(\"./utils/messages\"); const { userJoin, getCurrentUser, userLeave, getRoomUsers, } = require(\"./utils/users\"); const app = express(); const server = http.createServer(app); const io = socketio(server); // Set static folder app.use(express.static(path.join(__dirname, \"public\"))); const botName = \"ChatCord Bot\"; // Run when client connects io.on(\"connection\", (socket) =\u003e { socket.on(\"joinRoom\", ({ username, room }) =\u003e { const user = userJoin(socket.id, username, room); socket.join(user.room); // Welcome current user socket.emit(\"message\", formatMessage(botName, \"Welcome to ChatCord!\")); // Broadcast when a user connects socket.broadcast .to(user.room) .emit( \"message\", formatMessage(botName, `${user.username}has joined the chat`) ); // Send users and room info io.to(user.room).emit(\"roomUsers\", { room: user.room, users: getRoomUsers(user.room), }); }); // Listen for chatMessage socket.on(\"chatMessage\", (msg) =\u003e { const user = getCurrentUser(socket.id); io.to(user.room).emit(\"message\", formatMessage(user.username, msg)); }); // Runs when client disconnects socket.on(\"disconnect\", () =\u003e { const user = userLeave(socket.id); if (user) { io.to(user.room).emit( \"message\", formatMessage(botName, `${user.username}has left the chat`) ); // Send users and room info io.to(user.room).emit(\"roomUsers\", { room: user.room, users: getRoomUsers(user.room), }); } }); }); const PORT = process.env.PORT || 3000; server.listen(PORT, () =\u003e console.log(`Server running on port ${PORT}`)); ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:2:0","tags":["Network"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"客户端实现 需要先在 html 中引入 socket.io-client，才能使用 io \u003c!-- public/chat.html --\u003e \u003cscript src=\"/socket.io/socket.io.js\"\u003e\u003c/script\u003e \u003cscript src=\"js/main.js\"\u003e\u003c/script\u003e 这里的静态资源文件是由 express 加载的，没有跨域，可省略 io 括号里的地址 // public/js/main.js const chatForm = document.getElementById(\"chat-form\"); const chatMessages = document.querySelector(\".chat-messages\"); const roomName = document.getElementById(\"room-name\"); const userList = document.getElementById(\"users\"); // Get username and room from URL const { username, room } = Qs.parse(location.search, { ignoreQueryPrefix: true, }); const socket = io(); // Join chatroom socket.emit(\"joinRoom\", { username, room }); // Get room and users socket.on(\"roomUsers\", ({ room, users }) =\u003e { outputRoomName(room); outputUsers(users); }); // Message from server socket.on(\"message\", (message) =\u003e { console.log(message); outputMessage(message); // Scroll down chatMessages.scrollTop = chatMessages.scrollHeight; }); // Message submit chatForm.addEventListener(\"submit\", (e) =\u003e { e.preventDefault(); // Get message text const msg = e.target.elements.msg.value; // Emit message to server socket.emit(\"chatMessage\", msg); // Clear input e.target.elements.msg.value = \"\"; e.target.elements.msg.focus(); }); // Output message to DOM function outputMessage(message) { const div = document.createElement(\"div\"); div.classList.add(\"message\"); div.innerHTML = `\u003cp class=\"meta\"\u003e${message.username}\u003cspan\u003e${message.time}\u003c/span\u003e\u003c/p\u003e \u003cp class=\"text\"\u003e ${message.text}\u003c/p\u003e`; document.querySelector(\".chat-messages\").appendChild(div); } // Add room name to DOM function outputRoomName(room) { roomName.innerText = room; } // Add users to DOM function outputUsers(users) { userList.innerHTML = ` ${users.map((user) =\u003e `\u003cli\u003e${user.username}\u003c/li\u003e`).join(\"\")}`; } 更多内容请看源码。 附：源码地址 参阅资料 WebSocket 教程 Socket.IO 官方文档 ChatCord 源码 ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:3:0","tags":["Network"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"最近，Facebook 官方开源了一个状态管理库 Recoil，我们来学习一下。Recoil 是基于 Immutable 的数据流管理方案，这是它值得学习的重要原因。Recoil 非常易于学习，它的 API 简单强大，对于已经习惯使用 hooks 的人来说很自然。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:0:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"核心概念 Recoil 中的核心概念只有 Atom(原子状态) 和 Selector(派生状态)。 Recoil状态管理示意图Recoil状态管理示意图 \" Recoil状态管理示意图 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"Atom Atom 是状态的单位。它们可更新也可订阅。当 atom 被更新，每个被订阅的组件都将使用新值进行重渲染。如果多个组件使用相同的 atom，则这些组件共享 atom 的状态。可以使用 atom 替代组件内部的 state。atom 也可以在运行时创建。 Atom 是使用 atom 函数创建的： function atom\u003cT\u003e({ key: string, default: T | Promise\u003cT\u003e | RecoilValue\u003cT\u003e, dangerouslyAllowMutability?: boolean, }): RecoilState\u003cT\u003e key：标识 atom 的字符串，必须相对于其他 atom/selector 是唯一值 default：atom 的初始值，可以是静态值，Promise，或返回值类型相同的另一个 atom/seletor 最后一个参数是允许 Mutable，由于 Recoil 默认的 Immutable 特性带来的可预测性更利于调试和维护，一般不设置这个值 定义一个 atom，用来获取输入字符: const textState = atom({ key: \"textState\", // unique ID (with respect to other atoms/selectors) default: \"\", // default value (aka initial value) }); ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:1","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"Selector selector 是一个纯函数，入参为 atom 或其他 selector。selector 被用于计算基于 atom 的派生数据，这使得我们避免了冗余 state，将最小粒度的状态存储在 atom 中，而其它所有内容根据最小粒度的状态进行有效计算。当上游 atom/selector 更新时，将重新执行 selector 函数。组件可以像 atom 一样订阅 selector，当 selector 发生变化时，重新渲染相关组件。 Selector 是使用 selector 函数创建的： function selector\u003cT\u003e({ key: string, get: ({ get: GetRecoilValue }) =\u003e T | Promise\u003cT\u003e | RecoilValue\u003cT\u003e, set?: ( { get: GetRecoilValue, set: SetRecoilState, reset: ResetRecoilState, }, newValue: T | DefaultValue, ) =\u003e void, dangerouslyAllowMutability?: boolean, }): RecoilValueReadOnly\u003cT\u003e | RecoilState\u003cT\u003e type ValueOrUpdater\u003cT\u003e = T | DefaultValue | ((prevValue: T) =\u003e T | DefaultValue); type GetRecoilValue = \u003cT\u003e(RecoilValue\u003cT\u003e) =\u003e T; type SetRecoilState = \u003cT\u003e(RecoilState\u003cT\u003e, ValueOrUpdater\u003cT\u003e) =\u003e void; type ResetRecoilState = \u003cT\u003e(RecoilState\u003cT\u003e) =\u003e void; key：标识 selector 的字符串，必须相对于其他 atom/selector 是唯一值 get：get 参数中 get，可以从其他 atom/selector 取值，从而利用依赖关系计算 seletor，传递给此函数的 atom/selector 隐式添加到这个 seletor 的依赖项列表中 set?：设置了该属性，selector 才会返回可写的 state 定义一个 selector，依赖的 atom 是我们上面定义的 textState，用来获取输入字符长度 : const charCountState = selector({ key: \"charCountState\", // unique ID (with respect to other atoms/selectors) get: ({ get }) =\u003e { const text = get(textState); return text.length; }, }); 测试 atom 和 selector 示例 demo 从组件的角度来看，selector 和 atom 具有相同的功能，因此可以交替使用。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:2","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"订阅或更新状态 前面讲述如何用 atom 和 selector 定义 state，下面是 state 的取值和更新函数： useRecoilState：返回 atom/selector 的值和 set 函数，类似 useState。 useRecoilValue：仅返回 atom/selector 的值。 useSetRecoilState：仅返回 atom/seletor 的 set 函数。 useResetRecoilState：重置 atom/selector 到默认值并读取。 在组件中使用这些 hooks 与使用其他 hooks 的方式基本相同： import React from \"react\"; import { atom, useRecoilState, selector, useRecoilValue } from \"recoil\"; const textState = atom({ key: \"textState\", // unique ID (with respect to other atoms/selectors) default: \"\", // default value (aka initial value) }); const charCountState = selector({ key: \"charCountState\", // unique ID (with respect to other atoms/selectors) get: ({ get }) =\u003e { const text = get(textState); return text.length; }, }); export const CharacterCounter = () =\u003e { const [char, setChar] = useRecoilState(textState); // selector 没有定义 set，用 useRecoilValue 取值 const charCount = useRecoilValue(charCountState); return ( \u003cdiv\u003e \u003cinput type=\"text\" value={char} onChange={(e) =\u003e setChar(e.target.value)} /\u003e \u003cdiv\u003eEcho: {char}\u003c/div\u003e \u003cdiv\u003eCharacter Count: {charCount} \u003c/div\u003e \u003c/div\u003e ); }; export default CharacterCounter; atom，selector 的 state 的取值和更新函数是相同的，selector 未定义 set 只能用 useRecoilValue 取值，定义 set 之后也能用 useRecoilState，因此 atom 应该是基于 selector 的一个特定封装，帮我们封装好了 set，get，而无须自定义。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:2:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"异步支持 在 selector 的数据流图中, Recoil 可以让你随意的混合使用同步和异步函数。只需从 selector get 回调中返回一个 Promise，接口完全一样。因为这些只是 selector，其他的 selector 也可以依赖它们来进一步变更数据。selector 是纯函数，是对只读数据库查询进行建模的好方法，其中重复查询可提供一致的数据。 import React from \"react\"; import { selector, useRecoilValue } from \"recoil\"; const myQuery = selector({ key: \"MyDBQuery\", get: async () =\u003e { const response = await fetch(getMyRequestUrl()); return response.json(); }, }); function QueryResults() { const queryResults = useRecoilValue(myQuery); return \u003cdiv\u003e{queryResults.foo}\u003c/div\u003e; } function ResultsSection() { return ( \u003cReact.Suspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e \u003cQueryResults /\u003e \u003c/React.Suspense\u003e ); } atom 是基于 selector 封装，也支持 Promise 做默认 state。不过官方的建议是当其从其他状态或异步请求时派生的 state，应该使用 selector。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:3:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"参数查询 有时我们希望通过传递参数动态定义 state，你可以使用 atomFamily 或 selectorFamily 实现这类需求， atom 与 atomFamily，selector 与 selectorFamily 的区别仅仅是定义 state 的时候是否需要参数： const myDataQuery = selectorFamily({ key: \"MyDataQuery\", get: (queryParameters) =\u003e async ({ get }) =\u003e { const response = await asyncDataRequest(queryParameters); if (response.error) { throw response.error; } return response.data; }, }); function MyComponent() { const data = useRecoilValue(myDataQuery({ userID: 132 })); return \u003cdiv\u003e...\u003c/div\u003e; } 目前 Recoil 还属于实验阶段，能确定的是 Recoil 将兼容 React 并发模式。 我们可以在 Recoil 中学到 React Hook 时代的状态管理的基本模式： state 的读与写分离，做到最优按需渲染。 原子存储的数据相互无关联，关联的数据使用派生值的方式推导。 派生的值必须严格缓存，并在命中缓存时引用保证严格相等。 参阅资料 Recoil 官方文档 精读《recoil》 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:4:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"权限管理是所有后台系统的都会涉及的一个重要组成部分，主要目的是对不同的人访问资源进行权限的控制，避免因权限控制缺失或操作不当引发的风险问题，如操作错误，隐私数据泄露等问题。 迄今为止最为普及的权限设计模型是 RBAC 模型,基于角色的访问控制（Role-Based Access Control)，而 RBAC 模型又可以细分为 RBAC0，RBAC1，RBAC2，RBAC3。 本文介绍 RBAC0, 这是权限最基础也是最核心的模型，其他复杂模型也是建立在 RBAC0 之上的。关于 RBAC 还有很多重要理论，具体可参考知乎上的这篇 权限系统设计 和这篇 RBAC 理念 。本文将带领读者体会 RBAC0 的实践运用，实现 RBAC0 的关键在建立 用户-角色-权限 之间的多对多关系。 RBAC权限模型RBAC权限模型 \" RBAC权限模型 ","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:0:0","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"实例 请注意，本文不涉及具体代码讲解。如需具体代码的讲解，请移步到 后端代码讲解 和 前端代码讲解 ，在这两篇文章末尾附有源码地址。作者的讲解逻辑严密，注重细节，非常优秀，无需我再赘述。本文只演示实例程序，带领读者理解 RBAC0 权限设计模型。 实例程序将网站用户分为三个角色: Admin(管理员), Moderator(版主), User(普通用户)。 所有页面路由：home, rigister, login, profile, user, mod, admin ","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:0","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"正常访问截图 对所有未登录用户开放的页面(访客页面): home, register, login 访客权限展示的页面访客权限展示的页面 \" 访客权限展示的页面 对网站用户开放的页面： 对 User 开放的页面(用户页面)：访客页面, profile, user 用户权限展示的页面用户权限展示的页面 \" 用户权限展示的页面 对 Moderator 开放的页面：用户页面, mod(导航栏中增加 Moderator Board) 对 Admin 开放的页面：用户页面, admin(导航栏中增加 Admin Board) 正常访问其他页面的更多截图看 这里 ，或者自己运行前后端代码，修改用户角色需用 postman 向后端接口发送 http 请求或者直接修改数据表。 ","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:1","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"越权访问截图 未登录用户访问 user 页面： 未登录用户访问user页面未登录用户访问user页面 \" 未登录用户访问user页面 User 访问 admin 页面： 登录用户访问admin页面登录用户访问admin页面 \" 登录用户访问admin页面 User, Admin 访问 mod 页面, Moderator 访问 admin 页面的显示结果同理。 当一个用户同时具有 User, Moderator, Admin 角色时，就有了所有页面的访问权限。 访问所有页面的权限访问所有页面的权限 \" 访问所有页面的权限 根据用户角色来决定页面的数据，这样就实现了 RBAC0 的基本模型。 参阅资料 可能是史上最全的权限系统设计 RBAC 理念 实例程序讲解 --\r","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:2","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"这次使用 antd 和 TypeScript 实践一个简单 todolist, 作为简单的练手 Demo。这次的代码中暂时还没有实现数据持久化，状态管理等基础功能，只是把页面上能够看到的功能实现了。因为后续我可能会结合这个 Demo 尝试其他的数据流管理方案。 页面长这样，响应 pc 端，移动端: pc端页面展示pc端页面展示 \" pc端页面展示 移动端页面展示移动端页面展示 \" 移动端页面展示 页面上有一个搜索框，过滤列表项。点击添加按钮，弹出会话框，添加列表数据。下面是三个标签选项，点击不同的标签显示不同的列表内容。列表中每一项中的三个图标分别实现的是编辑数据，修改完成状态和删除这一项的功能。 这个 todolist 实例只实现了 Todo，ModalForm(对话框)，TodoList(标签选项下的列表) 组件。ModalForm，TodoList 是 Todo 的子组件。这三个组件就足够完成上述的功能了。 ","date":"2020-06-30","objectID":"/2020-06-30-antd/:0:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"定义数据模型 export interface ITodo { id: number; text: string; done: boolean; } ","date":"2020-06-30","objectID":"/2020-06-30-antd/:1:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"状态提升 由于没有引入 redux 状态管理库，为了方便组件间的数据传递，一个比较好的做法是将多个组件需要共享的状态提升到它们最近的父组件上(状态提升)。这里的父组件是 Todo 组件。 需要共享的状态有： 1.编辑 TodoList 组件中的 todo 时，需要让对话框显示(showModal) 2.编辑 TodoList 组件中的 todo 时，弹出的对话框需要获得 todo.id(todoId) 3.根据弹出对话框的位置，决定对话框的标题(modalTitle) 先在 Todo 组件中定义需要共享的数据字段： // Todo.ts const [showModal, setShowModal] = useState(false); const [todoId, setTodoId] = useState(1); const [modalTitle, setModalTitle] = useState(\"\"); 弹出的对话框可能是添加或编辑 todo： export enum ModalType { Edit = \"EDIT\", Add = \"ADD\", } 根据弹出对话框的位置决定对话框标题: // Todo.ts const onShowModal = (type: ModalType, id?: number) =\u003e { if (type === ModalType.Add) { setModalTitle(\"添加任务\"); } if (type === ModalType.Edit) { setModalTitle(\"编辑任务\"); setTodoId(id!); //记录 TodoList 组件传递的 todoId } setShowModal(true); }; 如果是在 Todo 组件的添加按钮: //Todo.ts \u003cButton type=\"primary\" className={styles.newTodo} onClick={() =\u003e onShowModal(ModalType.Add)} \u003e 添加 \u003c/Button\u003e 在 Todo 组件点击添加按钮时，显示对话框组件，提交表单时用内部实现的 itemId 作为 todo.id： // ModalForm.ts const ModalForm: FC\u003cIModalFormProps\u003e = (props) =\u003e { const { visible, onClose, addTodo, modalTitle } = props; const [itemId, setItemId] = useState(1); const [form] = Form.useForm(); const onFinish = () =\u003e { const text: string = form.getFieldValue('content').trim(); if (modalTitle === '添加任务') { addTodo(itemId, text, false); setItemId(itemId =\u003e itemId + 1); } form.setFieldsValue({ content: '' }); onClose(); }; 在 ts 中需要用 interface 声明父组件传过来的 props 的类型。 // ModalForm.ts interface IModalFormProps { visible: boolean; modalTitle: string; onClose: () =\u003e void; addTodo: (id: number, text: string, flag: boolean) =\u003e void; } 如果是在 TodoList 中的编辑按钮：Todo 组件将 onShowModal 方法传递给 TodoList 子组件，TodoList 就能让对话框组件显示并传递 todoId 给 Todo 组件： // TodoList.ts \u003cEditOutlined className={styles.icon} onClick={() =\u003e onShowModal(ModalType.Edit, todo.id)} /\u003e 在弹出编辑对话框之前，Todo 组件将已经获取到 todoId 传递给对话框组件: // Todo.ts \u003cModalForm modalTitle={modalTitle} todoId={todoId} visible={showModal} onClose={onClose} addTodo={addTodo} updateText={updateText} /\u003e 得到 todoId 就能在对话框提交时更新 todo 了，对话框组件中完善提交表单方法: // ModalForm.ts const { visible, onClose, addTodo, modalTitle, todoId, updateText } = props; const onFinish = () =\u003e { const text: string = form.getFieldValue(\"content\").trim(); if (modalTitle === \"添加任务\") { addTodo(itemId, text, false); setItemId((itemId) =\u003e itemId + 1); } if (modalTitle === \"编辑任务\") { updateText(todoId, text); } form.setFieldsValue({ content: \"\" }); onClose(); }; ","date":"2020-06-30","objectID":"/2020-06-30-antd/:2:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"列表的增删改查 先在 Todo 组件中定义列表数据状态： //Todo.ts const [lists, setlists] = useState\u003cITodo[]\u003e([]); 接下来实现列表的增删改查： // Todo.ts const addTodo = (id: number, text: string, done: boolean) =\u003e { const Item = { id, text, done }; setlists([Item, ...lists]); message.success(\"新增成功\"); }; const deleteTodo = (id: number) =\u003e { const newlists = lists.filter((i) =\u003e i.id !== id); setlists([...newlists]); message.success(\"删除成功\"); }; const toggleDone = (id: number) =\u003e { const newlists = lists.map((i) =\u003e i.id === id ? { ...i, done: !i.done, } : i ); setlists([...newlists]); }; const updateText = (id: number, text: string) =\u003e { const newlists = lists.map((i) =\u003e i.id === id ? { ...i, text, } : i ); setlists([...newlists]); message.success(\"编辑成功\"); }; 代办项，已完成，清单三个标签过滤列表： // Todo.ts const todoList = lists.filter((item) =\u003e !item.done); const doneList = lists.filter((item) =\u003e item.done); ","date":"2020-06-30","objectID":"/2020-06-30-antd/:3:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"实现搜索功能 先在 Todo 组件中定义搜索数据状态： //Todo.ts const [searchText, setSearchText] = useState(\"\"); 实现按搜索字段过滤数据的方法： // Todo.ts const getFilter = (lists: ITodo[], searchText: string) =\u003e { if (searchText.trim() !== \"\") { return lists.filter((todo) =\u003e todo.text.toLowerCase().includes(searchText.toLowerCase()) ); } return lists; }; Todo 组件将列表数据先用 getFilter 方法过滤再传递给 TodoList 子组件： //Todo.ts \u003cTabs defaultActiveKey=\"1\" size={\"large\"}\u003e \u003cTabPane tab={\u003cBadge status=\"warning\" text=\"待办项\" /\u003e} key=\"1\"\u003e \u003cTodoList lists={getFilter(todoList, searchText)} updateText={updateText} toggleDone={toggleDone} deleteTodo={deleteTodo} onShowModal={onShowModal} /\u003e \u003c/TabPane\u003e \u003c/Tabs\u003e 上面是待办项列表的数据传递，如果是已完成或清单组件，只需将 getFilter 的第一个参数替换为 doneList 或 lists，所有功能就完成了。 续：发现了一个状态管理库 Easy Peasy , 个人感觉比 redux 简洁。这里有一个 todolist 例子。 附：源码地址 ","date":"2020-06-30","objectID":"/2020-06-30-antd/:4:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"网络论坛，常简称为论坛，又称讨论区、讨论版等，是种提供在线讨论的程序，或由这些程序建立的以在线讨论为主的网站。本文记录如何用 Spring Boot 结合 MyBatis-Plus 实现论坛中常见的 API 接口。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:0:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 API","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"数据分页获取 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 API","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"引入依赖，连接数据库 在 spring-boot 项目的根目录 pom.xml 添加依赖，相关依赖有 lombok, mybatis-plus, druid, swagger, mysql 驱动等。 \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.9\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e2.8.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e2.8.0\u003c/version\u003e \u003c/dependency\u003e 然后在 src/main/resources 文件夹下添加 application.properties 或 application.yml 文件配置数据库连接。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:1","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 API","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建数据表 本地连接数据库，然后导入脚本，创建数据表。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:2","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 API","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建 entity 及 mapper 创建文章实体(entity) @Data @EqualsAndHashCode(callSuper = false) @Accessors(chain = true) @ApiModel(value = \"Article对象\", description = \"\") public class Article implements Serializable { private static final long serialVersionUID = 1L; @TableId(value = \"id\", type = IdType.AUTO) private Integer id; @ApiModelProperty(value = \"标题\") private String title; @ApiModelProperty(value = \"内容\") private String content; @ApiModelProperty(value = \"用户主键\") private Integer uId; @ApiModelProperty(value = \"热度\") private Integer score; @ApiModelProperty(value = \"版块主键/为0时表示未设置\") private Integer bId; @JsonFormat(pattern = \"yyyy-MM-dd\", timezone = \"GMT+8\") private Date createDate; @JsonFormat(pattern = \"yyyy-MM-dd\", timezone = \"GMT+8\") private Date updateDate; @TableField(exist = false) private User user; @TableField(exist = false) private Block block; } lombok 的注解： @Data 相当于 @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode 这 5 个注解的合集。 存在继承,编译时有警提示，加上@EqualsAndHashCode(callSuper=false), 只比较当前的类字段。 @Accessors(chain = true)链式调用为真, setter 方法返回当前对象的序列化对象，便于存储，便于传输。 mybatis-plus 的注解： @TableId 主键的映射,主键的生成策略,自动生成。 @TableField(exist = false) 不映射数据表字段。 swagger 的注解： @Api 开头的是 swagger 的注解。 对应的 Mapper 只需继承 BaseMapper，基本的 crud 方法 mybatis-plus 已经封装好了。 @Mapper @Component public interface ArticleMapper extends BaseMapper\u003cArticle\u003e { } @Component 注解代表需要被 Spring IoC 容器管理，才能实现依赖注入。 然后在启动类中加入 @MapperScan(\"\") 就可以完成 spring-boot 到数据表的映射。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:3","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 API","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建 service 创建 service，我们想要分页获取数据，先配置 mybatis-plus 分页插件： @Configuration @MapperScan(\"com.forum.buge_server.mapper*\") public class MybatisPlusConfig { /** * 加载分页插件 * * @return */ @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } } 定义 service 接口 public interface ArticleService extends IService\u003cArticle\u003e { IPage\u003cArticle\u003e getArticlePageing(IPage\u003cArticle\u003e iPage, LambdaQueryWrapper\u003cArticle\u003e wrapper); } service 实现类 在实现类里注入 mapper, 完成分页获取数据。selectPage 方法接收两个参数，第一个是 IPage 对象，第二个参数是条件构造器 QueryWrapper。我们需要在 controller 中传递这两个参数。 @Service public class ArticleServiceImpl extends ServiceImpl\u003cArticleMapper, Article\u003e implements ArticleService { @Autowired ArticleMapper articleMapper; @Override public IPage\u003cArticle\u003e getArticlePageing(IPage\u003cArticle\u003e iPage, LambdaQueryWrapper\u003cArticle\u003e wrapper) { IPage\u003cArticle\u003e articleIPage = articleMapper.selectPage(iPage, wrapper); return articleIPage; } } ","date":"2020-06-18","objectID":"/2020-06-18-forum/:2:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 API","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建 controller 我们需要传递 IPage 对象，QueryWrapper 对象给 service，然后从返回的 IPage 对象中取得查询到的数据。 @RestController @RequestMapping(\"/open\") public class OpenController { @Autowired ArticleService articleService; @ApiOperation(\"分页查询文章，时间排序\") @PostMapping(\"/article/new\") public Object getArticleNew(Integer current, Integer size) { // 分页条件 IPage\u003cArticle\u003e page = new Page\u003c\u003e(current, size); // 查询条件 LambdaQueryWrapper\u003cArticle\u003e wrapper = new LambdaQueryWrapper\u003c\u003e(); // 根据时间顺序查询 wrapper.orderByDesc(Article::getCreateDate); IPage\u003cArticle\u003e articlePageing = articleService.getArticlePageing(page, wrapper); // 当前页数 long atCurrent = articlePageing.getCurrent(); // 当前页的数据 List\u003cArticle\u003e records = articlePageing.getRecords(); for (Article article : records) { article.setContent(\"\"); article.setUser(userService.getById(article.getUId())); article.setBlock(blockService.getById(article.getBId())); } // 组装Dto PageResult pageResult = new PageResult(); pageResult.setCurrent(atCurrent); pageResult.setList(records); return new JsonResult(200, \"查询成功\", pageResult); } } 这样就实现了数据时间排序的分页获取。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:3:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 API","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"JWT 登录认证 添加依赖 \u003cdependency\u003e \u003cgroupId\u003eio.jsonwebtoken\u003c/groupId\u003e \u003cartifactId\u003ejjwt\u003c/artifactId\u003e \u003cversion\u003e0.7.0\u003c/version\u003e \u003c/dependency\u003e 写一个 jwt 工具类 @Component @Data public class JwtConfig { private String secret = \"abcdefg1234567\"; private long expire = 3600 * 60 * 60; private String header = \"token\"; /** * 生成token * * @param subject * @return */ public String createToken(String subject) { Date nowDate = new Date(); Date expireDate = new Date(nowDate.getTime() + expire * 1000);// 过期时间 return Jwts.builder().setHeaderParam(\"typ\", \"JWT\").setSubject(subject).setIssuedAt(nowDate) .setExpiration(expireDate).signWith(SignatureAlgorithm.HS512, secret).compact(); } /** * 获取token中注册信息 * * @param token * @return */ public Claims getTokenClaim(String token) { try { return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody(); } catch (Exception e) { // e.printStackTrace(); return null; } } /** * 验证token是否过期失效 * * @param expirationTime * @return */ public boolean isTokenExpired(Date expirationTime) { return expirationTime.before(new Date()); } } 里面写了 token 的生成和解密的方法。 添加 jwt 拦截器, 除了注册，登录和 get 请求的 uri 地址，都需要验证 token。 @Component public class TokenInterceptor extends HandlerInterceptorAdapter { JwtConfig jwtConfig = new JwtConfig(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (request.getMethod().equals(\"OPTIONS\")) { return true; } /** 地址过滤 */ String uri = request.getRequestURI(); if (uri.contains(\"/api/login\") || uri.contains(\"/api/reg\") || uri.contains(\"/sys/login\") || uri.contains(\"/api/get\")) { return true; } /** Token 验证是否存在 */ String token = request.getHeader(jwtConfig.getHeader()); if (StringUtils.isEmpty(token)) { token = request.getParameter(jwtConfig.getHeader()); } if (StringUtils.isEmpty(token)) { throw new SignatureException(jwtConfig.getHeader() + \"不能为空\"); } Claims claims = null; // 判断是否有效 try { claims = jwtConfig.getTokenClaim(token); if (claims == null || jwtConfig.isTokenExpired(claims.getExpiration())) { throw new SignatureException(jwtConfig.getHeader() + \"失效，请重新登录。\"); } } catch (Exception e) { throw new SignatureException(jwtConfig.getHeader() + \"失效，请重新登录。\"); } /** 设置 identityId 用户身份ID */ request.setAttribute(\"identityId\", claims.getSubject()); return true; } } ","date":"2020-06-18","objectID":"/2020-06-18-forum/:4:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 API","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"点赞关注收藏评论 点赞，关注，收藏，评论功能都可以用单表实现。点赞，收藏，评论功能就是在分别在 likes, collection, comment 表中记录 uid(用户),aid(文章) 实现关联，而关注则是在 follow 表中记录两个 uid 实现关联，下面给出点赞功能的逻辑实现，关注，收藏，评论功能的逻辑同点赞功能。 @PostMapping(\"/add/like\") public Object setLike(Integer aid, HttpServletRequest request) { Claims token = jwtConfig.getTokenClaim(request.getHeader(\"token\")); String subject = token.getSubject(); LambdaQueryWrapper\u003cLikes\u003e queryWrapper = new LambdaQueryWrapper\u003c\u003e(); queryWrapper.eq(Likes::getUid, Integer.valueOf(subject)); queryWrapper.eq(Likes::getAId, aid); Likes one = likeService.getOne(queryWrapper); if (one == null) { boolean save = likeService.save(new Likes().setAId(aid).setUid(Integer.valueOf(subject))); return new JsonResult(200, \"点赞成功!\"); } else { boolean b = likeService.removeById(one.getId()); return new JsonResult(200, \"已取消点赞!\"); } } ","date":"2020-06-18","objectID":"/2020-06-18-forum/:5:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 API","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"搜索和浏览记录 搜索使用 mysql 的模糊查询实现。 @PostMapping(\"/search/article\") public Object searchArticle(String title) { LambdaQueryWrapper\u003cArticle\u003e articleWrapper = new LambdaQueryWrapper\u003c\u003e(); articleWrapper.like(Article::getTitle, title); List\u003cArticle\u003e list = articleService.list(articleWrapper); for (Article article : list) { article.setContent(\"\"); article.setUser(userService.getById(article.getUId())); article.setBlock(blockService.getById(article.getBId())); } return new JsonResult(200, \"\", list); } 浏览记录，进入文章详情页面后，如果用户是登录状态，就加入 History 表。 History 表有三个字段，uid(用户), aid(文章), time(访问时间)。如果已经在 History 表中存在记录，则更新时间。 @GetMapping(\"/article/{id}\") public Object getArticleById(@PathVariable(\"id\") Integer id, HttpServletRequest request) { Claims token = jwtConfig.getTokenClaim(request.getHeader(\"token\")); // 在登陆状态下保存到历史表中 if (token != null) { String subject = token.getSubject(); LambdaQueryWrapper\u003cHistory\u003e queryWrapper = new LambdaQueryWrapper\u003c\u003e(); queryWrapper.eq(History::getAid, id); queryWrapper.eq(History::getUid, Integer.valueOf(subject)); History one = historyService.getOne(queryWrapper); // 如果已存在记录，则更新时间 History history = new History().setAid(id).setTime(new Date()).setUid(Integer.valueOf(subject)); if (one == null) { historyService.save(history); } else { one.setTime(new Date()); historyService.updateById(one); } } Article byId = articleService.getById(id); byId.setUser(userService.getById(byId.getUId())); byId.setBlock(blockService.getById(byId.getBId())); // 每次访问热度加1 articleService.updateById(new Article().setId(id).setScore(byId.getScore() + 1)); return new JsonResult(200, \"查询成功\", byId); } 每次访问文章详情页，文章热度发生变化，首页热度排序的内容将重新排序。 项目启动主类 @SpringBootApplication public class BugeServerApplication { public static void main(String[] args) { SpringApplication.run(BugeServerApplication.class, args); } } spring boot 提供了一个统一的注解@SpringBootApplication。 代表了@Configuration, @EnableAutoConfiguration, @ComponentScan。 @Configuration 和 @Bean。使用这两个注解就可以创建一个简单的 spring 配置类，可以用来替代相应的 xml 配置文件。@Configuration 的注解类标识这个类可以使用 Spring IoC 容器作为 bean 定义的来源。@Bean 注解告诉 Spring，一个带有@Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。 @EnableAutoConfiguration：能够自动配置 spring 的上下文，试图猜测和配置你想要的 bean 类，通常会自动根据你的类路径和你的 bean 定义自动配置。 @ComponentScan：会自动扫描指定包下的全部标有@Component 的类，并注册成 bean，当然包括@Component 下的子注解@Service, @Repository, @Controller。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:6:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 API","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"本文记录 react-beautiful-dnd 这个拖拽库的使用，我们将完成一个类似 trello 的看板应用。最终实现的效果如下：List 是一个可横向拖放的列表，Card 可在不同的 List 列表之间拖放。左上方的搜索框能够搜索筛选卡片，右上方的按钮能够实现撤销重做功能。 可拖拽Trello页面展示可拖拽Trello页面展示 \" 可拖拽Trello页面展示 ","date":"2020-05-18","objectID":"/2020-05-18-trello/:0:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"拖拽库的使用 react-beautiful-dnd 这个库使用 render-props 完成组件逻辑复用。react-beautiful-dnd 有 3 个主要组件：DragDropContext，Droppable 和 Draggable。这三者的关系如下： react-beautiful-dnd库的使用react-beautiful-dnd库的使用 \" react-beautiful-dnd库的使用 DragDropContext 表示一个全局拖拽上下文。Droppable 表示可以被拖入的容器，Draggable 是可被拖放的组件。 DragDropContext 提供了以下三个钩子： onDragStart 拖动开始时执行。 onDragUpdate 拖动过程中的执行。 onDragEnd 拖拽结束时执行，且 onDragEnd 必须设定。 我们需要在 Board 组件内建立可拖动范围，则需要这样写： // components/Board.js const Board = () =\u003e { // onDragEnd 需实现 const onDragEnd = (result) =\u003e {}; return \u003cDragDropContext onDragEnd={onDragEnd}\u003e...\u003c/DragDropContext\u003e; }; Droppable： Droppable 必须设定 droppableId Droppable 使用 render-props 意味着内部须使用一个函数，该函数接收参数 provided 对象, 然后将参数 provided 的属性传递给封装后的可拖放的容器组件 将 Board 组件建立成可拖放的容器组件，像这样写： // components/Board.js // 需嵌套在 DragDropContext 内 // 包裹 List 的容器，List 在 Board 容器内横向拖动 \u003cDroppable droppableId=\"all-lists\" direction=\"horizontal\" type=\"list\"\u003e {(provided) =\u003e ( // 封装后的可拖放的容器组件 \u003cListContainer ref={provided.innerRef} {...provided.droppableProps}\u003e // 遍历所有的列表，将列表数据传递给每个列表 {Object.keys(lists).map((key, index) =\u003e { const list = lists[key]; const listCards = list.cards.length \u003e 0 ? list.cards : []; return ( \u003cList key={list.id} id={list.id} title={list.title} cards={listCards} index={index} /\u003e ); })} {provided.placeholder} \u003c/ListContainer\u003e )} \u003c/Droppable\u003e Draggable： Draggable 必须设定 draggableId，index(由父组件传入) Draggable 与 Droppable 一样是 render-props，接收 provided 对象，返回值是封装后的可拖放组件 将 List 组件建立成可拖放组件，像这样写： // components/List.js // 设置每个 List 都是可拖动的 const List = ({ id, title, cards = [], index }) =\u003e { ... return ( \u003cDraggable draggableId={id} index={index}\u003e { provided =\u003e ( // 封装后的可拖放组件 \u003cListContainer ref={provided.innerRef} {...provided.draggableProps} // dragHandleProps 绑定的组件 ListContainer 可拖动 {...provided.dragHandleProps}\u003e ... \u003c/ListContainer\u003e )} \u003c/Draggable\u003e ); } 同理设置 Card 组件可在 List 组件内部拖动，先要将 List 内部封装成可拖放的容器，像这样写: // components/List.js // 需嵌套在 List 组件返回的 ListContainer 内 // 包裹 Card 的容器，Card 在 List 容器内可拖放 \u003cDroppable droppableId={id} type=\"card\"\u003e {(provided) =\u003e ( \u003cCardContainer ref={provided.innerRef} {...provided.droppableProps}\u003e // 遍历每个 List 中所有的卡片，将卡片数据传给每张卡片 {cards.map((card, index) =\u003e ( \u003cCard key={card.id} id={card.id} text={card.text} listId={id} index={index} /\u003e ))} {provided.placeholder} \u003c/CardContainer\u003e )} \u003c/Droppable\u003e 将 Card 组件封装成可拖放组件，像这样写: // components/Card.js const Card = ({ id, text, index, listId }) =\u003e { ... return ( \u003cDraggable draggableId={id} index={index}\u003e {provided =\u003e ( \u003cCardContainer className='card' ref={provided.innerRef} {...provided.draggableProps} // dragHandleProps 绑定的组件 CardContainer 可拖动 {...provided.dragHandleProps}\u003e \u003c/CardContainer\u003e )} \u003c/Draggable\u003e ); } ","date":"2020-05-18","objectID":"/2020-05-18-trello/:1:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"状态管理 初始化列表数据: // morkData.js import { uuid } from \"uuidv4\"; const getCard = (text) =\u003e ({ id: uuid(), text, }); export const ListState = [ { id: uuid(), title: \"To Do\", cards: [getCard(\"To do task\"), getCard(\"TO FILTER: To do task\")], }, { id: uuid(), title: \"Doing\", cards: [getCard(\"Doing task\"), getCard(\"TO FILTER: Doing task\")], }, { id: uuid(), title: \"Done\", cards: [getCard(\"Done task\"), getCard(\"TO FILTER: Done task\")], }, ]; 记录状态变更用 DragDropContext 上的钩子函数 onDragEnd，onDragEnd 接收一个 result 对象，result 记录了拖拽过程中的状态变化，result 结构如下： const result = { draggableId: 1, // 移动的组件 id type: \"list\", source: { droppableId: 1, // 移动前所在的容器 id index: 2, // 组件在移动前的容器内的位置 }, destination: { droppableId: 3, // 移动后所在的容器 id index: 1, // 组件在移动后的容器内的位置 }, }; 我们需要写拖放组件后的状态变化逻辑，因为我们的列表数据中的 cards 数组发生了变化，但我们还没有把新的状态渲染到 list 组件中，拖放组件后需要重新排序，现在去实现在 Board 组件中定义的 onDragEnd 钩子函数： // components/Board.js const onDragEnd = ({ draggableId, type, source, destination }) =\u003e { if (destination) { dispatch( sort( source.droppableId, destination.droppableId, source.index, destination.index, draggableId, type ) ); } }; action 用 payload 传递接收到的数据： // actions/listActions.js import { CONSTANTS } from '.'; ... export const sort = ( droppableIdStart, droppableIdEnd, droppableIndexStart, droppableIndexEnd, draggableId, type ) =\u003e { return { type: CONSTANTS.DRAGGED, // 动作是拖放，可能是列表，也可能是卡片 payload: { droppableIdStart, //开始时所在的 container id droppableIdEnd, //结束时所在的 container id droppableIndexStart, //开始所在 container 里的索引 droppableIndexEnd, //结束时所在的 container 里的索引 draggableId, // 移动的组件 id type } }; }; reducer 实现状态变化逻辑并返回新状态，始终用新状态替换原来的状态，不要直接在原来的对象上操作，因为我们将会对每个状态做记录，这有利于我们实现撤销重做功能。 // reducers/listReducer.js case CONSTANTS.DRAGGED: { // 当完成拖放动作时 const { droppableIdStart, droppableIdEnd, droppableIndexStart, droppableIndexEnd, type } = action.payload; const newState = [...state]; //深拷贝不改变原列表 if (type === 'list') { const moveList = newState.splice(droppableIndexStart, 1); newState.splice(droppableIndexEnd, 0, ...moveList); console.log('Drag list', newState); return newState; } const sourceListIndex = newState.findIndex(list =\u003e droppableIdStart === list.id); const sourceList = newState[sourceListIndex]; const sourceCards = [...sourceList.cards]; //深拷贝不改变原数组 const moveCard = sourceCards.splice(droppableIndexStart, 1); if (droppableIdStart !== droppableIdEnd) { //不同列之间移动卡片 const destinationListIndex = newState.findIndex(list =\u003e droppableIdEnd === list.id); const destinationList = newState[destinationListIndex]; const destinationCards = [...destinationList.cards]; destinationCards.splice(droppableIndexEnd, 0, ...moveCard); newState[destinationListIndex] = { ...newState[destinationListIndex], cards: destinationCards }; } else { //同列中改变卡片次序 sourceCards.splice(droppableIndexEnd, 0, ...moveCard); } newState[sourceListIndex] = { ...newState[sourceListIndex], cards: sourceCards }; console.log('Drag card', newState); return newState; } 这样就实现了移动列表和移动卡片的状态变化逻辑，剩下的列表和卡片的增删改查的状态变化逻辑的实现就比较容易了。 ","date":"2020-05-18","objectID":"/2020-05-18-trello/:2:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"搜索卡片 在界面上实现卡片的搜索功能，实际上就是实现筛选卡片功能。我们已经在每个 List 组件中遍历其中的 Card，筛选功能就是每个 List 组件根据搜索框的输入内容选择性的遍历 Card，修改 List 组件如下： // components/List.js ... \u003cDroppable droppableId={String(id)} type=\"card\"\u003e {(provided, snapshot) =\u003e ( \u003cCardListContainer ref={provided.innerRef} isDraggingOver={snapshot.isDraggingOver} {...provided.droppableProps}\u003e // 筛选出每个 List 中符合搜索条件的 cards {getFilteredCards(cards, searchText).map((card, index) =\u003e ( \u003cCard key={card.id} id={card.id} text={card.text} listId={id} index={index} /\u003e ))} {provided.placeholder} \u003c/CardListContainer\u003e )} \u003c/Droppable\u003e 实现其中的 getFilteredCards 方法： const getFilteredCards = (cards, searchText) =\u003e { if (searchText) { console.log(searchText); return cards.filter((card) =\u003e card.text.toLowerCase().includes(searchText.toLowerCase()) ); } return cards; }; ","date":"2020-05-18","objectID":"/2020-05-18-trello/:3:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"撤销重做功能 实现撤销重做功能可用 redux-undo 这个库，自己实现也不复杂，下面就自己实现: 实现方法是自定义一个接收 reducer 为参数，返回新 reducer 的函数(reducer enhancer)，监听 listReducer 的变化并做记录。实现思路来自 redux 官方文档 。原本创建 store 时需要导出的 reducer 如下： // reducers/index.js const rootReducer = combineReducers({ lists: listReducer, ... }); export default rootReducer; combineReducers 接收值为 reducer 的函数作为参数，我们只要实现一个返回值为 reducer 的函数(reducer enhancer)就行： const rootReducer = combineReducers({ board: stateEnhancer(listReducer), ... }); export default rootReducer; board 对应的值是将 listReducer 封装后的新 reducer，这样每次调用 listReducer 时也会调用 stateEnhancer，因为函数的参数发生了变化，函数就会重新执行。 // reducers/stateEnhancer.js import { CONSTANTS } from \"../actions\"; const stateEnhancer = (reducer) =\u003e { const initialState = { previousStates: [], currentState: reducer(undefined, {}), // currentState 取 reducer 的返回值 futureStates: [], }; // 调用 reducer 时就会调用 stateEnhancer, 并返回封装后的 reducer return (state = initialState, action) =\u003e { // console.log(state.currentState); const { previousStates, currentState, futureStates } = state; switch (action.type) { case CONSTANTS.UNDO_ACTION: const previous = previousStates[previousStates.length - 1]; const newPreviousStates = previousStates.slice( 0, previousStates.length - 1 ); return { previousStates: newPreviousStates, currentState: previous, futureStates: [currentState, ...futureStates], }; case CONSTANTS.REDO_ACTION: const next = futureStates[0]; const newFutureStates = futureStates.slice(1); return { previousStates: [...previousStates, currentState], currentState: next, futureStates: newFutureStates, }; default: const newCurrentState = reducer(currentState, action); if (currentState === newCurrentState) { //初始化列表 console.log(\"init\"); return state; } console.log(\"list change\"); // 列表变化时 return { previousStates: [...(previousStates || []), currentState], currentState: newCurrentState, futureStates: [], }; } }; }; export default stateEnhancer; 我们用了三个数组记录 listReducer 的变化，按下撤销或者重做功能按钮时，就能在不同的 listReducer 之间切换。并且我们可以根据 previousStates， futureStates 是否为空来判断撤销，重做按钮是否可用： \u003cDoBtn onClick={undo} disabled={previousStates.length === 0} className='btn'\u003e \u003ci className=\"fas fa-undo\"\u003e\u003c/i\u003e \u003c/DoBtn\u003e \u003cDoBtn onClick={redo} disabled={futureStates.length === 0} className='btn' \u003e \u003ci className=\"fas fa-redo\"\u003e\u003c/i\u003e \u003c/DoBtn\u003e 附：源码地址 参阅资料 React Beautiful Dnd 快速使用筆記 redux 文档 - 实现撤销历史 ","date":"2020-05-18","objectID":"/2020-05-18-trello/:4:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"React 组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。 React 组件分为两类，class 组件和函数组件。hooks 的出现让函数组件拥有了状态(state), 因此让自定义 hook 成为了继 render-props 和高阶组件(HOC)之后的第三种状态共享方案。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:0:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"class 组件的状态共享 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:1:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"render-props 具有 render prop 的组件接受一个函数，该函数返回一个 React 元素并调用它(回调函数)而不是实现自己的渲染逻辑。 react 官网示例： class Cat extends React.Component { render() { const mouse = this.props.mouse; return ( \u003cimg src=\"/cat.jpg\" style={{ position: \"absolute\", left: mouse.x, top: mouse.y }} /\u003e ); } } class Mouse extends React.Component { constructor(props) { super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = { x: 0, y: 0 }; } handleMouseMove(event) { this.setState({ x: event.clientX, y: event.clientY, }); } render() { return ( \u003cdiv style={{ height: \"100vh\" }} onMouseMove={this.handleMouseMove}\u003e {/*使用`render`属性来动态确定要渲染的内容。*/} {this.props.render(this.state)} \u003c/div\u003e ); } } class MouseTracker extends React.Component { render() { return ( \u003cdiv\u003e \u003ch1\u003e移动鼠标!\u003c/h1\u003e {/*将 Mouse 组件中的 state 传递给 Cat 组件*/} \u003cMouse render={(mouse) =\u003e \u003cCat mouse={mouse} /\u003e} /\u003e \u003c/div\u003e ); } } 注意 Mouse 组件中的 this.props.render 是绑定在标签模板上的 render(外部传入)。这样就实现了鼠标位置状态的共享, Cat 组件能够根据鼠标位置动态移动 cat 图片。这个示例实现了 react 组件的理想状态：有状态的组件无渲染，有渲染的组件无状态。 因为 Cat 组件只是一个渲染模板，它也可以替换成如下的函数组件: const Cat = (props) =\u003e { const mouse = this.props.mouse; return ( \u003cimg src=\"/cat.jpg\" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /\u003e ); } } UI 与状态分离，便于逻辑的复用。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:1:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"高阶组件(HOC) 高阶组件是参数为组件，返回值为新组件的函数，高阶组件是函数。 const EnhancedComponent = higherOrderComponent(WrappedComponent); 示例： function high(WrappedComponent){ return class extends React.Component{ constructor(){ this.state={ open:false } } componentDidMount(){ console.log('haha') } change=()=\u003e{ this.setState((state)=\u003e{//用到state需要使用回调函数修改state的值 return {open:!state.open} }) } render(){ //使用新数据渲染被包装的组件 return \u003cWrappedComponent open={this.state.open} change={this.change} /\u003e } } } class ToggleButton extends Component{//不带有自身的状态能够实现组件的复用 constructor(props){ super(props) } render(){ let {open,change}=this.props; // 来自 high 的数据 return \u003cFragment\u003e \u003cbutton type=\"primary\" onClick={change}\u003e toggle Modal \u003c/button\u003e \u003cdiv\u003e{open}\u003c/div\u003e //拿到open值 \u003c/Fragment\u003e } } // high 是一个高阶组件，传入组件作为参数，组件就能接收 high 的数据 export default high(ToggleButton)； 每个经过高阶组件处理过的组件都会复用高阶组件里边的所有逻辑，原则上高阶组件是一个纯函数，不会修改传入的组件，只是返回包装好的新组件。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:1:2","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"函数组件的状态共享 Hooks 可以让你在函数组件中使用状态(state)以及其他的 React 特性。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:2:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"自定义 hook Hook 是 React 中的一类特殊的 JavaScript 函数。自定义名为 useFriendStatus 的 hook，它通过调用 useState 和 useEffect 来订阅一个好友的在线状态。 import React, { useState, useEffect } from \"react\"; function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) { setIsOnline(status.isOnline); } useEffect(() =\u003e { ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =\u003e { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; } 自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。 现在我们可以在下面两个组件中使用它： function FriendStatus(props) { const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) { return \"Loading...\"; } return isOnline ? \"Online\" : \"Offline\"; } function FriendListItem(props) { const isOnline = useFriendStatus(props.friend.id); return ( \u003cli style={{ color: isOnline ? \"green\" : \"black\" }}\u003e{props.friend.name}\u003c/li\u003e ); } 这两个组件的 state 是完全独立的，Hook 是一种复用状态逻辑的方式，它不复用 state 本身。传入不同的 props，得到的 state 也不同。同样是实现了 UI 与状态分离，便于逻辑的复用。 但是使用 Hook 会有几个额外的规则： 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用 不要在普通 Javascript 函数中调用 在 React 的函数组件调用 Hook 在自定义的 Hook 中调用 Hook 自定义的 hook 必须以 “use” 开头 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:2:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"状态管理 实现状态管理的前提是能够状态共享，这就是为什么前面会先说状态共享。不同类型的组件实现状态共享的方法不同，状态管理的方案也不同。下面是一个计数器的状态管理的不同实现方案。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:3:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"class 组件的状态管理 class 组件的状态管理，通常方案是使用第三方库 Redux，结合 React-Redux 使用： $ npm i redux react-redux -S Redux 流程图 Redux流程图Redux流程图 \" Redux流程图 当 UI 的 state 变化时，组件 dispatch 发送 action 信号, reducer 接收来自 action 的信号更新 state, 然后 store 将新的 state 传递给组件，重新渲染 UI。 先创建 store，接收 reducer 为参数: import { createStore } from \"redux\"; import reducer from \"./reducer\"; //创建store const store = createStore(reducer); export default store; 再写 action，写 action 之前先了解一下 connect 函数 // React Redux 的 `connect` 函数 const connect(mapStateToProps, mapDispatchToProps)(Component); 可能看起来有些怪, 这样写你就明白了： //先传递两个参数将 connect 封装成高阶函数 const higherOrderComponent = connect(mapStateToProps, mapDispatchToProps); //再得到新包装的组件 EnhancedComponent const EnhancedComponent = higherOrderComponent(Component); action 就是 dispatch 中的参数。 // connect.js import { connect } from \"react-redux\"; const mapStateToProps = (state) =\u003e { return { count: state.count, message: state.message }; }; const mapDispatchToProps = (dispatch) =\u003e { return { increment: (data) =\u003e { dispatch({ type: \"INCREMENT\", num: data, message: \"Incremented\" }); }, decrement: (data) =\u003e { dispatch({ type: \"DECREMENT\", num: data, message: \"Decremented\" }); }, reset: () =\u003e { dispatch({ type: \"RESET\", message: \"Reset\" }); }, }; }; //封装了一个高阶组件，注意高阶组件是函数 export default connect(mapStateToProps, mapDispatchToProps); 最后写 reducer，接收 action 更新 state: const initialState = { count: 0, message: \"\" }; const reducer = (state = initialState, action) =\u003e { switch (action.type) { case \"INCREMENT\": return { count: state.count + action.num, message: action.message, }; case \"DECREMENT\": return { count: state.count - action.num, message: action.message, }; case \"RESET\": return { count: 0, message: action.message, }; default: return state; } }; export default reducer; 创建一个组件测试计数器: import React, { Component } from \"react\"; import connect from \"./connect\"; class Count extends Component { render() { let { count, message, increment, decrement, reset } = this.props; //来自 connect return ( \u003cdiv\u003e {count} \u003cbutton onClick={() =\u003e increment(1)}\u003e+1\u003c/button\u003e \u003cbutton onClick={() =\u003e decrement(3)}\u003e-3\u003c/button\u003e \u003cbutton onClick={() =\u003e reset()}\u003ereset\u003c/button\u003e {message} \u003c/div\u003e ); } } // 导入的 './connect' 是高阶组件，传入 Count 组件, Count就能接收 store 中的数据 export default connect(Count); 根组件注册 store，并导入 count 组件： import React from \"react\"; import ReactDOM from \"react-dom\"; import { Provider } from \"react-redux\"; import store from \"./store\"; import Count from \"./count\"; function App() { return ( \u003cProvider store={store}\u003e \u003cCount /\u003e \u003c/Provider\u003e ); } const rootElement = document.getElementById(\"root\"); ReactDOM.render(\u003cApp /\u003e, rootElement); 此时启动项目你发现已经能够计数了，但是我们并没有直接操作 store 啊，其实是 connect 帮我们做了这件事，可以看一下精简版的 connect 源码： import React, { Component } from \"react\"; import PropTypes from \"prop-types\"; const connect = (mapStateToProps, mapDispatchToProps) =\u003e (WrappedComponent) =\u003e { class Connect extends Component { static contextTypes = { store: PropTypes.object, }; constructor() { super(); this.state = { allProps: {} }; } componentWillMount() { const { store } = this.context; this._updateProps(); store.subscribe(this._updateProps); } _updateProps = () =\u003e { const { store } = this.context; let stateProps = mapStateToProps(store.getState()); let dispatchProps = mapDispatchToProps(store.dispatch); this.setState({ allProps: { ...stateProps, ...dispatchProps, ...this.props, }, }); }; render() { return \u003cWrappedComponent {...this.state.allProps} /\u003e; } } return Connect; }; export default connect; 你会发现 store 实际上是通过 Context 创建的，Context 是 React 中的 API 方法: Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。 有了状态共享方法(高阶组件)和数据传递的方法(Context), 就能让在整个组件树中的各个组件都很方便的读取状态修改状态, 就实现了 React-Redux，下面我会用 hooks 实现类似的全局状态管理。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:3:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"函数组件的状态管理 实际上 React 已经为我们实现了相应的 hooks, 我们需要做的只是将这些 hooks 灵活的组合在一起。就能够实现状态管理了，还是以实现计数器的为例。 实现一个 React-redux 中的 store 只需以下代码： //store.js import React, { createContext, useContext, useReducer } from \"react\"; import reducer from \"./reducer\"; const StoreContext = createContext(); const initialState = { count: 0, message: \"\" }; export const StoreProvider = ({ children }) =\u003e { const [state, dispatch] = useReducer(reducer, initialState); return ( \u003cStoreContext.Provider value={{ state, dispatch }}\u003e {children} \u003c/StoreContext.Provider\u003e ); }; export const useStore = () =\u003e useContext(StoreContext); useReducer 是 useState 的替代方案。它接收一个形如 (state, action) =\u003e newState 的 reducer，以及初始状态 initialState，返回值是当前的 state 以及与其配套的 dispatch 方法。 useContext 的参数必须是 context 对象，让你能够读取 context 的值以及订阅 context 的变化。调用了 useContext 的组件会在 context 值变化时重新渲染。你仍然需要在上层组件树中使用 \u003cMyContext.Provider\u003e 来为下层组件提供 context。 OK, 我们的简版 React-redux 就做好了。 写 action, 我们的状态数据从 useCounter 里获取: //storeApi.js import { useStore } from \"./store\"; export const useCounter = () =\u003e { const { state, dispatch } = useStore(); return { count: state.count, message: state.message, increment: (data) =\u003e dispatch({ type: \"INCREMENT\", num: data, message: \"Incremented\" }), decrement: (data) =\u003e dispatch({ type: \"DECREMENT\", num: data, message: \"Decremented\" }), reset: () =\u003e dispatch({ type: \"RESET\", message: \"Reset\" }), }; }; 写 reducer, 去掉 initialState, 我们已经写在了 useReducer 里, 原因是： 注意 React 不使用 state = initialState 这一由 Redux 推广开来的参数约定。有时候初始值依赖于 props，因此需要在调用 Hook 时指定。 // reducer.js const reducer = (state, action) =\u003e { switch (action.type) { case \"INCREMENT\": return { count: state.count + action.num, message: action.message, }; case \"DECREMENT\": return { count: state.count - action.num, message: action.message, }; case \"RESET\": return { count: 0, message: action.message, }; default: return state; } }; export default reducer; 写个组件，测试一下: //Count.js import React from \"react\"; import { useCounter } from \"./storeApi\"; export const Count = () =\u003e { const { count, message, increment, decrement, reset } = useCounter(); return ( \u003cdiv\u003e {count} \u003cbutton onClick={() =\u003e increment(1)}\u003e+1\u003c/button\u003e \u003cbutton onClick={() =\u003e decrement(3)}\u003e-3\u003c/button\u003e \u003cbutton onClick={() =\u003e reset()}\u003e Reset\u003c/button\u003e {message} \u003c/div\u003e ); }; 修改根组件如下： import React from \"react\"; import ReactDOM from \"react-dom\"; import { StoreProvider } from \"./store\"; import { Count } from \"./Count\"; function App() { return ( \u003cStoreProvider\u003e \u003cCount /\u003e \u003c/StoreProvider\u003e ); } const rootElement = document.getElementById(\"root\"); ReactDOM.render(\u003cApp /\u003e, rootElement); 启动服务，发现能够计数成功，我们的状态管理方案成功了。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:3:2","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"本次实践我将使用 Angular 和 Nest.js 写一个带有状态管理，登录验证的全栈 todolist 应用。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:0:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"后端开发 后端开发使用 Nest.js 框架，本次实践是重前端的，因此后端会做得简单一些。后端是在上一次鉴权认证的代码做部分修改。如果有不懂的代码，可以参考之前的文章 。此部分的讲解略过。这是后端部分生成的 swagger 接口文档: swagger接口文档swagger接口文档 \" swagger接口文档 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:1:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"前端开发 前端使用 Angular 框架。为什么使用 Angular? 以下几点是我选择它的原因： 1.它是前端真正意义上的框架。 2.它的一些理念是相当超前。 3.Nest.js 和 Angular 非常像。 4.前后端开发同构语言。 不过它的缺点也很显著，或者说是我的缺点： 1.学习到会用有较长的时间周期。 2.HMR(hot module replacement) 体验太差。 3.报错信息简直了。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"组件开发 导入 UI 组件库 在样式开发方面，我们使用 angular 官方提供的 Material UI。用一个 MaterialModule，导出我们需要用到的所有样式组件。 @NgModule({ exports: [ MatButtonModule, MatCardModule, MatDialogModule, MatIconModule, MatInputModule, MatListModule, MatToolbarModule, MatMenuModule, ], }) export class MaterialModule {} 这样在我们需要用到样式组件时，直接导入 MaterialModule 就好。 顶部导航 在 AppModule 中导入 MaterialModule， 然后在 app.component.html 中写入顶部 header 导航组件。 \u003cheader\u003e \u003cmat-toolbar color=\"primary\" class=\"expanded-toolbar\"\u003e \u003cdiv\u003e \u003cspan\u003e{{title}}\u003c/span\u003e \u003cbutton mat-button routerLink=\"/todos\"\u003e \u003cmat-icon\u003eview_lists\u003c/mat-icon\u003e Todo \u003c/button\u003e \u003c/div\u003e \u003cdiv\u003e \u003cbutton mat-button routerLink=\"/login\" *ngIf=\"authService.token.length == 0\" \u003e \u003cmat-icon\u003eaccount_box\u003c/mat-icon\u003e Login \u003c/button\u003e \u003cbutton mat-button routerLink=\"/login\" *ngIf=\"authService.token.length \u003e 0\" (click)=\"logout()\" \u003e \u003cmat-icon\u003eexit_to_app\u003c/mat-icon\u003e Logout \u003c/button\u003e \u003c/div\u003e \u003c/mat-toolbar\u003e \u003c/header\u003e \u003cmain\u003e \u003crouter-outlet\u003e\u003c/router-outlet\u003e \u003c/main\u003e \u003c!-- \u003cfooter\u003e\u003c/footer\u003e --\u003e 顶部导航写在 header 标签中，router-outlet 是路由插座，当路由跳转时，我们导入的组件会替换掉 router-outlet 标签。登录成功后显示 Logout button，未登录或登出用户后显示 Login button。在 css 中做些样式调整，接下来是路由注册模块。新建一个 app-routing.module.ts 组件： import { NgModule } from \"@angular/core\"; import { Routes, RouterModule } from \"@angular/router\"; const routes: Routes = [ { path: \"login\", loadChildren: () =\u003e import(\"./features/auth/auth.module\").then((m) =\u003e m.AuthModule), }, { path: \"todos\", loadChildren: () =\u003e import(\"./features/todo/todo.module\").then((m) =\u003e m.TodoModule), }, ]; @NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule], }) export class AppRoutingModule {} 我们注册了路由，因为我们会在导入的模块中进行状态管理，因此这里会用 Angular 中的 Lazy-loading 方式导入模块。这样，当路由匹配 login 时 auth.module.ts 中的 component 成为 main，当路由匹配 todos 时 todo.module.ts 中的 component 成为 main。 登录表单 在 auth.module.ts 只用一个登录组件，导入一些我们需要用到的表单模块。 @NgModule({ imports: [ CommonModule, FormsModule, ReactiveFormsModule, MaterialModule, AuthRoutingModule, ], declarations: [LoginComponent], }) export class AuthModule {} 先创建出 login 组件，可以用 cli 的方式生成：$ nest g component login，也可以手动新建文件：login.component.html，“error$ | async” 是因为我们传递的是 obeservable 对象，我们先不说 login.component.ts, 这一部分在后面的状态管理中再说。 \u003cmat-card\u003e \u003cmat-card-content\u003e \u003cform [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\"\u003e \u003ch2\u003eLogin\u003c/h2\u003e \u003cmat-error *ngIf=\"error$ | async\"\u003e The username and password were not recognised \u003c/mat-error\u003e \u003cmat-form-field class=\"full-width-input\"\u003e \u003cinput matInput placeholder=\"Username\" formControlName=\"username\" required /\u003e \u003cmat-error\u003e Please provide a valid email address \u003c/mat-error\u003e \u003c/mat-form-field\u003e \u003cmat-form-field class=\"full-width-input\"\u003e \u003cinput matInput type=\"password\" placeholder=\"Password\" formControlName=\"password\" required /\u003e \u003cmat-error\u003e Please provide a valid password \u003c/mat-error\u003e \u003c/mat-form-field\u003e \u003cbutton mat-raised-button color=\"primary\"\u003eLogin\u003c/button\u003e \u003c/form\u003e \u003c/mat-card-content\u003e \u003c/mat-card\u003e 然后注册路由 auth-routing.module.ts： import { NgModule } from \"@angular/core\"; import { Routes, RouterModule } from \"@angular/router\"; import { LoginComponent } from \"./login/login.component\"; const routes: Routes = [ { path: \"\", component: LoginComponent, }, ]; @NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule], }) export class AuthRoutingModule {} todolist 列表 创建 todo.component.html, 捕获 todolist 对应的增删改查事件： \u003cmat-card\u003e \u003cng-container *ngIf=\"vm$ | async as vm\"\u003e \u003ch2\u003eTodo Lists\u003c/h2\u003e \u003cmat-action-list role=\"list\"\u003e \u003capp-todo-list-item *ngFor=\"let todo of vm.todos\" [todo]=\"todo\" [loading]=\"vm.loading\" (update)=\"showEditDialog($event)\" (remove)=\"showRemoveDialog($event)\" \u003e\u003c/app-todo-list-item\u003e \u003c/mat-action-list\u003e \u003c/ng-container\u003e \u003c/mat-card\u003e \u003cdiv class=\"fab-bottom-right\"\u003e \u003cbutton mat-fab color=\"accent\" aria-label=\"Add\" (click)=\"showCreateDialog()\"\u003e \u003cmat-icon\u003eadd\u003c/mat-icon\u003e \u003c/button\u003e \u003c/div\u003e todo 单项 todolist 模板中的 remove, update 不是 js 原生事件, 我们需要注册对应的 EventEmitter，它是自定义事件触发与事件监听器功能的封装。todolist 列表是父组件，todo 单项是子组件。父子组件通讯需要用到 @Input() 和 @Output() 装饰器， @Input() 是父传子，@Output() 是子传父。todo-list-item.ts: @Component({ selector: \"app-tod","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:1","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"登录验证 新建一个 services 文件夹，在其中新建 auth.service.ts 文件： @Injectable({ providedIn: \"root\", }) export class AuthService { private api: string = environment.apiUrl + \"/auth\"; constructor( private http: HttpClient, private router: Router, private store: Store ) {} login(user: Partial\u003cUser\u003e) { return this.http.post\u003cUser\u003e(`${this.api}/signIn`, user).pipe( mergeMap((user: User) =\u003e { this.token = user.access_token || \"\"; this.router.navigate([\"todos\"]); return of(user); }) ); } get token() { return localStorage.getItem(\"access_token\") || \"\"; } set token(val: string) { if (val.length \u003e 0) { localStorage.setItem(\"access_token\", val); } } logout() { this.store.dispatch(UserActions.logout()); localStorage.clear(); } } 为 token 创建一个 setter, getter 方法，登录成功后，为 token 赋值，登出后，将 token 置空。providedIn: ‘root’ 表示我们的 service 是根级作用域。客服端判断用户是否登录成功的方法就是判断我们的 token 是否为空。而服务端将 token 作为验证用户的凭据。用户登录成功后，每次需要用户验证的请求都要求验证 token。我们可以使用拦截器(Interceptor) 对网络请求重新封装。 @Injectable() export class AuthInterceptor implements HttpInterceptor { constructor(public authService: AuthService) {} intercept( req: HttpRequest\u003cany\u003e, next: HttpHandler ): Observable\u003cHttpEvent\u003cany\u003e\u003e { const authToken = this.authService.token; const authReq = req.clone({ headers: req.headers.set(\"Authorization\", \"Bearer \" + authToken), }); return next.handle(authReq); } } 当我们设置拦截器后，我们需要注册在根模块 app.module.ts 中。 providers: [ { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true } ], 添加了全局拦截器后我们就不必在每个请求接口都手动添加 header 的 bear 参数了。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:2","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"状态管理 状态管理是为了组件之间的数据共享。组件数据发生变化后，不通过不同组件传值这样的方式，而通过一个叫 store 的东西统一管理状态数据，监听状态数据变化。 打印日志 新建一个 store 文件夹，里面新建 app.state.ts 文件，将路由变化 router 加入到 AppState 中。 import { RouterReducerState } from \"@ngrx/router-store\"; export interface AppState { router: RouterReducerState; } 创建一个 reducers 文件夹, 里面新建 logger.reducer.ts: import { ActionReducer } from \"@ngrx/store\"; import { AppState } from \"../app.state\"; export function logger( reducer: ActionReducer\u003cAppState\u003e ): ActionReducer\u003cAppState\u003e { return (state, action) =\u003e { const result = reducer(state, action); console.groupCollapsed(action.type); console.log(\"prev state\", state); console.log(\"action\", action); console.log(\"next state\", result); console.groupEnd(); return result; }; } 这是参考了 NgRx 在 github 上的官方示例 的做法，实现一个控制台的日志打印，当然我们也可以在浏览器安装 redux 扩展程序。新建 index.ts，开发环境下就有日志打印: import { ActionReducerMap, MetaReducer } from \"@ngrx/store\"; import * as fromRouter from \"@ngrx/router-store\"; import { environment } from \"../../../environments/environment\"; import { logger } from \"./logger.reducer\"; import { AppState } from \"../app.state\"; export const reducers: ActionReducerMap\u003cAppState\u003e = { router: fromRouter.routerReducer, }; export const metaReducers: MetaReducer\u003cAppState\u003e[] = !environment.production ? [logger] : []; 理解状态管理 写本篇文章的目的之一是将状态管理实践验证。之前我有说前端的状态管理相当于后端的数据库。接下来我将一步一步的验证这个说法。下面以用户状态来讲解。 定义初始状态类似于数据库的创建，action 是 store 数据的来源入口，从 NgRx 官网示意图中我们可以看到它可以来自用户操作(component)，也可以来自网络请求(effects)，reducer 类似于数据表，那 adapter, selector, effects 又分别是什么呢？ ngrx状态管理ngrx状态管理 \" ngrx状态管理 按照 Redux 的约定，reducer 必须是纯函数，接收旧状态，返回新状态。adapter 是 reducer 数据表的一行(记录)，selector 类似于 sql 中的 select 语句。而 effects 负责传递数据，和一些 DOM 操作，使用 NgRx 这套流程时，component 唯一能做的是 dispatch action, 额外的事情(副作用)就交给 effects 来做。 下面给出代码实例，可以结合代码来理解这段话。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:3","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"代码实例 初始化 reducer 表 初始状态(initialState)是定义在 reducer 中的，user.state.ts: import { EntityState, createEntityAdapter } from \"@ngrx/entity\"; import { User } from \"src/app/models/user.model\"; export const featureName = \"user\"; export interface State extends EntityState\u003cUser\u003e { needAuth: boolean; selectedId?: string; error?: any; } export const adapter = createEntityAdapter\u003cUser\u003e(); export const initialState: State = adapter.getInitialState({ needAuth: false, }); 注册 reducer 表 featureName 是我们的 reducer 表名，根模块注册时，StoreModule.forRoot(featureName, reducer)。 其他模块注册时，StoreModule.forFeature(featureName, reducer), 当在其他模块注册时，仍然需要在根模块配置 StoreModule.forRoot({})。 action 数据源 定义 Action 作为 store 数据来源，props 接收数据参数。 import { createAction, props } from \"@ngrx/store\"; import { User } from \"src/app/models/user.model\"; export const login = createAction( \"[Auth Page] User Login\", props\u003c{ user: Partial\u003cUser\u003e }\u003e() ); export const loginSuccess = createAction( \"[Auth Page] Login Success\", props\u003c{ user: User }\u003e() ); export const loginFailure = createAction( \"[Auth Page] Login Failure\", props\u003c{ error: any }\u003e() ); export const logout = createAction(\"[Auth Page] User Logut\"); effects 钩子 effects 钩取相应 action(login) 后，发送网络请求，并触发新的 action(loginSuccess 或者 loginFailure)。effects 与 action 数据交互是双向的。 @Injectable() export class UserEffects { constructor(private actions$: Actions, private authService: AuthService) {} login$ = createEffect(() =\u003e this.actions$.pipe( ofType(UserActions.login), concatMap(({ user }) =\u003e this.authService.login(user).pipe( map((result) =\u003e UserActions.loginSuccess({ user: result })), catchError((error) =\u003e of(UserActions.loginFailure({ error }))) ) ) ) ); } adapter 记录 action 传递数据给 reducer 表, reducer 表在 loginSuccess 时就增加一行记录。 export const reducer = createReducer( initialState, on(UserActions.login, (state) =\u003e { return { ...state, needAuth: true }; }), on(UserActions.loginSuccess, (state, { user }) =\u003e { return adapter.addOne(user, { ...state, needAuth: false }); }), on(UserActions.loginFailure, (state, { error }) =\u003e { return { ...state, needAuth: true, error }; }), on(UserActions.logout, (state) =\u003e { return { ...state, needAuth: true }; }) ); selector 状态切片 我们要将新的状态作用到 component 上，这个时候就需要 selector 在 reducer 中查询，创建 user.selector.ts: const getUserState = createFeatureSelector\u003cState\u003e(featureName); const { selectEntities } = adapter.getSelectors(); export const getLogin = createSelector(getUserState, (state) =\u003e state.needAuth); export const getError = createSelector(getUserState, (state) =\u003e state.error); export const getSelectedId = createSelector( getUserState, (state) =\u003e state.selectedId ); export const getUserEntities = createSelector(getUserState, selectEntities); export const getUser = createSelector( getSelectedId, getUserEntities, (id, entities) =\u003e (id ? entities[id] : undefined) ); 在 login.component.ts 中得到新的状态： error$ = this.store.pipe(select(UserSelectors.getError)); needAuth$ = this.store.pipe(select(UserSelectors.getLogin)); 变量中的 $ 表示得到的数据是 Observable 对象。我们可以直接将 Observable 渲染在 html 中： \u003cmat-error *ngIf=\"error$ | async\"\u003e The username and password were not recognised \u003c/mat-error\u003e 也可以取订阅后的布尔值 error$.subscribe(data =\u003e data)。 在 component 中填写完登录表单后, 只需 dispatch action: this.store.dispatch(UserActions.login({ user })); 状态数据就在 component, store 之间来回传递。最后的程序如图： 监听页面状态变化监听页面状态变化 \" 监听页面状态变化 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:4","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"思考 看到这里，你会发现，我们绕了一圈做了一件简单的事。但你可以想象，前端框架的组件化开发方式，组件之间的通信基本都是单向数据流，要是没有状态管理，父子组件还好，相隔很远的组件，只能通过一级一级向上传，再一级一级向下传，会更加麻烦。 如果需要共享的状态较少，可以直接定义在 service 中，通过 DI(依赖注入) 的方式能够很方便地传递到不同的 component 中，并不需要状态管理。 附：源码地址 参阅资料 NgRx 官方文档 Angular 真的需要状态管理么？ ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:5","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"本文主要讲述如何用 typeorm 建表，建立一对一，一对多，多对多的关系，建立表的外连接。 以及在 typeorm 做查询操作的两种常用方式：Find 选项 和 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:0:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"建表 typeorm 建表时，将 @Entity() 装饰的 class 映射为数据表，entity 中 @PrimaryColumn() 装饰的属性作为表的主键, @PrimaryGeneratedColumn() 表示自动生成主键, @Column() 装饰属性作为表的属性。 @Entity() export class Photo { @PrimaryGeneratedColumn() id: number; @Column({ length: 100 }) name: string; @Column(\"text\") description: string; @Column() views: number; @Column() isPublished: boolean; } 数据库中的列类型是根据你使用的属性类型推断的，例如: number 将被转换为 integer，string 将转换为 varchar，boolean 转换为 bool 等。下面我们从实际的例子出发探索如何用 typeorm 建一对一、一对多、多对多的关系。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:1:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"一对一 用户 user 和用户档案 profile 是一对一关系，一个用户只有一份档案。 @Entity(\"users\") export class UserEntity { @PrimaryGeneratedColumn() id: number; @Column() username: string; @OneToOne((type) =\u003e ProfileEntity, (profile) =\u003e profile.user) @JoinColumn() profile: ProfileEntity; } 注意 profile 是 ProfileEntity 类型的，在数据库中存储的类型却是 profile.id 的类型。 @OneToOne 中需要指明对方 entity 的类型，指明对方 entity 的外键。@JoinColumn 必须在且只在关系的一侧的外键上。 @Entity(\"profiles\") export class ProfileEntity { @PrimaryGeneratedColumn() id: number; @Column() gender: string; @Column() photo: string; @OneToOne((type) =\u003e UserEntity, (user) =\u003e user.profile) user: UserEntity; } 这将生成以下数据表： +-------------+--------------+----------------------------+ | users | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | username | varchar(255) | | | profileId | int(11) | FOREIGN KEY | +-------------+--------------+----------------------------+ +-------------+--------------+----------------------------+ | profiles | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | gender | varchar(255) | | | photo | varchar(255) | | +-------------+--------------+----------------------------+ ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:2:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"一对多 用户 user 与用户发布的文章 article 是一对多关系，一个用户可发布多篇文章。 @Entity(\"users\") export class UserEntity { @PrimaryGeneratedColumn() id: number; @Column() username: string; @OneToMany((type) =\u003e ArticleEntity, (article) =\u003e article.author) articles: ArticleEntity[]; } @OneToMany，@ManyToOne 中需要指明对方的 entity 类型，指明对方 entity 的外键。 @Entity(\"articles\") export class ArticleEntity { @PrimaryGeneratedColumn() id: number; @Column() title: string; @ManyToOne((type) =\u003e UserEntity, (user) =\u003e user.articles) author: UserEntity; } typeorm 在处理 “一对多”关系时将“一”的主键作为“多”的外键 (即 @ManyToOne 装饰的属性)，建表时有最少的数据表操作代价，避免数据冗余，提高效率。这会生成以下表： +-------------+--------------+----------------------------+ | articles | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | title | varchar(255) | | | authorId | int(11) | | +-------------+--------------+----------------------------+ +-------------+--------------+----------------------------+ | users | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | username | varchar(255) | | +-------------+--------------+----------------------------+ ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:3:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"多对多 用户 user 对文章 article 的喜欢 favorite 是多对多关系。一个用户可对多篇文章标记喜欢，一篇文章可被多个用户标记喜欢。 @Entity(\"users\") export class UserEntity { @PrimaryGeneratedColumn() id: number; @Column() username: string; @ManyToMany((type) =\u003e ArticleEntity, (article) =\u003e article.favoritedBy) favorites: ArticleEntity[]; } @OneToMany 中需要指明对方的 entity 类型，指明对方 entity 的外键。@JoinTable 必须在且只在关系的一侧的外键上。 @Entity(\"articles\") export class ArticleEntity { @PrimaryGeneratedColumn() id: number; @Column() title: string; @ManyToMany((type) =\u003e UserEntity, (user) =\u003e user.favorites) @JoinTable() favoritedBy: UserEntity[]; } typeorm 的处理方式是将多对多关系转化为两个一对多关系: 用户 user 与 喜欢 favorites 一对多。 文章 article 与被喜欢 favoritedBy 一对多。 多对多关系需要采用中间表的方式处理，这是为了避免笛卡尔积的出现。这会生成以下表： +-------------+--------------+----------------------------+ | users | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | username | varchar(255) | | +-------------+--------------+----------------------------+ +-------------+--------------+----------------------------+ | articles | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | title | varchar(255) | | +-------------+--------------+----------------------------+ +-------------+--------------+----------------------------+ | articles_favorited_by_users | +-------------+--------------+----------------------------+ | articlesId | int(11) | PRIMARY KEY FOREIGN KEY | | usersId | int(11) | PRIMARY KEY FOREIGN KEY | +-------------+--------------+----------------------------+ ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:4:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"增删改查 创建好一对一，一对多，多对多的实体 entity 后，我们如何做增删改查呢？单个实体的 crud 可参考我的这一篇文章 。而关联后的实体对象会作为该实体对象的一个属性, 直接对属性进行操作即可。如下是文章被用户喜欢的实现: async favoriteArticle(slug: string, user: UserEntity) { const article = await this.articleRepo.findOne({ where: { slug }}); article.favoritedBy.push(user); await article.save(); return article; } crud 操作中查询操作是我们最常遇到的，下面讲如何查询，typeorm 支持两种查询方式：Find 选项 和 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"Find 选项 在 Nest.JS 中，对具体实体的管理（insert, update, delete, load 等)我们使用的是 Repository。对应的查找方法是：Repository.find(FindOptions)。 使用 find 查询只能获得一种类型的结果：entities。 find 选项的完整例子如下： userRepository.find({ select: [\"username\"], relations: [\"profile\", \"article\"，\"article.favoritedBy\"], where: { username: \"Timber\", }, order: { id: \"DESC\" }, skip: 5, take: 10, cache: true }); 直接使用 find 是不会查出关联的对象的，要查询的关联对象需要添加到 relations 数组中。 除了 relations 以外，其他选项等同于原生 sql 操作, order 等同于 order by, skip 等同于 offset, take 等同于 limit, cache 是查询缓存。细节请参考 Find 选项 。 这种查询有个局限就是只能查询到关联对象的整个实体或主键。而不能 select 关联实体的其他属性。因此更复杂的查询我们需要使用 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:1","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"QueryBuilder 使用 QueryBuilder 查询可以获得两种类型的结果：entities 或原始数据。 要获取 entities，请使用 getOne 和 getMany。 要获取原始数据，请使用 getRawOne 和 getRawMany。 它能够很方便的帮我们构造出 sql 语句，addSelect() 可以获取关联对象上的其他属性。 if (query.author) { const article = await getRepository(ArticleEntity) .createQueryBuilder(\"article\") .select(\"article.id\", \"id\") .addSelect(\"favoritedBy.username\", \"name\") .leftJoin(\"article.favoritedBy\", \"favoritedBy\") .where(\"favoritedBy.username = :name\", { name: query.author }) .getRawMany(); } 获取生成的 sql 语句可以在 getRawMany() 前获取 getSql() 或打印 printSql() 生成的 sql 语句。细节请参考 Query Builder 。 参阅资料 Typeorm 官方文档 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:2","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"鉴权(authentication)是指验证用户是否拥有访问系统的权利。传统的鉴权是通过密码来验证的。这种方式的前提是，每个获得密码的用户都已经被授权。 ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:0:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"建立用户表，密码散列 要实现鉴权认证，首先需要一张 user 表。上一次我们用 NestJS 和 Typeorm 做了最基本的 crud 操作, 这次我们用 NestJS 和 node 中最流行的身份验证库 Passport 来完成鉴权认证。为了方便，我们直接沿用上次的代码库 。 创建 user module: $ nest g mo user 然后在 user 文件夹新建 user.entity.ts, 其中我们做了密码散列: import { BeforeInsert, Column, Entity, PrimaryGeneratedColumn } from \"typeorm\"; import * as bcrypt from \"bcryptjs\"; @Entity(\"user\") export class UserEntity { @PrimaryGeneratedColumn() id: number; @Column({ length: 20 }) username: string; @Column({ length: 255 }) password: string; @BeforeInsert() async hashPassword() { this.password = await bcrypt.hash(this.password, 10); } } 在 user.module.ts 中注册 user 表：TypeOrmModule.forFeature([UserEntity]) 上一次我们直接在 module 中写了数据库连接配置，其实更常见的做法是写一个数据库配置文件。可以用环境变量设置数据库连接，这是 typeorm 数据库连接配置的参考地址 。在文件夹建立一个 .env 文件： # App JWT_SECRET = 'ThisIsASecretKey' # Database TYPEORM_CONNECTION = mysql TYPEORM_HOST = localhost TYPEORM_USERNAME = root TYPEORM_PASSWORD = 123456 TYPEORM_DATABASE = test TYPEORM_PORT = 3306 TYPEORM_SYNCHRONIZE = true TYPEORM_LOGGING = true TYPEORM_ENTITIES = dist/**/*.entity.js 其中写了数据库配置和自定义的 jwt 密匙，关于如何生成 jwt 格式的字符串, 可以看这篇文章 , 本文只讲如何使用它来做用户登录验证。 在 app.module.ts 的 imports 数组中修改数据库为注册：TypeOrmModule.forRoot()，然后写入 UserModule。测试一下我们的数据库连接情况：$ npm run start, 控制台打印了 sql 语句，说明我们的连接配置是对的。查看数据库会发现新增加了 user 表。 在 user 文件夹新建 user.dto.ts： import { IsString } from \"class-validator\"; import { ApiProperty } from \"@nestjs/swagger\"; export class UserDto { @ApiProperty() @IsString() readonly username: string; @ApiProperty() @IsString() readonly password: string; } 然后创建 user service：$ nest g s user，注意在 createUser 方法中一定要先 实例化 user, 再返回创建的对象。否则 user.entity.ts 中的 @BeforeInsert() 装饰的方法不会执行，密码就不会取散列后的值。 import { Injectable } from \"@nestjs/common\"; import { InjectRepository } from \"@nestjs/typeorm\"; import { UserEntity } from \"./user.entity\"; import { Repository } from \"typeorm\"; import { UserDto } from \"./user.dto\"; @Injectable() export class UserService { constructor( @InjectRepository(UserEntity) private readonly userRepository: Repository\u003cUserEntity\u003e ) {} async createUser(userDto: UserDto) { // const user = Object.assign(new UserEntity(), userDto) const user = this.userRepository.create(userDto); return await this.userRepository.save(user); } async findUsername(username: string) { return this.userRepository.findOne({ where: { username } }); } async findAll(): Promise\u003cUserEntity[]\u003e { return await this.userRepository.find(); } } ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:1:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"实现本地认证策略 实现本地认证策略需要先安装以下依赖： yarn add @nestjs/passport passport passport-local yarn add -D @types/passport-local 说明一下，这一步不是必须的。其实本地认证就是做用户名和密码的核对，我们自己去实现也不算麻烦。但是为了和 NestJS 官网教程保持一致，我们也这样做。 创建 auth module: $ nest g mo auth，在 auth 目录下创建一个 local.strategy.ts 文件： import { Injectable, UnauthorizedException } from \"@nestjs/common\"; import { PassportStrategy } from \"@nestjs/passport\"; import { Strategy } from \"passport-local\"; import { AuthService } from \"./auth.service\"; @Injectable() export class LocalStrategy extends PassportStrategy(Strategy) { constructor(private readonly authService: AuthService) { super(); } async validate(username: string, password: string) { const user = await this.authService.validateUser(username, password); if (!user) { throw new UnauthorizedException(); } return user; } } 使用 @nestjs/passport ，你需要继承 PassportStrategy 类来配置 passport 策略。通过调用子类中的 super() 方法传递策略选项，通过在子类中实现 validate() 方法，可以提供 verify 回调。Passport 定义的 所有策略 都是将 validate() 方法执行的结果作为 user 属性存储在当前 HTTP Request 对象 上,你也可以自定义此属性的名称。上面文件中的 validateUser 方法需要在 auth.service.ts 自己实现，因为框架不清楚你定义的密码散列方式。 //auth.service.ts ... async validateUser(username: string, pass: string): Promise\u003cany\u003e { const user = await this.userService.findUsername(username); console.log('-----------Login-----------') if (user \u0026\u0026 bcrypt.compareSync(pass, user.password)) { return user; } return null; } ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:2:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"实现注册登录功能 创建 auth controller: $ nest g co auth，路由功能： import { UserDto } from \"./../user/user.dto\"; import { Body, Controller, Get, Post, UseGuards, Res, Request, } from \"@nestjs/common\"; import { AuthGuard } from \"@nestjs/passport\"; import { ApiTags, ApiBearerAuth } from \"@nestjs/swagger\"; import { AuthService } from \"src/auth/auth.service\"; @ApiBearerAuth() @ApiTags(\"Auth\") @Controller(\"auth\") export class AuthController { constructor(private readonly authService: AuthService) {} @UseGuards(AuthGuard(\"jwt\")) @Get(\"users\") async findAll(@Request() req): Promise\u003cany[]\u003e { console.log(\"--------------Auth--Success---------------\"); console.log(req.user); return await this.authService.findAll(); } @Post(\"signUp\") async register(@Body() req: UserDto, @Res() res) { const result = await this.authService.register(req); res.status(result.statusCode).send(result); } @UseGuards(AuthGuard(\"local\")) @Post(\"signIn\") async login(@Body() @Request() req: UserDto, @Res() res) { console.log(\"----------Login--Success-----------\"); console.log(req); const result = await this.authService.login(req); res.status(result.statusCode).send(result); } } 注意其中的 @UseGuards(AuthGuard(‘local’)) 装饰器，因为我们写了 local.strategy.ts 文件，其中继承了 PassportStrategy 类，并实现了 validate 方法。@nestjs/passport 就会为我们实现一个 AuthGuard，我们直接在需要验证的路由前使用就好。@UseGuards(AuthGuard(‘jwt’)) 是我们接下来要讲的 JWT 认证策略。 再补充完整 auth.service.ts 文件： // auth.service.ts import { BadRequestException, Injectable, Body, Request } from \"@nestjs/common\"; import { UserService } from \"../user/user.service\"; import { JwtService } from \"@nestjs/jwt\"; import * as bcrypt from \"bcryptjs\"; @Injectable() export class AuthService { constructor( private readonly userService: UserService, private readonly jwtService: JwtService ) {} async findAll(): Promise\u003cany[]\u003e { return await this.userService.findAll(); } async validateUser(username: string, pass: string): Promise\u003cany\u003e { const user = await this.userService.findUsername(username); console.log(\"-----------Login-----------\"); if (user \u0026\u0026 bcrypt.compareSync(pass, user.password)) { return user; } return null; } async register(user: any) { let userData: any; userData = await this.userService.findUsername(user.username); if (userData) { return { statusCode: 400, message: \"This username aleady exists\" }; } await this.userService.createUser(user); userData = await this.userService.findUsername(user.username); return { username: userData.username, statusCode: 201, }; } async login(user: any) { return this.userService.findUsername(user.username).then((userData) =\u003e { const Token = this.createToken(userData); return { username: userData.username, access_token: Token, statusCode: 200, }; }); } createToken(user: any) { const payload = { username: user.username, sub: user.id }; return this.jwtService.sign(payload); } } ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:3:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"实现 JWT 认证策略 实现了用户注册登录后，我们需要保护 API，限制有的路由地址需要用户登录后才能访问，有的路由地址需要管理员登录后才能访问。我们这里只实现需要普通用户登录后才能访问的路由。 什么是 Token？ 前后端分离模式下，Token 是我们验证用户登录的常用方式。Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器会生成一个 Token 并将此 Token，返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。 为什么要使用 Token？ 在很多项目案例中，需要实现账户的功能，客户端所有的功能都基于用户已登陆的前提下才可以使用。这就要求每次客户端向服务器请求数据时都要验证账户是否正确，如果正确则按正常方式返回数据，如果错误则进行拦截并返回错误信息。但是当客户端频繁向服务器请求数据的话，每次服务器都要频繁地查询数据库。而 Token 正是为了 减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。并取代传统使用 session 的方法来进行验证。 在 Nest.js 中使用 jwt(json web token), 我们需要安装以下依赖： yarn add @nestjs/jwt passport-jwt yarn add -D @types/passport-jwt 我们在 auth.service.ts 中已经实现了生成 jwt 字符串的方法，在用户登录路由中就会调用，并返回 jwt 字符串： createToken(user: any) { const payload = { username: user.username, sub: user.id }; return this.jwtService.sign(payload); } 注意 上面 sign 的参数 payload 是可逆加密的，拿到 token 后是可以解密成明文内容的，所以这部分不要放敏感信息。 我们已经创建了 jwt 字符串作为请求令牌，那么服务端如何根据 jwt 字符串的内容，找到用户信息？ 我们就需要实现 jwt 认证策略，在 auth 文件夹下新建 jwt.strategy.ts 文件： import { Injectable } from \"@nestjs/common\"; import { PassportStrategy } from \"@nestjs/passport\"; import { ExtractJwt, Strategy } from \"passport-jwt\"; import { JWT_SECRET } from \"config\"; @Injectable() export class JwtStrategy extends PassportStrategy(Strategy) { constructor() { super({ jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), ignoreExpiration: false, secretOrKey: JWT_SECRET, }); } async validate(payload: any) { return { userId: payload.sub, username: payload.username }; } } 解释一下，对于 JWT 策略，Passport 首先验证 JWT 的签名并解码为 JSON 格式内容。仅在 @nestjs/passport 模块验证令牌有效后，才调用 validate() 方法。该方法将解码后的 JSON 作为其单个参数继续传递。否则。将阻止请求，抛出 401 Unauthorized 的异常。 现在来看我们的 auth.controller.ts，可以将 validate() 返回值输出到控制台： // auth.controller.ts @UseGuards(AuthGuard('jwt')) @Get('users') async findAll(@Request() req): Promise\u003cany[]\u003e { console.log('--------------Auth--Success---------------') console.log(req.user); return await this.authService.findAll(); } 最后这是我们的 auth.module.ts，其中注册了 jwt 字符串过期时间，我们在 auth.service.ts 中注入了 UserService，记得导入 UserModule。 // auth.module.ts @Module({ imports: [ PassportModule, JwtModule.register({ secret: JWT_SECRET, signOptions: { expiresIn: \"3600s\" }, }), UserModule, ], controllers: [AuthController], providers: [AuthService, LocalStrategy, JwtStrategy], exports: [AuthService], }) export class AuthModule {} 启动项目：$ npm run start:dev，打开 http://localhost:3000/docs 在 swagger 文档模型中测试我们的 api。先 signUp, 然后 signIn, 登录成功返回 access_token，点击那个锁符号，将 access_token 的值粘贴过去，就能通过认证了。 附：源码地址 参阅资料 Nest.JS 官方文档 Typeorm 官方文档 Node.js JWT 范例 ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:4:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"本篇文章将介绍如何用 Spring boot 与 Vue.js 创建一个具有基本 crud 功能的全栈 web 应用，我们将使用 bootstrap 作为项目的 UI 库，适合 web 开发初学者阅读。 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:0:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"后端接口 到 https://start.spring.io/ 去生成和下载 spring 应用，Group 填写 com.jpa，Artifact 填写 spring-jpa-demo， 其他默认选择就好，点击 Generate 就会生成并下载名压缩包，将压缩包解压，并在编辑器中打开。 我们使用 jpa 作为我们的 orm, 连接 mysql 数据库，因此在 pom.xml 中加入以下依赖。 \u003c!-- jpa driver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- spring web driver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- MySQL database driver --\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- Skip test plugin --\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cversion\u003e2.22.2\u003c/version\u003e \u003cconfiguration\u003e \u003cskipTests\u003etrue\u003c/skipTests\u003e \u003c/configuration\u003e \u003c/plugin\u003e ","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"I. 数据库连接 编写数据库连接文件 application.properties，它在 resources 文件夹中。 ## use create when running the app for the first time ## then change to \"update\" which just updates the schema when necessary spring.datasource.url=jdbc:mysql://localhost:3306/notesapi?createDatabaseIfNotExist=true\u0026useSSL=false\u0026serverTimezone=UTC spring.datasource.username=root spring.datasource.password=root spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver ## this shows the sql actions in the terminal logs spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true spring.jpa.properties.hibernate.format_sql=true ##optional, but just in case another application is listening on your default port (8080) server.port = 8034 这是我们的 src 文件夹结构，接下来的文件都会在 src 中编写。 服务端文件结构服务端文件结构 \" 服务端文件结构 在 entity 文件夹中新建文件 Notes.java，这是我们的数据表映射。 package com.jpa.springjpademo.entity; import javax.persistence.*; import org.hibernate.annotations.CreationTimestamp; import org.hibernate.annotations.GenericGenerator; import org.hibernate.annotations.UpdateTimestamp; import java.util.Date; @Entity @Table(name = \"notes_table\") @GenericGenerator(name = \"jpa-uuid\", strategy = \"uuid\") // 这个是hibernate的注解/生成32位UUID public class Notes { @Id @GeneratedValue(generator = \"jpa-uuid\") @Column(name = \"notes_id\", nullable = false, length = 32) private String notes_id; // 默认创建时间 @Column(name = \"create_time\") @Temporal(TemporalType.TIMESTAMP) @CreationTimestamp private Date time; // 默认更新时间 @Column(name = \"update_time\") @Temporal(TemporalType.TIMESTAMP) @UpdateTimestamp private Date update_time; @Column(name = \"title\", nullable = true, length = 100) private String title; @Column(name = \"description\", nullable = true, length = 255) private String description; @Column(name = \"content\", nullable = true) @Lob @Basic(fetch = FetchType.LAZY) private String content; @Column(name = \"author\", nullable = true, length = 50) private String author; public String getId() { return notes_id; } public void setId(String notes_id) { this.notes_id = notes_id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public void setUpdateTime(Date update_time) { this.update_time = update_time; } public Date getUpdateTime() { return update_time; } } 在 dao 文件夹中新建文件 NotesDao.java, 只需实现 JpaRepository 接口，我们就能够连接到数据库。 package com.jpa.springjpademo.dao; import com.jpa.springjpademo.entity.Notes; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; @Repository public interface NotesDao extends JpaRepository\u003cNotes, String\u003e { } 接下来终端执行 $ mvn clean package 下载依赖，编译代码。然后 $ mvn spring-boot:run 运行项目。项目运行起来后刷新数据库，可以看到新生成名为 notesapi 的数据库，其中有一个名为 notes_table 的数据表。表示我们的数据库连接成功。 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:1","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"II. 增删改查 五步实现完整的数据增删改查和接口测试： 1.实现 Conctroller 路由处理 2.实现 Service 数据库操作 3.实现 Exception 异常捕获 4.实现 Cors 跨域配置 5.实现 Swagger 文档配置 下面是详细步骤和代码示例： 实现 Conctroller 路由处理： package com.jpa.springjpademo.controller; import com.jpa.springjpademo.entity.Notes; import com.jpa.springjpademo.service.NotesService; import org.springframework.http.ResponseEntity; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(\"/api/notes\") public class NotesController { @Autowired NotesService notesService; @RequestMapping(value = \"/all\", method = RequestMethod.GET) public List\u003cNotes\u003e getAllNotes() { return notesService.getAllNotes(); } @RequestMapping(value = \"/create\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public Notes addNotes(@RequestBody Notes notes) { return notesService.addNotes(notes); } @RequestMapping(value = \"/update\", method = RequestMethod.PUT, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public Notes updateNotes(@RequestParam(\"notes_id\") String id, @RequestBody Notes notes) { return notesService.updateNotes(id, notes); } @RequestMapping(value = \"/{id}\", method = RequestMethod.GET) public Notes getNotes(@PathVariable(\"id\") String id) { return notesService.getNotesById(id); } @RequestMapping(value = \"/delete/all\", method = RequestMethod.DELETE) public void deleteAllNotes() { notesService.deleteAllNotes(); } @RequestMapping(value = \"/delete\", method = RequestMethod.DELETE) public ResponseEntity\u003c?\u003e deleteNotes(@RequestParam(\"notes_id\") String id) { return notesService.deleteNotesById(id); } } 实现 Service 数据库操作： package com.jpa.springjpademo.service; import com.jpa.springjpademo.dao.NotesDao; import com.jpa.springjpademo.entity.Notes; import com.jpa.springjpademo.exception.ResourceNotFoundException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Service; import java.util.List; @Service public class NotesService { @Autowired NotesDao notesDao; public List\u003cNotes\u003e getAllNotes() { return notesDao.findAll(); } public Notes addNotes(Notes notes) { return notesDao.save(notes); } public Notes getNotesById(String id) { return notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id)); } public Notes updateNotes(String id, Notes notes) { Notes tnotes = notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id)); tnotes.setTitle(notes.getTitle()); tnotes.setDescription(notes.getDescription()); tnotes.setContent(notes.getContent()); tnotes.setAuthor(notes.getAuthor()); return notesDao.save(tnotes); } public ResponseEntity\u003c?\u003e deleteNotesById(String id) { Notes notes = notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id)); notesDao.delete(notes); return ResponseEntity.ok().build(); } public void deleteAllNotes() { notesDao.deleteAll(); } } 实现 Exception 异常捕获： package com.jpa.springjpademo.exception; import org.springframework.http.HttpStatus; import org.springframework.web.bind.annotation.ResponseStatus; @ResponseStatus(value = HttpStatus.NOT_FOUND) public class ResourceNotFoundException extends RuntimeException { private static final long serialVersionUID = 1L; private String resourceName; private String fieldName; private Object fieldValue; public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) { super(String.format(\"%s not found with %s : '%s'\", resourceName, fieldName, fieldValue)); this.resourceName = resourceName; this.fieldName = fieldName; this.fieldValue = fieldValue; } public String getResourceName() { return resourceName; } public String getFieldName() { return fieldName; } public Object getFieldValue() { return fieldValue; } } 实现 Cors 跨域配置： packag","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:2","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"前端界面 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"I. 初始化配置 先安装好 Vue/cli 工具: $ npm install -g @vue/cli 安装完成后生成 Vue 项目: $ vue create blog-frontend 输入此命令后，我们将看到一个简短的提示。选择 manually select features 选项（手动选择特性）。然后按空格表示选择，我们选择 Babel、Router 和 Linter/Formatter。后面选项一路回车就好。 我们使用 bootstrap 库定义基本的 css 样式。在 public 文件夹的 index.html 中加入以下代码： \u003clink rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css\" /\u003e \u003cscript src=\"https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js\"\u003e\u003c/script\u003e 安装 axios 处理 http 请求，这是一种基于 Promise 的浏览器 HTTP 客户端： $ yarn add axios 在 src 目录中新建文件夹 utils, 新建文件 helper.js, 对接后端接口: export const server = { baseURL: \"http://localhost:8034/api/notes\", }; ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:1","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"II. 创建页面组件 在 component 中新建文件夹 post, 新建三个文件：Create.vue, Edit.vue, Post.vue 新增帖子组件 Create.vue \u003ctemplate\u003e \u003cdiv\u003e \u003cdiv class=\"col-md-12 form-wrapper\"\u003e \u003ch2\u003eCreate Post\u003c/h2\u003e \u003cform id=\"create-post-form\" @submit.prevent=\"createPost\"\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"title\"\u003eTitle\u003c/label\u003e \u003cinput type=\"text\" id=\"title\" v-model=\"title\" name=\"title\" class=\"form-control\" placeholder=\"Enter title\" /\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"description\"\u003eDescription\u003c/label\u003e \u003cinput type=\"text\" id=\"description\" v-model=\"description\" name=\"description\" class=\"form-control\" placeholder=\"Enter Description\" /\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"content\"\u003eWrite Content\u003c/label\u003e \u003ctextarea id=\"content\" cols=\"30\" rows=\"5\" v-model=\"content\" class=\"form-control\" \u003e\u003c/textarea\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"author\"\u003eAuthor\u003c/label\u003e \u003cinput type=\"text\" id=\"author\" v-model=\"author\" name=\"author\" class=\"form-control\" /\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003cbutton class=\"btn btn-success\" type=\"submit\"\u003eCreate Post\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e 这是 Create.vue 组件 script 标签中的内容 import axios from \"axios\"; import { server } from \"../../utils/helper\"; import router from \"../../router\"; export default { data() { return { title: \"\", description: \"\", content: \"\", author: \"111hunter\", }; }, methods: { createPost() { let postData = { title: this.title, description: this.description, content: this.content, author: this.author, }; this.__submitToServer(postData); }, __submitToServer(data) { axios.post(`${server.baseURL}/create`, data).then((data) =\u003e { router.push({ name: \"home\" }); }); }, }, }; 修改帖子组件 Edit.vue \u003ctemplate\u003e \u003cdiv\u003e \u003ch4 class=\"text-center mt-20\"\u003e \u003csmall\u003e \u003cbutton class=\"btn btn-info\" v-on:click=\"navigate()\"\u003e View All Posts \u003c/button\u003e \u003c/small\u003e \u003c/h4\u003e \u003cdiv class=\"col-md-12 form-wrapper\"\u003e \u003ch2\u003eEdit Post\u003c/h2\u003e \u003cform id=\"edit-post-form\" @submit.prevent=\"editPost\"\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"title\"\u003eTitle\u003c/label\u003e \u003cinput type=\"text\" id=\"title\" v-model=\"post.title\" name=\"title\" class=\"form-control\" placeholder=\"Enter title\" /\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"description\"\u003eDescription\u003c/label\u003e \u003cinput type=\"text\" id=\"description\" v-model=\"post.description\" name=\"description\" class=\"form-control\" placeholder=\"Enter Description\" /\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"content\"\u003eWrite Content\u003c/label\u003e \u003ctextarea id=\"content\" cols=\"30\" rows=\"5\" v-model=\"post.content\" class=\"form-control\" \u003e\u003c/textarea\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003clabel for=\"author\"\u003eAuthor\u003c/label\u003e \u003cinput type=\"text\" id=\"author\" v-model=\"post.author\" name=\"author\" class=\"form-control\" /\u003e \u003c/div\u003e \u003cdiv class=\"form-group col-md-12\"\u003e \u003cbutton class=\"btn btn-warning\" type=\"submit\"\u003eEdit Post\u003c/button\u003e \u003c/div\u003e \u003c/form\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e 这是 Edit.vue 组件 script 标签中的内容 import { server } from \"../../utils/helper\"; import axios from \"axios\"; import router from \"../../router\"; export default { data() { return { id: 0, post: {}, }; }, created() { this.id = this.$route.params.id; this.getPost(); }, methods: { editPost() { let postData = { title: this.post.title, description: this.post.description, content: this.post.content, author: this.post.author, }; axios .put(`${server.baseURL}/update/?notes_id=${this.id}`, postData) .then((data) =\u003e { router.push({ name: \"home\" }); }); }, getPost() { axios .get(`${server.baseURL}/${this.id}`) .then((data) =\u003e (this.post = data.data)); }, navigate() { router.go(-1); }, }, }; 帖子详情组件 Post.vue \u003ctemplate\u003e \u003cdiv class=\"text-center\"\u003e \u003cdiv class=\"col-sm-12\"\u003e \u003ch4 style=\"margin-top: 30px;\"\u003e \u003csmall\u003e \u003cbutton class=\"btn btn-info\" v-on:click=\"navigate()\"\u003e View All Posts \u003c/button\u003e \u003c/small\u003e \u003c/h4\u003e \u003chr /\u003e \u003ch2\u003e{{ post.title }}\u003c/h2\u003e \u003ch5\u003e \u003cspan class=\"glyphicon glyphicon-time\"\u003e\u003c/span\u003e Post by {{post.author}}, {{new Date(post.updateTime).toLocaleDateString()}}. \u003c/h5\u003e \u003cp\u003e{{ post.content }}\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e 这是 Post.vue 组件 script 标签中的内容 import { server }","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:2","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"III. 搭建路由 在根组件 App.vue 中修改链接: \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e 将 about 改为 create, 链接到 Create 组件: \u003crouter-link to=\"/Create\"\u003eCreate\u003c/router-link\u003e 最后将 router/index.js 改为以下代码： import Vue from \"vue\"; import Router from \"vue-router\"; import HomeComponent from \"@/views/Home\"; import EditComponent from \"@/components/post/Edit\"; import CreateComponent from \"@/components/post/Create\"; import PostComponent from \"@/components/post/Post\"; Vue.use(Router); export default new Router({ mode: \"history\", base: process.env.BASE_URL, routes: [ { path: \"/\", redirect: { name: \"home\" } }, { path: \"/home\", name: \"home\", component: HomeComponent }, { path: \"/create\", name: \"Create\", component: CreateComponent }, { path: \"/edit/:id\", name: \"Edit\", component: EditComponent }, { path: \"/post/:id\", name: \"Post\", component: PostComponent }, ], }); 编写完前端代码，启动服务： $ npm run serve 浏览器打开 http://localhost:8080 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:3","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"成果展示 pc 端页面展示： pc端页面展示pc端页面展示 \" pc端页面展示 移动端页面展示： 移动端页面展示移动端页面展示 \" 移动端页面展示 附：源码地址 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:3:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":" ReactiveX 结合了 观察者模式、迭代器模式 和 使用集合的函数式编程，以满足以一种理想方式来管理事件序列所需要的一切。 在 RxJS 中用来解决异步事件管理的的基本概念是： Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。 Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。 Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。 Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。 Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。 Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。 以上文字来自 RxJS 中文文档，是 RxJS 的核心概念。 下面来学习创建 Observable 对象以加深对一些概念的理解。 本文将生成 observable 的操作符分为以下四类： 转换操作符：from，fromEvent，fromPromise，of 创建操作符：create, range 时间操作符：interval, timer 特殊操作符：empty, never, throw ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:0:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"项目初始化 我们使用 webpack 作为项目构建工具。使用 Babel 编译我们的代码。这是我们的项目依赖： \"devDependencies\": { \"@babel/core\": \"^7.8.7\", \"@babel/preset-env\": \"^7.8.7\", \"babel-loader\": \"^8.0.6\", \"webpack\": \"^4.42.0\" }, \"dependencies\": { \"jquery\": \"^3.1.0\", \"rxjs\": \"^5.0.0-beta.12\" } webpack 配置文件 webpack.config.js: module.exports = { entry: \"./src/app.js\", output: { path: __dirname + \"/dist\", filename: \"app.bundle.js\", }, module: { rules: [ { test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: { loader: \"babel-loader\", options: { presets: [\"@babel/preset-env\"], }, }, }, ], }, }; 新建文件夹 src, 在里面新建文件 app.js, 我们在 app.js 中引入 jquery 和 RxJS。 import $ from \"jquery\"; import Rx from \"rxjs/Rx\"; console.log(\"Code Running...\"); 在 html 文件中引入编译后的 js 文件。 \u003cbody\u003e \u003cinput type=\"text\" id=\"input\" /\u003e \u003cdiv id=\"output\"\u003e\u003c/div\u003e \u003cul\u003e \u003cli id=\"name\"\u003e\u003c/li\u003e \u003cli id=\"artist\"\u003e\u003c/li\u003e \u003c/ul\u003e \u003cscript src=\"./dist/app.bundle.js\"\u003e\u003c/script\u003e \u003c/body\u003e 执行 webpack --watch --mode development，实时监视文件变化，并重新编译代码。 打开浏览器控制台没有任何报错，并输出 “Code Running…” 说明我们的项目构建成功。 高版本的 chrome 可能出现 DevTools failed to parse SourceMap，在控制台的 setting 中取消 Enable JavaScript source maps 这一项即可。 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:1:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"转换操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.from() Observable.from() 将 可迭代对象 转化为 observables 序列, 传入数据集合。 // from array const numbers = [1, 2, 3, 4, 5]; const numbers$ = Rx.Observable.from(numbers); numbers$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), () =\u003e console.log(\"complete\") ); // from string const str = \"hello world\"; const str$ = Rx.Observable.from(str); str$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), () =\u003e console.log(\"complete\") ); // from array of objects const posts = [ { title: \"post 1\", body: \"body 1\" }, { title: \"post 2\", body: \"body 2\" }, { title: \"post 3\", body: \"body 3\" }, ]; const posts$ = Rx.Observable.from(posts); posts$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), () =\u003e console.log(\"complete\") ); // from set const set = new Set([\"hello\", 123, { title: \"my title\" }]); const set$ = Rx.Observable.from(set); set$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), () =\u003e console.log(\"complete\") ); // from map const map = new Map([ [1, 2], [3, 4], [5, 6], ]); const map$ = Rx.Observable.from(map); map$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), () =\u003e console.log(\"complete\") ); ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.fromEvent() Observable.fromEvent() 将 事件 转化为 observables 序列, 传入两个参数：页面元素 和 事件名称。从事件中创建的 observable 对象是持续不断产生的，不会输出 “completed”。 转化键盘事件: const input = $(\"#input\"); const output = $(\"#output\"); const inputStream$ = Rx.Observable.fromEvent(input, \"keyup\"); inputStream$.subscribe( (e) =\u003e { console.log(e.target.value); output.text(e.target.value); }, (err) =\u003e console.log(err), () =\u003e console.log(\"completed\") ); 转化鼠标事件: const moveStream$ = Rx.Observable.fromEvent(document, \"mousemove\"); moveStream$.subscribe( (e) =\u003e { console.log(e.type); output.html(\"\u003ch1\u003eX: \" + e.clientX + \" Y: \" + e.clientY + \"\u003c/h1\u003e\"); }, (err) =\u003e console.log(\"err\"), () =\u003e console.log(\"completed\") ); ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:2","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.fromPromise() Observable.fromPromise() 将 promise 转化为 observables 序列, 传入 promise。 const myPromise = new Promise((resolve, reject) =\u003e { console.log(\"creating promise\"); setTimeout(() =\u003e { resolve(\"hello from promise\"); }, 500); }); const myPromiseSource$ = Rx.Observable.fromPromise(myPromise); myPromiseSource$.subscribe((x) =\u003e console.log(x)); 结合之前定义的 inputStream$ 嵌套使用： function getSong(username) { return $.ajax({ type: \"GET\", url: `https://autumnfish.cn/search?keywords=` + username, }).promise(); } const song = $(\"#input\"); const inputStream$ = Rx.Observable.fromEvent(song, \"keyup\"); inputStream$.subscribe((e) =\u003e { Rx.Observable.fromPromise(getSong(e.target.value)).subscribe((x) =\u003e { $(\"#name\").text(\"Song: \" + x.result.songs[0].name); console.log(x.result.songs[0].name); $(\"#artist\").text(\"Artist: \" + x.result.songs[0].artists[0].name); }); }); ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:3","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.of() of 操作符接收 1 个或多个参数。转换为 Observable 对象。 const stream$ = Rx.Observable.of(1, 2, 3, \"hello\"); stream$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), (complete) =\u003e console.log(\"complete\") ); ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:4","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"创建操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.create() Rx.Observable.create 是 Observable 构造函数 的别名，它接收一个以 observer 作为参数的回调函数。这个回调函数会定义 observable 将会如何发送值给 observer。observer 是什么？observer 就是我们之前传入 subscribe() 的参数，是一个有三个回调函数的对象。 const source$ = new Rx.Observable.create((observer) =\u003e { observer.next(\"hello\"); observer.next(\"another hello\"); setTimeout(() =\u003e { observer.next(\"next hello\"); observer.complete(); }, 2000); }); const observer1 = { next: (v) =\u003e console.log(v + \"1\"), error: (err) =\u003e console.log(err), complete: () =\u003e console.log(\"complete\"), }; source$.subscribe(observer1); observable 是数据流的生产者，决定数据怎么给。observer 是数据流的消费者，决定数据怎么用。observable 是老板，observer 是顾客。 observable.subscribe()会实例化一个 Subscription 对象。Subscription 表示 Observable 的执行，可以被清理。这个对象最常用的方法是 unsubscribe 方法。 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.range() 接收两个数字参数产生有序序列，一个是开始序列数字。一个是序列个数。 const rangeSource$ = Rx.Observable.range(6, 5); rangeSource$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), (complete) =\u003e console.log(\"complete\") ); ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:2","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"时间操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:4:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.interval 和 Observable.timer 从零开始产生数字，interval 的参数是数字产生的间隔时间，timer 多了个开始延迟时间作为第一个参数。 const intervalSource$ = Rx.Observable.interval(1000).take(5); intervalSource$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), (complete) =\u003e console.log(\"complete\") ); const timerSource$ = Rx.Observable.timer(2000, 1000).take(5); timerSource$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), (complete) =\u003e console.log(\"complete\") ); ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:4:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"特殊操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:5:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.empty(), Observable.never() 和 Observable.throw() Observable.empty 创建的 Observable 开始就结束，Observable.never 创建的 Observable 不会结束，Observable.throw 抛出异常不会结束。 const emptySource$ = Rx.Observable.empty(); emptySource$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), (complete) =\u003e console.log(\"complete\") ); const neverSource$ = Rx.Observable.never(); neverSource$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(err), (complete) =\u003e console.log(\"complete\") ); const errorSource$ = Rx.Observable.throw(\"err\"); errorSource$.subscribe( (v) =\u003e console.log(v), (err) =\u003e console.log(\"Throw Error: \" + err), (complete) =\u003e console.log(\"complete\") ); 附：源码地址 参阅资料 RxJS Ultimate 中文版 30 天精通 RxJS RxJS 中文文档 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:5:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"随着代码量的增长传统服务端 MVC 模式中 Modal 和 Controller 会变得含糊不清，导致难于维护。下面是传统 MVC 服务端架构： 传统MVC架构传统MVC架构 \" 传统MVC架构 Nest(Nest.js) 的分层借鉴自 Spring，更细化。我们应该要了解整个 Nest 框架的三层结构，Nest 和传统的 MVC 框架的区别在于它更注重于后端部分（控制器、服务与数据）的架构，视图层相对比较独立，完全可以由用户自定义配置。 NestJS三层架构NestJS三层架构 \" NestJS三层架构 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:0:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"创建 Nest 项目 $ npm install -g @nest/cli 全局安装 nest 脚手架 $ nest new nest-crud 新建 nest.js 项目, 选择 yarn 作为开发工具 $ nest g mo photo 建立 PhotoModule $ nest g co photo 建立 PhotoController $ nest g s photo 建立 PhotoService $ yarn add @nestjs/typeorm typeorm mysql 需要使用 typeorm, mysql 需要安装这些库 在 TypeORM 中数据库的表对应的就是一个类，通过定义一个类来创建实体。实体（Entity）是一个映射到数据库表的类 (类似于 mongoose 中的 Schema 映射到 MongoDB 的 collection)，通过@Entity()来标记。在 photo 文件夹中新建 photo.entity.ts: // photo.entity.ts import { Column, Entity, PrimaryGeneratedColumn } from \"typeorm\"; @Entity(\"photo\") export class PhotoEntity { @PrimaryGeneratedColumn() id: number; @Column({ length: 500 }) name: string; @Column(\"text\") description: string; @Column() filename: string; @Column(\"int\") views: number; @Column() isPublished: boolean; } 在 app.module.ts 中的 import 数组中配置数据库连接，可以配置多个数据库连接。 TypeOrmModule.forRoot({ type: \"mysql\", host: \"localhost\", port: 3306, username: \"root\", password: \"123456\", database: \"test\", entities: [PhotoEntity], synchronize: true, }); 然后在 photo.mudule.ts 中 import 数组中注册要本模块使用的数据库。这样，我们就可以使用 @InjectRepository() 装饰器将 PhotoRepository 注入到 PhotoService 中 imports: [TypeOrmModule.forFeature([PhotoEntity])]; 数据传输对象简称 DTO(Data Transfer Object)，是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。class-validator 可以很方便地验证前端传过来的参数。 // photo.dto.ts import { IsString, IsInt, IsBoolean } from \"class-validator\"; export class PhotoDto { @IsInt() readonly id: number; @IsString() readonly name: string; @IsString() readonly description: string; @IsString() readonly filename: string; @IsInt() readonly views: number; @IsBoolean() readonly isPublished: boolean; } ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:1:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"三层结构 将 PhotoRepository 注入到 PhotoService 中, 写数据库操作的 crud 代码: @Injectable() export class PhotoService { constructor( @InjectRepository(PhotoEntity) private readonly photoRepository: Repository\u003cPhotoEntity\u003e ) {} async findAll(): Promise\u003cPhotoEntity[]\u003e { return this.photoRepository.find(); } async create(photoDto: PhotoDto): Promise\u003cPhotoEntity\u003e { return await this.photoRepository.save(photoDto); } async delete(id: number) { return await this.photoRepository.delete(id); } async update(photoDto: PhotoDto) { return await this.photoRepository.update(photoDto.id, photoDto); } async findOne(id: number): Promise\u003cPhotoEntity\u003e { return await this.photoRepository.findOne(id); } } 将 PhotoService 注入到 PhotoController 中, 写 api 路由: @Controller(\"photo\") export class PhotoController { constructor(private readonly photoService: PhotoService) {} @Get() findAll(): Promise\u003cPhotoEntity[]\u003e { return this.photoService.findAll(); } @Post(\"create\") create(@Body() PhotoDto: PhotoDto): Promise\u003cPhotoEntity\u003e { return this.photoService.create(PhotoDto); } @Delete(\"delete/:id\") delete(@Param(\"id\") id: number) { return this.photoService.delete(id); } @Put(\"update/:id\") update(@Param(\"id\") id: number, @Body() PhotoDto: PhotoDto) { return this.photoService.update(PhotoDto); } @Get(\":id\") findOne(@Param(\"id\") id: number): Promise\u003cPhotoEntity\u003e { return this.photoService.findOne(id); } } 接下来在 main.ts 中配置 swagger, 方便我们测试 api const app = await NestFactory.create(AppModule); const options = new DocumentBuilder() .setTitle(\"photo example\") .setDescription(\"The photo API description\") .setVersion(\"0.0.1\") .build(); const document = SwaggerModule.createDocument(app, options); SwaggerModule.setup(\"docs\", app, document); await app.listen(3000); $ npm run start 启动 nest 项目, 访问 http://localhost:3000/docs ，到这里基本的 crud 操作已经实现，此时，NestJS 框架的三层结构已有体现。接下来再完善项目。 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:2:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"AOP 的思想 我们在 PhotoController 的路由请求参数中传入了 DTO, 做了直接的参数校验。传入类型不符合要求时，会直接报错。DTO 中的 class-validator 还需要配合 pipe 才能完成校验功能。新建一个 pipe 捕获异常。$ nest g pi section/validation @Injectable() export class ValidationPipe implements PipeTransform\u003cany\u003e { async transform(value, metadata: ArgumentMetadata) { const { metatype } = metadata; if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length \u003e 0) { const errorMessage = _.values(errors[0].constraints)[0]; throw new BadRequestException(errorMessage); } return value; } private toValidate(metatype): boolean { const types = [String, Boolean, Number, Array, Object]; return !types.find((type) =\u003e metatype === type); } } 有了这一层 pipe 帮助我们校验参数，有效地降低了类的复杂度，提高了可读性和可维护性。我们还可以对正确的请求，异常的请求进行包装，假设返回的格式是这样的： # 请求失败 { status: 1, message: string, } # 请求成功 { status: 0, message: '请求成功', data: any } 可以利用 AOP 的思想去做这件事。全局捕获错误的切片层去处理所有的 exception，如果是一个成功的请求，需要把这个返回结果通过一个切片层包装一下。 在 NestJs 中，Exception Filter 是最后捕获 exception 的机会。我们把它作为处理全局错误的切片层。$ nest g f section/errors @Catch() export class ExceptionsFilter implements ExceptionFilter { async catch(exception, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse(); const request = ctx.getRequest(); let message = exception.message; let isDeepestMessage = false; while (!isDeepestMessage) { isDeepestMessage = !message.message; message = isDeepestMessage ? message : message.message; } const errorResponse = { message: message || \"请求失败\", status: 1, }; const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR; response.status(status); response.header(\"Content-Type\", \"application/json; charset=utf-8\"); response.send(errorResponse); } } 而 Interceptor 则负责对成功请求结果进行包装：$ new g in section/transform interface Response\u003cT\u003e { data: T; } @Injectable() export class TransformInterceptor\u003cT\u003e implements NestInterceptor\u003cT, Response\u003cT\u003e\u003e { intercept( context: ExecutionContext, next: CallHandler ): Observable\u003cResponse\u003cT\u003e\u003e { return next.handle().pipe( map((rawData) =\u003e { return { data: rawData, status: 0, message: \"请求成功\", }; }) ); } } 将 Interceptor, Exception Filter 和 Pipe 定义在全局范围内: app.useGlobalFilters(new ExceptionsFilter()); app.useGlobalInterceptors(new TransformInterceptor()); app.useGlobalPipes(new ValidationPipe()); $ npm run start 打开 http://localhost:3000/docs, 测试 api 结果正如我们预期的那样。 附：源码地址 参阅资料 DI(依赖注入) NestJS 官方文档 TypeORM 官方文档 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:3:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"Git 是一个全世界开发者都在用的版本控制系统。它会帮助你与其他开发者合作，以及跟踪你不同版本的代码。如果你长时间在一个项目工作，你也许会想对那些有改动的地方保持跟踪：是谁，以及什么时候改动的。要是最终你发现你的代码里有 bug，这跟踪就变得更重要了。 git版本控制git版本控制 \" git版本控制 本文实践较多，建议跟着文章的步骤敲一遍代码以加深理解。 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:0:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"1. 使用帮助 $ git help 可以查看 git 常用命令 $ git help -a 可以查看 git 所有命令，F 或者 空格 向下查看命令，B 向上查看命令，Q 退出 git-cli $ git help add help 后接一个指令可以查看该指令的详细用法 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:1:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"2. git 配置范围 git 配置分为三个范围 system, global 和 项目范围 一般选择 global 进行配置 $ git config --global user.name '111hunter' $ git config --list 查看当前配置信息 $ git config --unset --global user.name 取消 user.name 配置 配置文件是当前用户主目录 $ cat ~/.gitconfig ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:2:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"3. git 项目文件 $ mkdir movietalk \u0026\u0026 cd movietalk 新建文件夹 $ git init 初始化项目 $ cd .git \u0026\u0026 ls -a config 目录就是项目级别的配置 $ cd .. \u0026\u0026 touch index.html 新建文件 $ vim index.html 编辑文件后保存 $ git add . 提交所有文件到暂存区 $ git commit -m \"first commit\" 暂存区文件提交仓库区 $ git log 查看提交日志信息 $ vim index.html 将 index.html 中 charset=“UTF-8” 改为 charset=“GBK” $ git status 查看文件状态 $ git diff index.html 查看暂存区文件与本地工作区的对比 $ git diff --staged 查看仓库区与暂存区对比，此时一致 $ git add . 然后 $ git diff index.html 此时没有区别了，因为已将文件提交暂存区 $ vim index.html 再次修改，在文件中新增适应移动端的 meta 标签 $ git diff --staged 查看仓库区与暂存区对比 $ git commit -m \"修改了charset属性\" 暂存区提交仓库 $ git diff --staged 此时暂存区与仓库一致 $ git log 查看提交日志信息, 此时有两条提交信息 $ git status 查看文件状态 $ git add . \u0026\u0026 git commit -m \"新增meta标签\" 工作区文件提交到仓库 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"重命名 git 已跟踪文件 $ touch style.css \u0026\u0026 vim style.css 新建 css 文件 $ mv style.css theme.css 修改文件名 $ git status 查看文件状态 $ git rm style.css \u0026\u0026 git add theme.css 就能修改文件名字 $ git commit -m \"mv style.css theme.css\" 上传仓库区 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:1","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"git 移动文件 $ git mv theme.css aha.css 移动文件，重命名 $ mkdir css \u0026\u0026 git status git 不会跟踪空文件 $ git mv aha.css /css 移动文件 $ git commit -m \"move aha.css\" 上传仓库区 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:2","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"git 删除文件与恢复 $ git rm index.html 从工作区与暂存区中删除 index.html $ git checkout HEAD -- index.html HEAD 指针指向最近一次提交， – 表示当前分支，将 index.html 恢复到当前 commit 的状态 $ git rm index.html \u0026\u0026 git commit -m \"删除了index.html\" 从工作区与暂存区中删除 index.html, 并提交仓库 $ git checkout \"HEAD^\" -- index.html 恢复到上一次提交，windows cmd 中 ^ 会被当做换行处理，需要加上引号 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:3","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"git 恢复某个操作状态 在 css 文件夹引入 bootstrap vim index.html 在 index.html 中引入 bootstrap git commit -am \"增加了bootstrap\" 提交仓库 新建 js 文件夹并引入 jquery vim index.html 在 index.html 中引入 jquery git commit -am \"增加了jquery\" 提交仓库 git log --oneline 查看提交日志 id, 添加 bootstrap 的 id 为 981eb52 git revert 981eb52 撤销对 bootstrap 的提交，查看工作区文件夹发现 index.html 对 bootstrap 的引入消失了 每次 git commit 后 HEAD 都会指向最后一次提交，用 git reset 可以帮助回到某次提交时的状态，有 3 个可选配置参数: –mixed, –soft, –hard –soft 软重置，不会修改任何文件状态。该参数用于 git commit 后，又要恢复还没 commit 的场景，重新审查代码，然后再推上去覆盖之后的提交。 $ git log --oneline 查看添加 jquery 的 id 为 e9ae8b5，Revert “添加了 bootstrap\"的 id 为 3e3da01 $ git reset --soft e9ae8b5 回到提交 jquey 的 commit，但是不会对文件做任何操作 $ git status 会提示 撤销 bootstrap 时的消息 默认是 –mixed, 只影响暂存区文件状态 $ git reset --mixed e9ae8b5 \u0026\u0026 git status 发现 bootstrap 已经不在暂存区了 –hard 会直接重置暂存区和工作区文件到指定 id 状态，用 git reset –hard 可直接在不同提交状态切换。 $ git reset --hard e9ae8b5 \u0026\u0026 git log --oneline 查看工作区文件发现 bootstrap 又回来了 $ git reset --hard 3e3da01 \u0026\u0026 git log --oneline 文件又到了最后一次提交时的状态 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:4","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"4. git 项目分支 $ git branch testing \u0026\u0026 git checkout testing 新建并切换分支，此时对文件的修改只影响 branch 分支 $ vim index.html 在 index.html 中引入 link 标签 $ git commit -am \"添加link标签\" 提交仓库区 $ git checkout master 切换回 master 分支，查看工作区文件发现对文件的修改没有了 $ git diff master..testing index.html 查看分支间的文件对比 $ git merge testing 分支合并 $ git diff master..testing 没有不同，已经合并了分支 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"解决分支合并冲突 $ vim index.html 修改 document 为 Movietalk $ git commit -am \"修改标题为Movietalk\" 提交仓库区 $ git checkout testing \u0026\u0026 vim index.html 切换分支，修改 document 为 Movie-talk $ git commit -am \"修改标题为Movie-talk\" 提交仓库区 $ git merge master 产生冲突。git 发现冲突，查看文件会有提示，编辑保留其中一个 document 修改 $ git commit -am \"解决冲突\" 提交 $ git log --oneline --all -10 --graph 查看所有分支提交信息 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:1","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"保存当前工作状态 git stash 指令能够保存当前工作状态到 git 栈 $ touch human.txt \u0026\u0026 git commit -am \"add human.txt\" 新建空文件 $ vim human.txt 加入任意内容 $ git status 查看修改，不提交 $ git stash save \"修改了human.txt\" 保存工作进度，查看文件 human.txt 又变成了空文件 $ git stash list 查看工作进度 $ git stash show -p stash@{0} 以补丁的方式查看工作进度与工作目录的区别 $ git stash apply stash@{0} 切换到之前的工作进度，发现对 human.txt 的修改又生效了 $ git stash pop 切换栈顶工作状态 $ git stash drop stash@{0} 删除工作状态 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:2","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"5. git 远程仓库 新建远程仓库后请清空仓库，不要保留任何文件 $ git remote add origin https://gitee.com/hunter_111/movietalk.git 关联远程仓库 $ git remote -v 查看是否关联, fetch 远程用来提取，push 远程用来推送 $ git push -u origin master 推送到远程分支，并跟踪远程分支变化 $ git push origin testing 推送远程分支，不跟踪变化 参阅资料 廖雪峰的 git 教程 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:5:0","tags":["Git"],"title":"Git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"扫雷是一款大众类的益智小游戏,于 1992 年发行。游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子,同时避免踩雷,踩到一个雷即全盘皆输。 JS实现的扫雷小游戏JS实现的扫雷小游戏 \" JS实现的扫雷小游戏 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:0:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"游戏规则 在写扫雷之前，我们先了解下它的游戏规则： 扫雷是一个矩阵，地雷随机分布在其中的方格里。 方格上的数字代表着这个方格所在的九宫格内有多少个地雷。 游戏玩家用鼠标左键打开方格，用鼠标右键标记地雷。 踩到地雷，游戏失败。打开所有非雷方格，游戏胜利。 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:1:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"功能实现 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"矩阵的生成 用 html 中的表格 table，span 生成矩阵方格。把矩阵方格放入二维数组中，然后对单个方格添加鼠标事件。 //初始化矩阵 (row-行数 col-列数) function init_grid() { //生成矩阵html \u003ctr\u003e--行标签 \u003ctd\u003e--列标签 let gridHtml = \"\"; for (let i = 0; i \u003c row; i++) { gridHtml += \"\u003ctr\u003e\"; for (let j = 0; j \u003c col; j++) { gridHtml += '\u003ctd\u003e\u003cspan class=\"blocks\" onmousedown=\"block_click(' + i + \",\" + j + ',event)\"\u003e\u003c/span\u003e\u003c/td\u003e'; } gridHtml += \"\u003ctr\u003e\"; } //写入html document.getElementById(\"grid\").innerHTML = gridHtml; //返回矩阵二维数组 let blocks = document.getElementsByClassName(\"blocks\"); let grid = new Array(); for (let i = 0; i \u003c blocks.length; i++) { if (i % col === 0) { grid.push(new Array()); } //初始化计雷数 blocks[i].count = 0; grid[parseInt(i / col)].push(blocks[i]); } return grid; } ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:1","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"方格打开与标记 通过 onmousedown 事件，传入点击的方格的坐标及 event，判断 event 为左键还是右键。左键打开方格，右键标记方格。 //方格点击事件 _i：坐标i _j:坐标j e:鼠标事件 function block_click(_i, _j, e) { //跳过已打开的方格 if (grid[_i][_j].isOpen) { return; } //鼠标左键打开方格 if (e.button === 0) { ... //执行递归打开方格函数 block_open(_i, _j); } //鼠标右键标记方格 else if (e.button === 2) { let block = grid[_i][_j]; if (block.innerHTML !== '▲') { block.innerHTML = '▲'; } else { block.innerHTML = ''; } } } ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:2","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"地雷随机分布 第一次打开的方格不能为地雷，把生成地雷的函数放在第一次点击方格后。 通过循环用 Math.random() 函数来随机生成地雷的二维坐标。 判断坐标是否不为第一次点击方格的坐标以及该坐标没有雷存在。 是则将方格设置为地雷，当前地雷数+1，将该方格所在九宫格内的方格的计雷数+1。 否则跳过进入下个循环，直到地雷的数量达到设定的最大雷数，结束循环。 //方格点击事件 _i：坐标i _j:坐标j e:鼠标事件 function block_click(_i, _j, e) { //跳过已打开的方格 if (grid[_i][_j].isOpen) { return; } //鼠标左键打开方格 if (e.button === 0) { //第一次打开 if (isFirstOpen) { isFirstOpen = false; let count = 0; //当前地雷数 //生成地雷 while (count \u003c maxCount) { //生成随机坐标 let ri = Math.floor(Math.random() * row); let rj = Math.floor(Math.random() * col); //坐标不等于第一次点击方格的坐标 \u0026\u0026 非雷方格 if (!(ri === _i \u0026\u0026 rj === _j) \u0026\u0026 !grid[ri][rj].isMine) { grid[ri][rj].isMine = true; //自定义属性isMine代表方格为地雷 count++; //当前地雷数+1 //更新九宫格内非雷方格的计雷数 for (let i = ri - 1; i \u003c ri + 2; i++) { for (let j = rj - 1; j \u003c rj + 2; j++) { //判断坐标防越界 if (i \u003e -1 \u0026\u0026 j \u003e -1 \u0026\u0026 i \u003c row \u0026\u0026 j \u003c col) { //计雷数+1 grid[i][j].count++; } } } } } } //执行打开方格函数 block_open(_i, _j); } } ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:3","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"递归打开方格 当打开的方格为计雷数为 0 的方格，自动打开九宫格内的非雷方格。如果打开的非雷方格九宫格内仍有非雷方格，用递归继续打开九宫格内的非雷方格，直到没有为止。 //递归打开方格函数 function block_open(_i, _j) { let block = grid[_i][_j]; op(block); //设定打开方格的状态与样式 function op(block) { block.isOpen = true; //isOpen为自定义属性，设置为true代表已打开 block.style.background = '#ccc'; //将背景设置为灰色 block.style.cursor = 'default'; //将鼠标停留样式设置为默认 } //打开计雷数为0的方格 if (block.count === 0) { //遍历九宫格内的方格 for (let i = _i - 1; i \u003c _i + 2; i++) { for (let j = _j - 1; j \u003c _j + 2; j++) { //判断是否越界\u0026\u0026跳过已打开的方格\u0026\u0026非雷 if (i \u003e -1 \u0026\u0026 j \u003e -1 \u0026\u0026 i \u003c row \u0026\u0026 j \u003c col \u0026\u0026 !grid[i][j].isOpen \u0026\u0026 !grid[i][j].ismine) { //递归打开方格函数 block_open(i, j); } } } } // 踩雷 else if (block.isMine) { ... } //打开计雷数不为0的方格 else { block.innerHTML = block.count; //显示计雷数 } } ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:4","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"踩雷游戏结束 打开方格为地雷时，提示游戏结束。通过遍历矩阵打开所有埋地雷位置。 else if (block.isMine) { block.innerHTML = '雷'; //显示为 '雷' //遍历矩阵打开所有埋地雷的方格 for (let i = 0; i \u003c row; i++) { for (let j = 0; j \u003c col; j++) { //找到地雷 block = grid[i][j]; if (!block.isOpen \u0026\u0026 block.isMine) { op(block); //设置打开状态和样式 block.innerHTML = '雷'; //显示为 '雷' } } } clearInterval(timer); //游戏结束停止计时，清除定时器 //提示游戏结束 alert(\"你踩到雷了！游戏结束\"); } ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:5","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"游戏胜利条件 当所有非雷方格被打开即为游戏胜利。在每次打开方格函数中都遍历一遍矩阵，当找到有未打开的非雷方格时则退出遍历，遍历完所有方格均未找到未打开的非雷方格时则游戏胜利。 //方块点击事件 _i：坐标i _j:坐标j e:鼠标事件 function block_click(_i, _j, e) { //跳过已打开的方块 if (grid[_i][_j].isOpen) { //... } //鼠标左键打开方块 if (e.button === 0) { //... } //鼠标右键标记方块 else if (e.button === 2) { //... } //遍历矩阵 let isWin = true; for (let i = 0; i \u003c row; i++) { for (let j = 0; j \u003c col; j++) { let block = grid[i][j]; //如果有未打开的非雷方块 if (!block.isMine \u0026\u0026 !block.isOpen) { isWin = false; } } } if (isWin) { alert(\"游戏胜利\"); } } 游戏逻辑部分到这里就结束了，剩余雷数和计时可用全局变量实现。 附：源码地址 参阅资料 原生 JS 实现扫雷 (分析+代码实现) ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:6","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"ECMAScript 6(以下简称 ES6)是 JavaScript 语言的下一代标准,已经在 2015 年 6 月正式发布了。Mozilla 公司将在这个标准的基础上,推出 JavaScript 2.0。ECMAScript 和 JavaScript 是什么关系？简单来说，ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:0:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"let 和 const var 函数作用域 function scope,不在函数内时作用域是全局的 用 let 和 const 声明变量, let, const 块级作用域 block scope,作用域是{}内 eg.执行以下语句判断区别： for (var i = 0; i \u003c 10; i++) { console.log(i); setTimeout(function () { console.log(`i:${i}`); }, 1000); } for (let i = 0; i \u003c 10; i++) { console.log(i); setTimeout(function () { console.log(`i:${i}`); }, 1000); } let, const 不能重复声明变量值 let 声明的变量是可以重新赋值的, const 声明的变量只能修改引用类型的属性值 变量提升：let, count 有变量提升,未声明先使用存在临时性死区(Temporal dead zone),详见 mdn ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:1:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"箭头函数 特点：简明的语法,隐式返回(省去 return 关键字),匿名函数 this:普通函数 this 是动态绑定的 const Jelly = { name: \"Jelly\", hobbies: [\"Coding\", \"Sleeping\", \"Reading\"], printHobbies: function () { // console.log(this); this.hobbies.map(function (hobby) { // console.log(this); console.log(`${this.name}loves ${hobby}`); }); }, }; Jelly.printHobbies(); map 中的回调函数是一个独立的函数,不作为对象的方法,并且没有通过 call bind apply 来改变里面的 this，this 指向 window,严格模式下指向 undefined const Jelly = { name: \"Jelly\", hobbies: [\"Coding\", \"Sleeping\", \"Reading\"], printHobbies: function () { // console.log(this); var self = this; this.hobbies.map(function (hobby) { // console.log(this); console.log(`${self.name}loves ${hobby}`); }); }, }; Jelly.printHobbies(); 箭头函数的 this 值继承父作用域,是词法作用域,定义的时候就指向明确,且不会绑定 this： const Jelly = { name: \"Jelly\", hobbies: [\"Coding\", \"Sleeping\", \"Reading\"], printHobbies: function () { // console.log(this); this.hobbies.map((hobby) =\u003e { // console.log(this); console.log(`${this.name}loves ${hobby}`); }); }, }; Jelly.printHobbies(); 命名函数在递归,事件绑定时有用,在箭头函数中使用： const greet = (name) =\u003e { alert(`Hello ${name}`); }; 箭头函数不适用的情况： 需要使用 this 慎用 需要使用 arguments(箭头函数没有 arguments) ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:2:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"模板字符串 模板字符串中的换行和空格都是会被保留的。 模板字符串可嵌套,支持三元表达式。 标签模板字符串,是一个函数的调用。 alert`Hello world!`; // 等价于alert('Hello world!'); ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:3:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"解构赋值 针对数组或者对象进行模式匹配,然后对其中的变量进行赋值。 是对赋值运算符的扩展,方便提取对象属性值,可嵌套可忽略。 let [a, b, c, d, e] = \"hello\"; let obj = { p: [\"hello\", { y: \"world\" }] }; let { p: [x, { y }], } = obj; // x = 'hello' // y = 'world' let obj = { p: [\"hello\", { y: \"world\" }] }; let { p: [x, {}], } = obj; // x = 'hello' ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:4:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"计算属性 对象字面定义属性名位置的 [ ] 中可以放置任意合法表达式。 const keys = [\"name\", \"age\", \"birthday\"]; const values = [\"jelly\", 18, \"2016-01\"]; const Laravist = { [keys.shift()]: values.shift(), [keys.shift()]: values.shift(), [keys.shift()]: values.shift(), }; console.log(Laravist); ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:5:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Symbol ES6 引入了一种新的原始数据类型表示独一无二的值,最大的用法是用来定义对象的唯一属性名。 用于生成唯一标识符避免命名冲突,可作为私有属性在对象内部使用,不能 for 循环遍历 const classRoom = { [Symbol(\"lily\")]: { grade: 60, gender: \"female\" }, [Symbol(\"nina\")]: { grade: 70, gender: \"female\" }, [Symbol(\"nina\")]: { grade: 90, gender: \"female\" }, }; const syms = Object.getOwnPropertySymbols(classRoom).map( (sym) =\u003e classRoom[sym] ); console.log(syms); ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:6:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"剩余参数 const player = [\"jelly\", 123, 2.4, 3.6, 1.7]; const [name, id, ...scores] = player; console.log(name, id, scores); 扩展运算符可以将可遍历对象元素扩展成新的参数序列,而不用改变原来的对象 const younger = [\"aaa\", \"bbb\", \"ccc\"]; const older = [\"xxx\", \"yyy\", \"zzz\"]; const members = [...younger, \"ddd\", ...older]; const newmembers = members; ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:7:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Promise Promise 用于避免回调地狱 const p = new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { reject(Error(\"Laravist isn't awesome!\")); }, 2000); }); p.then((data) =\u003e { console.log(data); }).catch((err) =\u003e { console.error(err); }); await 操作符用于等待一个 Promise 对象,它只能在异步函数 async function 内部使用。 await 针对所跟不同表达式的处理方式： Promise 对象：await 会暂停执行,等待 Promise 对象 resolve,然后恢复 async 函数的执行并返回解析值。 非 Promise 对象：直接返回对应的值。 function testAwait(x) { return new Promise((resolve) =\u003e { setTimeout(() =\u003e { resolve(x); }, 2000); }); } async function helloAsync() { var x = await testAwait(\"hello world\"); console.log(x); } helloAsync(); ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:8:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Class class 是语法糖,本质是 funciton,没有变量提升 一个继承的例子: function MyArray() { Array.apply(this, arguments); } const colors = new MyArray(); colors[0] = \"red\"; console.log(colors.length); //undefined colors.length = 0; console.log(colors[0]); //red ES5 是先新建子类的实例对象 this, 再将父类的属性添加到子类上,原生构造函数会忽略 apply 方法传入的 this, 父类的内部属性无法获取,导致无法继承原生的构造函数。 class MyArray extends Array { constructor() { super(); console.log(this); } } const colors = new MyArray(); colors[0] = \"red\"; console.log(colors.length); // 1 colors.length = 0; console.log(colors[0]); // undefined ES6 允许继承原生构造函数定义的子类,因为 ES6 是先新建父类的实例对象 this, 然后再用子类的构造函数修饰 this,使得父类的素有行为都可以继承。 ES6 可以自定义原生数据结构的子类，这是 ES5 无法做到的。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:9:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"一些补充 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"新增 for…of 循环： 先回顾 js 中 for 循环的几种写法 const fruits = [\"apple\", \"banana\", \"orange\", \"mango\"]; for (let i = 0; i \u003c fruits.length; i++) { console.log(fruits[i]); } 可读性不是很好 fruits.forEach((fruit) =\u003e { console.log(fruit); }); 不能在循环中 break 或 continue for (let index in fruits) { console.log(fruits[index]); } 会遍历对象上所有可枚举属性 for (let fruit of fruits) { console.log(fruit); } 不会遍历数组中非数字属性,能够 break 或 continue 应用数组解构语法 for (let [index, fruit] of fruits.entries()) { console.log(`${fruit}rank in ${index + 1}in my favorite fruits`); } for…of 可以应用于可迭代对象(部署了 iterator 接口或提供 Symbol.iterator 方法的数据结构) 数组,字符串,arguments,NodeList,map.set 等,但不支持对象 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:1","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Array.from()和 Array.of() es6 新增数组方法 Array.from()和 Array.of()： 注意是数组原型对象上的静态方法 Array.from()用于把可迭代对象转化成数组,Array.of()传入参数生成数组 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:2","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Proxy 与 Reflect Proxy 与 Reflect 是 ES6 为了操作对象引入的 API 。 Proxy 可以对目标对象的读取、函数调用等操作进行拦截,然后进行操作处理。它不直接操作对象,而是像代理模式,通过对象的代理对象进行操作。 ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:3","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"迭代器与生成器 Iterator 是 ES6 引入的一种新的遍历机制,通过一个键为 Symbol.iterator 的方法来实现。 Generator 函数:在 function 后面,函数名之前有个*,函数内部有 yield 表达式。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:4","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Map 与 Set Object 的键只能是字符串或者 Symbols, Map 的键可以是任意值,Map 中的键值是有序的(FIFO 原则),Map 的键值对个数可以从 size 属性获取。 Set 对象允许你存储任何类型的唯一值,NaN 与 NaN 是不恒等的,但是在 Set 中只能存一个。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:5","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"闭包的核心作用闭包的核心作用 \" 闭包的核心作用 闭包就是能够读取其他函数内部变量的函数。在 javascript 中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成\"定义在一个函数内部的函数\"。闭包是将函数内部和函数外部连接起来的桥梁，实现了变量的私有化问题。 有如下例子，我们想要用一个 counter 记录 add 函数的执行次数。 function add() { var counter = 0; //局部变量 counter++; console.log(\"counter = \" + counter); } add(); // counter = 1 add(); // counter = 1 由于 counter 是局部变量，每次我们执行 add()函数，都是输出 counter = 1; 我们想要执行函数时改变 counter 的值，一种可行的办法是： var counter = 0; //全局变量，谁都可以访问，修改 function add() { counter++; console.log(\"counter = \" + counter); } add(); // counter = 1 add(); // counter = 2 但是这样会带来问题，由于 counter 是全局变量，我们可能会在函数外不小心改变了 counter 的值， 比如在函数外写了一句 counter = -100；就打乱了我们原来的计数，显然我们并不希望在函数外任意地改变 counter 的值。 我们可以这样写： function add() { var counter = 1; //局部变量 console.log(\"counter = \" + counter); plus = function () { //全局函数 counter++; console.log(\"counter = \" + counter); }; } add(); //counter = 1 counter初始化 plus(); //counter = 2 这样我们就无法在函数外任意改变 counter 了，进一步的写法是： function add() { var counter = 1; //局部变量 console.log(\"counter = \" + counter); var plus = function () { //局部函数 counter++; console.log(\"counter = \" + counter); }; return plus; } var plus1 = add(); // counter = 1 plus1(); // counter = 2 plus 函数名有些多余，add 可以简化为立即执行函数。 var plus1 = (function add() { var counter = 0; //局部变量 return function () { //全局函数 counter++; console.log(\"counter = \" + counter); }; })(); plus1(); // counter = 1 plus1(); // counter = 2 发现 add 函数名也可以去掉了，简化为匿名函数，如下就是闭包的一般写法： var plus1 = (function () { var counter = 0; //局部变量 return function () { counter++; console.log(\"counter = \" + counter); }; })(); plus1(); // counter = 1 plus1(); // counter = 2 闭包实现了变量私有化，局部变量的本质，全局变量的生命周期。闭包本质是利用作用域链，即当前环境中存在指向父级作用域的引用。 ","date":"2019-10-07","objectID":"/2019-10-17-js-basis/:0:0","tags":["JavaScript"],"title":"JS 闭包写法的演变过程","uri":"/2019-10-17-js-basis/"},{"categories":null,"content":"关于网站 个人博客，记录所学所思。 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于版权 本站所有原创文章均受 创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0 保护。 任何个人及媒体在转载本站原创内容 (包含文字、图像、摄影作品等) 时请遵守以下版权要求： 注明转载； 注明来源为本站首页网址，或所转内容在本站的完整网址。 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"}]