[{"categories":["Thinking"],"content":"如果你没有听说过 λ 演算，可以阅读我的这篇文章。如果你没有编译原理相关知识，可以阅读我的这篇文章。首先介绍调度场算法，后面的实现中会用到。 ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:0:0","tags":["AST","lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Thinking"],"content":"调度场算法 调度场算法是一种将中缀表达式转换为后缀表达式的经典算法，由 Dijkstra 提出，因其操作类似于火车调车场而得名。为什么要转换，为了处理运算符的优先级： \r之后，程序处理后缀表达式 output 就像玩消消乐。 ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:1:0","tags":["AST","lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Thinking"],"content":"处理括号 首先后缀表达式里没有括号，所以括号不应该被输出。由于括号里一定是一个完整的表达式，可以这样修改算法。把左括号的优先级当作最低，这样括号就不会立即出栈： 1.依次按顺序读入， 读到数字：直接输出； 读到一般运算符：如果栈顶的运算符优先级不低于该运算符，则输出栈顶运算符并使之出栈，直到栈空或不满足上述条件为止；然后入栈； 读到左括号：直接入栈； 读到右括号：输出栈顶运算符并使之出栈，直到栈顶为左括号为止；令左括号出栈。 2.当读入完毕时，依次输出并弹出栈顶运算符，直到栈被清空。 这样处理后，就能让括号内的运算符优先级最高。 除括号外，在 λ 演算有语义的运算符只有 . 和函数与参数之间的空格。. 用于区分函数变量和函数体，空格表示将参数作用于函数。它们都是中缀表达式，我们用调度场算法把它们转换为后缀表达式。 ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:1:1","tags":["AST","lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Thinking"],"content":"词法分析 对任意的 λ 演算表达式，只保留函数间的空格。 /** remove any space that isn't in one of the following spots:\r)_(, x_(, )_x, x_x, x_\\, )_\\ */\rfunction remove_extra_spaces(str) {\rreturn str.trim()\r.replace(/\\s+([^\\(\\wλ])/g, '$1')\r.replace(/([^\\)\\w])\\s+/g, '$1');\r}\r// all spaces are lambda application =\u003e whitespace matters\rfunction lex(str) {\rlet tokens = remove_extra_spaces(str)\r.split(/(\\)|\\(|λ|\\.|\\w+|\\s+)/)\r.filter(t =\u003e t != '');\rreturn tokens;\r}\r lex(' ( λ a. λ b. a ) a b ')\r// [\"(\", \"λ\", \"a\", \".\", \"λ\", \"b\", \".\", \"a\", \")\", \" \", \"a\", \" \", \"b\"]\r ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:2:0","tags":["AST","lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Thinking"],"content":"语法分析 按照调度场算法处理运算符，空格的优先级高于 .，因为函数的参数是函数。设计如下递归下降解析器： // shunting yard algorithm\rfunction parse(tokens) {\rlet output = [];\rlet stack = [];\rwhile(tokens.length \u003e 0) {\rlet current = tokens.shift();\rif(current.match(/\\w+/)) {\routput.push(new Var(current));\r}\relse if(current.match(/\\s+/)) { // swap if both o1 and o2 are application\r stack_to_output(stack, output, () =\u003e stack[stack.length-1].match(/\\s+/));\rstack.push(current);\r}\relse if(current == \"(\" || current == '.') {\rstack.push(current);\r}\relse if(current == \")\") {\rstack_to_output(stack, output, () =\u003e stack[stack.length-1] != '(');\rif(stack.length == 0) {\rconsole.log(\"mismatched parenthesis\");\r}\rstack.pop(); // pop off left paren\r }\r}\rif(stack.indexOf('(') != -1 || stack.indexOf(')') != -1) {\rconsole.log(\"mismatched parenthesis\");\r} else {\rstack_to_output(stack, output, () =\u003e true);\r}\rreturn output.pop();\r}\r 加入运算符到后缀表达式 output function stack_to_output(stack, output, condition) {\rwhile(stack.length \u003e 0 \u0026\u0026 condition()) {\rlet top = stack.pop();\rlet s = output.pop();\rlet f = output.pop();\routput.push(top == '.' ? new Abs(f, s) : new App(f, s));\r}\r}\r 这里用到了 AST 节点，给出定义： function Var(id) {\rthis.type = 'var';\rthis.id = id;\rthis.free_vars = new Set([id]);\r}\rfunction App(func, arg) {\rthis.type = 'app';\rthis.func = func;\rthis.arg = arg;\rthis.free_vars = new Set([...func.free_vars, ...arg.free_vars]);\r}\rfunction Abs(v, expr) {\rthis.type = 'abs';\rthis.var = v;\rthis.expr = expr;\rthis.free_vars = new Set([...expr.free_vars]);\rthis.free_vars.delete(this.var.id);\r}\r 只有 abs 类型里的参数 var 是约束变量，例如 (λa.b) 生成的 AST 如下 Abs {\rtype: 'abs',\rvar: Var { type: 'var', id: 'a', free_vars: Set(1) { 'a' } },\rexpr: Var { type: 'var', id: 'b', free_vars: Set(1) { 'b' } },\rfree_vars: Set(1) { 'b' }\r}\r (λa.b) c 生成的 AST 如下 App {\rtype: 'app',\rfunc: Abs {\rtype: 'abs',\rvar: Var { type: 'var', id: 'a', free_vars: [Set] },\rexpr: Var { type: 'var', id: 'b', free_vars: [Set] },\rfree_vars: Set(1) { 'b' }\r},\rarg: Var { type: 'var', id: 'c', free_vars: Set(1) { 'c' } },\rfree_vars: Set(2) { 'b', 'c' }\r}\r ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:3:0","tags":["AST","lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Thinking"],"content":"实现解释器 在每个 AST 节点上封装一个 stepped 布尔值，表示对应的表达式是否能够 β 规约。只有在调用函数时，才能进行 β 规约，替换掉函数里的约束变量。代码的实现思路是观察 AST 的结构，例如 (λa.b) c 能够被替换的是 (λa.b)，对应的 AST 结构是 app 里的 abs var redexes = 0;\rfunction stepper(node) {\rswitch (node.type) {\rcase 'var': return { stepped: false, node: node };\rcase 'app':\rswitch(node.func.type) {\rcase 'var':\rcase 'app':\rlet func_evaled = stepper(node.func);\rif (func_evaled.stepped) {\rreturn {stepped: true, node: new App(func_evaled.node, node.arg)};\r}\rlet arg_evaled = stepper(node.arg);\rreturn {stepped: arg_evaled.stepped, node: new App(node.func, arg_evaled.node)};\rcase 'abs': // redex\r redexes++;\rreturn {stepped: true, node: substitute(node.arg, node.func.var, node.func.expr)};\r}\rbreak;\rcase 'abs':\rlet new_expr = stepper(node.expr);\rreturn { stepped : new_expr.stepped, node : new Abs(node.var, new_expr.node) };\r}\r}\r 实现替换函数 substitute，代码的实现思路同样是观察 AST 的结构 // substitute e for x (variable) in expr\rfunction substitute(e, x, expr) {\rswitch (expr.type) {\rcase 'var': return expr.id == x.id ? e : expr;\rcase 'app': return new App(substitute(e, x, expr.func), substitute(e, x, expr.arg));\rcase 'abs':\rif(expr.var.id == x.id) {\rreturn expr;\r}\relse if(!e.free_vars.has(expr.var.id)) {\rreturn new Abs(expr.var, substitute(e, x, expr.expr));\r}\relse {\rdo {\rvar z = rename(expr.var.id);\r} while(e.free_vars.has(z) || variables(expr.expr).has(z));\rreturn new Abs(new Var(z), substitute(e, x, substitute(new Var(z), expr.var, expr.expr)));\r}\r}\r}\r 进行 β 规约时，约束变量的名字可能重复，这就需要使用 α 变换重命名约束变量 function rename(variable) {\rlet [match, prefix, num] = /^(.*?)([\\d]*)$/.exec(variable);\rreturn prefix + (num == '' ? 1 : parseInt(num) + 1);\r}\rfunction variables(expr) {\rswitch (expr.type) {\rcase 'var': return new Set([expr.id]);\rcase 'app': return new Set([...variables(expr.func), ...variables(expr.arg)]);\rcase 'abs': return new Set([...variables(expr.expr), expr.var.id]);\r}\r}\r 最后实现一个由 AST 节点重新生成 λ 演算表达式的函数 // unnecessary parenthesises uses in some abstractions\rfunction ast_to_expr(expr) {\rswitch (expr.type) {\rcase 'var': return expr.id;\rcase 'abs': return `(λ${expr.var.id}.${ast_to_expr(expr.expr)})`;\rcase 'app':\rreturn ast_to_expr(expr.func) + ' ' + (expr.arg.type == 'app' ? '('+ast_to_expr(expr.arg)+')' : ast_to_expr(expr.arg));\r}\r}\r 现在可以自顶向下的解释 λ 演算表达式的计算规则了 let expr = '(λn. (λf. (λx. (f ((n f) x))))) (λf. (λx. x))';\rfunction run(expr) {\rlet t = new Date().getTime();\rlet ast = parse(lex(expr));\rlet new_expr = stepper(ast);\rwhile(new_expr.stepped) {\rconsole.log(redexes + ': ' + ast_to_expr(new_expr.node));\rnew_expr = stepper(new_expr.node);\r}\rlet delay = new Date().getTime() - t;\rconsole.log('delay: ' + delay);\rconsole.log('redexes: ' + redexes);\rconsole.log('final: ' + ast_to_expr(new_expr.node));\r}\rrun(expr);\r expr 中第一个表达式是数字的后继函数，第二个表达式是数字 0 1: (λf.(λx.f ((λf.(λx.x)) f x)))\r2: (λf.(λx.f ((λx.x) x)))\r3: (λf.(λx.f x))\rdelay: 10\rredexes: 3\rfinal: (λf.(λx.f x))\r 可以看到经过 3 次计算后，最终的表达式是数字 1，我们实现了 λ 演算解释器！ 附：源码地址 参考资料 算法学习笔记: 调度场算法 parkertimmins/lambda_interpreter ","date":"2020-12-13","objectID":"/2020-12-13-%CE%BB-interpreter/:4:0","tags":["AST","lambda"],"title":"实现 λ 演算解释器","uri":"/2020-12-13-%CE%BB-interpreter/"},{"categories":["Thinking"],"content":"程序的解释和编译通常需要经过词法分析，语法分析和生成抽象语法树等阶段。 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:0:0","tags":["Theories","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"前置知识 算术表达式根据运算符所在的位置可以分为三种表示方法： 前缀表达式(波兰式)，如 (- (+ 3 (* 2 4)) 1)，Lisp 语言就是使用这种表示方法 中缀表达式，如 3 + 2 * 4 - 1，最适合人阅读的表示方法 后缀表达式(逆波兰式)，如 3 2 4 * + 1 -，计算机处理起来比较方便 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:1:0","tags":["Theories","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"编译原理 为了讲清楚程序解释与编译，我们自定义一种类似 Lisp 的前缀表达式： mul 3 sub 2 sum 1 3 4\r ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:0","tags":["Theories","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"语法和语义 为了完整地定义编程语言，我们需要： 语法(Syntax)，就是程序看起来的样子(我们已经定义了)。 语义(semantics，描述程序的含义。一些编程语言有官方的书面规范。而另一些只有一个可用的解释器或者编译器，它们的语义是 “靠实现规范” 的。 我们用 JS 代码来规范前缀表达式的语义： const OpMapper = {\rsum: args =\u003e args.reduce((a, b) =\u003e a + b, 0),\rsub: args =\u003e args.reduce((a, b) =\u003e a - b),\rdiv: args =\u003e args.reduce((a, b) =\u003e a / b),\rmul: args =\u003e args.reduce((a, b) =\u003e a * b, 1)\r};\r 按照我们规范的语义，前缀表达式等价为如下 JS 代码： mul(3, sub(2, sum(1, 3, 4)))\r// or 3 * (2 - (1 + 3 + 4))\r ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:1","tags":["Theories","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"词法分析 词法分析将源代码中每一个有语义的字符(token)提取出来，用数组表示。 const lex = str =\u003e str.split(' ').map(s =\u003e s.trim()).filter(s =\u003e s.length);\rconst tokens = lex('mul 3 sub 2 sum 1 3 4')\r// tokens = [\"mul\", \"3\", \"sub\", \"2\", \"sum\", \"1\", \"3\", \"4\"]\r ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:2","tags":["Theories","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"语法分析 - 语法描述 用 EBNF 来描述我们的程序语法： digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\rnum = digit+\rop = sum | sub | mul | div\rexpr = num | op expr+\r - 抽象语法树 确定了语法后，一开始定义的前缀表达式可以表示为如下程序树(AST)： \r尝试用 JS 代码解析这种逻辑： const Op = Symbol('op');\rconst Num = Symbol('num');\rconst parse = tokens =\u003e {\rlet c = 0;\rconst peek = () =\u003e tokens[c];\rconst consume = () =\u003e tokens[c++];\rconst parseNum = () =\u003e ({ val: parseInt(consume()), type: Num });\rconst parseOp = () =\u003e {\rconst node = { val: consume(), type: Op, expr: [] };\rwhile (peek()) node.expr.push(parseExpr());\rreturn node;\r};\rconst parseExpr = () =\u003e /\\d/.test(peek()) ? parseNum() : parseOp();\rreturn parseExpr();\r};\r 程序树中每个节点都被表示为了 JS 对象，我们完成了程序的解析！ 实际上，我们开发了一个简单的递归下降解析器。每个对象的值其实是它的 val 属性，可以通过分治法自顶向下地对整个前缀表达式进行求值。 const evaluate = ast =\u003e {\rif (ast.type === Num) {\rreturn ast.val;\r} else {\r// Op needs parameters to be evaluated\r return OpMapper[ast.val](ast.expr.map(evaluate));\r}\r};\rconst value = evaluate(parse(tokens));\rconsole.log(value);\r// -18\r ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:3","tags":["Theories","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"解释和编译 将程序转换为 AST，然后直接对 AST 求值就是程序的解释(Interpreted)，还有一种求值方式是由 AST 生成中间代码，再由别的解释器或编译器对中间代码求值，就是程序的编译(Compiled)。通过 AST 完成代码转换非常方便，只需设计转换前后的映射表，代码转换就是查表替换。 const compile = ast =\u003e {\rconst opMap = { sum: '+', mul: '*', sub: '-', div: '/' };\rconst compileNum = ast =\u003e ast.val;\rconst compileOp = ast =\u003e `(${ast.expr.map(compile).join(' ' + opMap[ast.val] + ' ')})`;\rconst compile = ast =\u003e ast.type === Num ? compileNum(ast) : compileOp(ast);\rreturn compile(ast);\r};\rconst newCode = compile(parse(tokens)); console.log(newCode);\r// (3 * (2 - (1 + 3 + 4)))\r 这里生成的中间代码就可以被直接被低级一些的语言解释或编译。 参考资料 Implementing a Simple Compiler on 25 Lines of JavaScript 解谜计算机科学 ","date":"2020-12-10","objectID":"/2020-12-10-lex-parse/:2:4","tags":["Theories","AST"],"title":"程序解释与编译","uri":"/2020-12-10-lex-parse/"},{"categories":["Thinking"],"content":"由邱奇 (Alonzo Church) 创造的 λ 演算(λ-calculus) 是世界上最小的程序设计语言。虽然没有数(number)，字符串(string)，布尔型(boolean) 或其他任何非函数(non-function) 的数据类型，但 λ 演算只用匿名单参函数就能模拟图灵机(图灵完备)。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:0:0","tags":["Theories","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"λ 演算 λ 演算仅由 3 种元素组成：变量、函数 和 应用 \r最基本的函数是恒等函数：$ λx.x $，等同于 $ f(x) = x $，第一个 x 是函数参数，第二个是函数体。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:0","tags":["Theories","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"变量 λ 演算中的变量分为自由变量和约束变量： 在函数 $ λx.x $ 中 x 被称为约束变量，x 被称为约束变量，因为它既在函数体中又是形参。 在 $ λx.y $ 中 y 被称为自由变量，因为它没有被预先声明。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:1","tags":["Theories","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"求值 求值通过 β规约(β-Reduction) 完成，它将替换作用于应用，简单理解就是函数调用。例如对表达式 $ (λx.x)a $ 求值时，我们把函数体中所有的 x 都替换为 a： $ (λx.x) \\ a = a $ $ (λx.y) \\ a = y $ 你可以这样表示高阶函数： $ (λx.λy.x) \\ a = λy.a $ 为了简化表示，λx.λy. 与 λxy. 等价： $ (λxy.x) \\ a = λy.a $ 图灵机的逻辑操作实际上是二进制的 0 1 比较，而 λ 演算中连数字都没有，怎么定义程序逻辑？既然没有数，那就用 λ 函数来表示数！ ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:2","tags":["Theories","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"Church 编码 邱奇数 邱奇数 是用 λ 函数表示的自然数。某个程序过程(函数) f 和它的执行次数 n，存在对应关系： $ 0 = λf.λx.x $ $1 = λf.λx.f x$ $ 2 = λf.λx.f (f x) $ $ 3 = λf.λx.f ( f (f x)) $ … 于是， $ n = λf.λx.f^nx $ 由 β规约得出：$ n \\ f \\ x = (λf.λx.f^nx) \\ f \\ x = f^nx $ 由恒等式 $ f^{m+n}x = f^m(f^nx) $ 推出加法定义： $ plus = λm.λn.λf.λx.m \\ f \\ (n \\ f \\ x) $ 由恒等式 $ f^{m*n}x = (f^n)^mx $ 推出乘法定义： $ mult = λm.λn.λf.m (n \\ f) $ 其他的运算都能用类似的方法推出。 布尔逻辑 布尔逻辑可被看做一种选择，ture 和 false 可以被编码为有两个参数的函数： ture — 选择第一个参数 $ true = λa.λb.a $ false — 选择第二个参数 $ false = λa.λb.b $ 布尔函数本身是条件分支，那 if-else 语句就成语法糖了。因为判定条件最终是布尔函数，直接能将 if-else 的条件分支作为布尔函数的参数(if-else 语句有三个参数，第一个是判定条件)： $ ifelse = λp.λt.λf. p \\ t \\ f $ (p = true or p = false) 接着定义与、或、非的逻辑运算符： $ and = λp.λq. p \\ q \\ p $ $ or = λp.λq. p \\ p \\ q $ $ not = λp. p \\ false \\ true $ 若要图灵完备，必然能实现无限递归。而 λ 演算中只有匿名单参函数，也就是没有提前的函数声明，这能实现无限递归？真的能！ ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:3","tags":["Theories","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"不动点组合子 不动点 函数 $ f $ 的不动点指的是将函数应用在输入值 x 时，会传回与输入值相同的值，使得 $ f(x) = x $。例如，0 和 1 是函数 $ f(x) = x^2 $ 的不动点。现在，假设有某个函数 Y 和任意函数 g，满足： Y g = g (Y g) 就是说将 g 作为 Y 的参数时，得到的新函数 Y g 是 g 的不动点。那神奇的事情就发生了： Y g = g (Y g) = g (g (Y g)) = g (…g (Y g)…) 一旦调用 Y g 就会产生新的 g，任意函数 g 的无限递归不就产生了吗？Amazing！ Y combinator 数学家 Haskell Curry 发现了这个 Y 的存在： $ Y := λf.(λx.f(x \\ x))(λx.f(x \\ x)) $ 证明过程： \r例如我们用匿名函数表达求阶乘时，我们暂称它为 g，实际的 g 和 Y 没有名字， g = λf. λx. (iszero x) 1 (mult x (f (pred x))) 当调用 Y g 时，得到 g(Y g)，由 β规约得出： g(Y g) = λx. (iszero x) 1 (mult x ((Y g) (pred x))) 于是，Y g 就成为了递归函数： Y g = λx. (iszero x) 1 (mult x ((Y g) (pred x))) Y 能够组合一个匿名函数成为递归函数，因此被称为 Y combinator(Y组合子)。由于 lambda 表达式是惰性求值，而很多编程语言例如 JS 中使用严格求值，因此 Y组合子在 JS 中这样表示： let Y = f =\u003e (x =\u003e f(y =\u003e x(x)(y)))(x =\u003e f(y =\u003e x(x)(y)));\r Church 编码和不动点组合子表明了程序不用其他原始数据类型就能模拟图灵机。 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:1:4","tags":["Theories","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"实践 代码实践参考了计算的本质一书，原文是 Ruby 代码，我把它翻译为 JS 代码了： const Y = f =\u003e (x =\u003e f(y =\u003e x(x)(y)))(x =\u003e f(y =\u003e x(x)(y)));\rconst F = a =\u003e b =\u003e b;\rconst T = a =\u003e b =\u003e a;\rconst zero = f =\u003e x =\u003e x;\rconst one = f =\u003e x =\u003e f(x);\rconst two = f =\u003e x =\u003e f(f(x));\rconst three = f =\u003e x =\u003e f(f(f(x)));\rconst four = f =\u003e x =\u003e f(f(f(f(x))));\rconst five = f =\u003e x =\u003e f(f(f(f(f(x)))));\rconst pair = x =\u003e y =\u003e z =\u003e z(x)(y);\rconst left = p =\u003e p(x =\u003e y =\u003e x);\rconst right = p =\u003ep(x =\u003e y =\u003e y);\rconst empty = pair(T)(T);\rconst ushift = l =\u003e x =\u003e pair(F)(pair(x)(l));\rconst is_empty = left;\rconst first = l =\u003e left(right(l));\rconst rest = l =\u003e right(right(l));\rconst if_else = b =\u003e b;\rconst is_zero = f =\u003e f(x =\u003e F)(T);\rconst is_less_or_equal = m =\u003e n =\u003e is_zero(minus(m)(n));\rconst succ = n =\u003e f =\u003e x =\u003e f(n(f)(x));\rconst slide = p =\u003e pair(right(p))(succ(right(p)));\rconst pred = n =\u003e left(n(slide)(pair(zero)(zero)));\rconst plus = m =\u003e n =\u003e n(succ)(m);\rconst minus = m =\u003e n =\u003e n(pred)(m);\rconst mult = m =\u003e n =\u003e n(plus(m))(zero);\rconst div = Y(f =\u003e m =\u003e n =\u003e\rif_else(is_less_or_equal(n)(m))\r(x=\u003esucc(f(minus(m)(n))(n))(x))\r(zero)\r);\rconst a = two;\rconst b = succ(a);\rconst aa = ushift(ushift(empty)(a))(a);\rconst ab = ushift(ushift(empty)(b))(a);\rconst abaa = ushift(ushift(aa)(b))(a);\rconst to_boolean = p =\u003e if_else(p)('T')('F');\rconst to_char = c =\u003e if_else(is_zero(c))('0')(\rif_else(is_zero(pred(c)))('1')(\rif_else(is_zero(two(pred)(c)))('a')('b')\r)\r);\rconst fold = Y(f =\u003e l =\u003e x =\u003e g =\u003e if_else(is_empty(l))\r(x)\r(y=\u003eg(f(rest(l))(x)(g))(first(l))(y))\r);\rconst pushs = l =\u003e x =\u003e fold(l)(ushift(empty)(x))(ushift);\rconst to_digits = Y(f =\u003e n =\u003e pushs(\rif_else(is_less_or_equal(n)(pred(two)))\r(empty)\r(x =\u003e f(div(n)(two))(x))\r)(mod(n)(two))\r)\rconst mod = Y(f =\u003e m =\u003e n =\u003e if_else(is_less_or_equal(n)(m))\r(x =\u003e f(minus(m)(n))(n)(x))\r(m)\r);\rconst range = Y(f =\u003e m =\u003e n =\u003e if_else(is_less_or_equal(m)(n))\r(x =\u003e ushift(f(succ(m))(n))(m)(x))\r(empty)\r);\rconst maps = k =\u003e f =\u003e fold(k)(empty)(l =\u003e x =\u003e ushift(l)(f(x)));\rconst twenty = mult(four)(five);\rconst my_list = maps(range(one)(twenty))(n =\u003e if_else(is_zero(mod(n)(succ(five))))(abaa)(\rif_else(is_zero(mod(n)(three)))(aa)(\rif_else(is_zero(mod(n)(two)))(ab)(to_digits(n))\r)\r) );\r// The above code only uses functions to compconste all calculations, // and the calculation result is a single-character linked list\r\r// But the above code does not encode the characters related to the output format, // so use an array to store the result to change the output format\r\rconst to_array = proc =\u003e {\rconst arr = [];\rwhile(to_boolean(is_empty(proc))!='T'){\rarr.push(first(proc));\rproc = rest(proc);\r}\rreturn arr;\r}\rconst to_string = s =\u003e to_array(s).map(c =\u003e to_char(c)).join('');\rconsole.log(to_array(my_list).map(v=\u003eto_string(v)));\r// If you don’t use arrays, you can also use functions to simulate\r\rconst fact = Y(f =\u003e n =\u003e is_zero(n)(one)(\rx =\u003e mult(n)(f(pred(n)))(x)\r));\rconst arr = s =\u003e to_char(first(s));\rconst s1 = to_digits(fact(four));\rconst s2 = rest(s1);\rconst s3 = rest(s2);\rconst s4 = rest(s3);\rconst s5 = rest(s4);\r// console.log(arr(s1) + arr(s2) + arr(s3) + arr(s4) + arr(s5));\r 附：源码地址 参考资料 康托尔、哥德尔、图灵——永恒的金色对角线 Church encoding Learn Lambda Calculus in Y minutes Lambda演算系列 ","date":"2020-11-26","objectID":"/2020-11-26-%CE%BB-calculus/:2:0","tags":["Theories","Lambda"],"title":"λ 演算: 程序从无到有","uri":"/2020-11-26-%CE%BB-calculus/"},{"categories":["Thinking"],"content":"图灵机是英国数学家图灵于 1936 年提出的一种将人的计算行为抽象化的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终极强大逻辑机器。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:0:0","tags":["Theories"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Thinking"],"content":"基本思想 图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作： 在纸上写上或擦除某个符号； 把注意力从纸的一个位置移动到另一个位置； 而在每个阶段，人要决定下一步的动作，依赖于此人当前所关注的纸上某个位置的符号和此人当前思维的状态。为了模拟人的这种运算过程，图灵构造出一台假想机器，该机器由以下几个部分组成： \r 一条无限长的纸带，纸带由很多个格子构成，用于输入输出信息。每个格子中包含一个来自有限字母表的符号，字母表中有一个特殊符号表示空白。纸带上一端的格子从0开始编号，另一端无限延伸一直到无穷大 一个读写头，用于读写纸带 一个状态寄存器，用于保存机器状态。图灵机的状态个数有限，并且有一个特殊的状态：停机状态 一套控制规则，根据当前机器状态和纸带内容来确定下一步的动作： 写入或擦除当前格子内容 移动读写头，向左、向右、或不动 保持当前状态或转移到另一状态 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:1:0","tags":["Theories"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Thinking"],"content":"图灵完备 只要能模拟单带图灵机，就是图灵完备的(递归可枚举)。这意味着其计算能力与通用图灵机等同。不是图灵完备的情况: 递归或循环有限，无法写不终止的程序(如 while(true){}) 无法实现类似数组或列表这样的数据结构(不能模拟纸带) 但图灵完备也有可能带来坏处，有些场景我们需要限制语言的表达能力，通过限制无限循环却保程序一定是可终止的。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:2:0","tags":["Theories"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Thinking"],"content":"极简实现 Brainfuck 是一种极小化的图灵完备的程序语言，它仅由八种运算符构成。 它的工作机制与单带图灵机高度一致，它用一个一维数组存取数据，数组元素初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一元素。指针可以向左/右移动，也可以读取/修改当前值。如果你了解 C 语言，那么一看表格便明白它每个运算符的含义： brainfuck c \u003e ++ptr; \u003c --ptr; + ++*ptr; - --*ptr; . putchar(*ptr); , *ptr = getchar(); [ while (*ptr) { ] } 不了解也没关系，它每个运算符的含义如下： \u003e 指针右移一格 \u003c 指针左移一格 + 使指针当前格数值加一 - 使指针当前格数值减一 . 把当前格数值按 ASCII 表输出到终端 , 从终端接收一字节的数据，存储其 ASCII 数值到当前格 [ 当指针当前值为 0 时，程序跳转至与之对应的 ] 之后；否则程序正常执行 ] 程序跳转回与之对应的 [ 处 有了这些工具，我们可以很快写出一个计算乘法的程序。因为 ASCII 表中 ‘A’ 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 ‘A’。 +++++\r[\r\u003e +++++++++++++\r\u003c -\r]\r\u003e .\r 把 brainfuck 的一维数组命名为 arr，则开始的数组元素为 arr[0]，arr[0] 右边的数组元素为 arr[1]。第一句代码将 arr[0] 的数值递增 5 次变为 5。 然后，循环执行“右移指针，递增 13 次，左移指针，递减 1 次”。当 arr[0] 的值最终被递减为 0 的时候，循环结束。此时 arr[1] 的值执行了 5 次“递增 13 次”的操作，即 65。最后指针右移至 arr[1]，输出它对应的 ASCII 值即为 A。网站1和网站2可以试玩这门程序语言。 ","date":"2020-11-17","objectID":"/2020-11-17-brainfuck/:3:0","tags":["Theories"],"title":"图灵机的极简实现","uri":"/2020-11-17-brainfuck/"},{"categories":["Thinking"],"content":"“我是谁？”，这种对指代自身的疑问每个人都会有。在自然语言和形式语言中，如果一个句子直接或间接提及自身，就称为自指(Self-reference)，自指的语句常常会造成悖论。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:0:0","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"不可判定怪圈 “这句话在说谎”，那么上句话是否在说谎呢？你会发现，你若判定真，那么就是假。你若判定假，那么就是真。永远得不到确切答案，最终陷入不可判定的怪圈： \r你以为这只是文字游戏？然而这种判定怪圈在严谨的自然科学中同样存在。并且科学家们运用它，推动了人类社会的进步。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:1:0","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"崩塌的数学大厦 在 1900 年巴黎数学家大会上，希尔伯特提出了他的 23 个著名数学问题。以希尔伯特为首的很多数学家，打算让数学矗立在一个坚实的地基(公理体系)上，一劳永逸地解决所有关于对数学可靠性的种种疑问，这可是一项宏图大志。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:2:0","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"第二个问题 这 23 个问题中的第 2 个问题是完成数学家们理想计划的关键一步，它包含如下三个问题： 数学是完备的吗？(正确的数学陈述，是否总能被证明？) 数学是一致的吗？(数学是否前后一致，没有内部矛盾？) 数学是可判定的吗？(能否仅通过计算判定数学陈述的真假？) 在数学中，不证自明的事实被归纳为公理。公理是数学推演和计算的起点，对公理的陈述就是命题，已被证明成立的重要命题被称为定理。那么一个可靠的数学系统至少应该满足以下性质： 有效性：在系统中如果前提为真，那么结论也为真 可靠性：系统中的所有定理都为真 一致性：系统中所有公理，定理之间没有矛盾 完备性：系统中不存在无法证明或无法证伪的命题 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:2:1","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"哥德尔不完备定理 这个想法非常美好，然而不久后，哥德尔用两条不完备定理将数学家们拍醒了： 第一定理：任何包含了算术的数学系统不可能同时拥有一致性和完备性(这里算术指皮亚诺算术(PA)的公理，这说明任何一个允许自然数加法和乘法的体系必定是不完备的，不能通过推理和计算得到所有真命题)。 第二定理：任何包含了算术的数学系统，如果它是一致的，那么它就不能证明自身的一致性。 哥德尔不完备定理宣告了把数学彻底形式化的愿望不可能实现，它让我们意识到“正确”与“可证”是两码事，简直颠覆了我们的认知，他的证明过程其实是构造了自指怪圈。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:2:2","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"图灵机的由来 哥德尔得到了第二个问题中前两个问题的答案。不久之后，图灵给出了其中最后一个问题的答案：数学是不可判定的。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:0","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"图灵对计算的思考 什么是计算？计算就是由输入(前提)到输出(结论)的过程。什么是可计算的？可计算就是一定能在有限步骤内完成的计算。为了给可计算一个精确定义，图灵提出了一种叫图灵机的数学模型，并提出了可计算函数(算法)的概念。(为什么可计算就是图灵机可判定，请看邱奇－图灵论题) 图灵对计算的思考让他解决了希尔伯特的问题，他的证明过程分两步: 1.停机问题不可判定 2.停机问题到判定问题的归约 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:1","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"停机问题不可判定 停机问题(halting problem)：是否存在一个程序 P，对于有任意输入参数的程序 w，能够判断 w 会在有限时间内结束或者死循环。图灵用对角论证法证明了，不存在解决停机问题的通用算法。本文引入自指做一个反证法证明(程序中的自指主要是递归)： 假设存在可以判定任意程序是否停机的程序，我们姑且称它为上帝程序 那么一定存在一个撒旦程序，首先让上帝程序判定自己，然后根据上帝判定结果，相反地运行程序 伪代码描述如下： def is_halt(program, input):\rif program halts on input:\rreturn true\relse:\rreturn false\rdef against_is_halt():\rif is_halt(against_is_halt): while (1):\rpass\relse:\rpass\r 在撒旦程序中，上帝程序的判断都是错的，所以不存在这样的上帝程序。停机问题是不可判定问题，这响应了哥德尔不完备定理。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:2","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"到判定问题的规约 现在将数学陈述转化为程序 w 的输入参数，前面的停机问题证明了，不存在上帝程序能够判定程序 w 能否在有限时间内结束，因此数学是不可判定的。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:3:3","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"自指与自复制 美国哲学家蒯因(Quine)创造了一种不使用代词就能构造自指语句的方法，称为蒯因技巧。如下句子便采用了蒯因技巧： 把“把中的第一个字放到左引号前面，其余的字放到右引号后面，并保持引号及其中的字不变”中的第一个字放到左引号前面，其余的字放到右引号后面，并保持引号及其中的字不变 当你按照该句子的指示操作后，便得到了它自身。该句子仅用动作便完成了一次自复制。我们发现这种结构的句子完全能用数学符号表达继而演化成数学函数。 数学家克林(Kleene)将蒯因这种语言上的操作技巧进行数学化得到了一种更加普适的递归定理。有了这个递归定理以后，数学家就可以在严格的数学公理体系中玩各种各样的自指游戏。哥德尔和图灵就是利用这种技术来完成他们的伟大证明的。 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:4:0","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Thinking"],"content":"思考总结 回到皮亚诺公理的第五条：对于无穷无尽具有相同性质的多米诺骨牌序列，已知第一块会倒下，并且每一块多米诺骨牌的倒下都会导致后一块倒下，是否每一块多米诺骨牌都会倒下？数学给出的假设是会，你觉得呢？数学是建立在有限假设之上的学科，当已知假设无法推导某些与无穷相关的性质时，就会在判定结果中显现出这种无穷无尽。一阶逻辑的逻辑归结是半可判定的，无法用有限归纳描述无穷过程。 自指太神秘了，关于它的研究涉及到了很多主流科学的交叉领域，作为门外汉的我只能无限感慨。想了解相关知识的读者，可以阅读下面的参考资料。 参考资料 计算的极限(零)：逻辑与图灵机 系统中的观察者——被科学遗忘的角色 自指机器的奥秘 ","date":"2020-11-16","objectID":"/2020-11-16-self-ref/:5:0","tags":["Theories"],"title":"自我指涉与数理逻辑","uri":"/2020-11-16-self-ref/"},{"categories":["Coding"],"content":"在前端开发的过程中，我们经常需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等，然而有些时候我们并不希望在事件持续触发的过程中频繁地去执行函数，这时候就会用到函数防抖(Debounce)与节流(Throttle)： 防抖：在触发事件 n 秒后才执行函数，如果在 n 秒内又触发了事件，则重新计算时间。 节流：连续触发事件时在 n 秒中只执行一次函数，节流的目的是稀释函数的执行频率。 下面我们简单地了解这两种限制函数执行次数的具体实现方式。首先看这个例子： \u003cbutton type=\"submit\" id=\"btn\"\u003e提交\u003c/button\u003e\r\u003cscript\u003e\rvar btn = document.getElementById('btn');\rbtn.addEventListener('click', submit, false);\rfunction submit(){\rconsole.log('submit');\r}\r\u003c/script\u003e\r 每次 button 的点击事件都会执行 submit 函数，我们如何限制 submit 的执行次数？ ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:0:0","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Coding"],"content":"Debounce 防抖是在事件多次触发时让函数只执行一次，有非立即执行和立即执行两种实现。 ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:1:0","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Coding"],"content":"闭包实现防抖 用闭包可以实现一个简单的 debounce 函数来包装 submit 函数，实现防抖效果。 var btn = document.getElementById('btn');\rbtn.addEventListener('click', debounce(submit, 1000), false);\rfunction submit(){\rconsole.log('submit');\r}\rfunction debounce(fn, timer){ let t = null; return function(){\r// 计时未到 timer 的定时器会被清理，函数就不会执行  if(t){ clearTimeout(t); }; t = setTimeout(fn, timer); };\r}\r 连续点击时，始终从最新一次点击开始计时。直到不再点击的 1s 后，才会执行一次 submit。 ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:1:1","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Coding"],"content":"传递 this 和 event 当我们在事件监听中绑定 submit 时，this 指向 button，并且可以拿到 MouseEvent 事件。 var btn = document.getElementById('btn');\rbtn.addEventListener('click', submit, false);\rfunction submit(){\rconsole.log('submit');\rconsole.log(this); // \u003cbutton type=\"submit\" ...\r console.log(arguments); // Arguments [MouseEvent ...\r}\r 现在我们的 submit 被 debounce 包装，此时 this 和事件参数要从 debounce 传递给 submit。 var btn = document.getElementById('btn');\rbtn.addEventListener('click', debounce(submit, 1000), false);\rfunction submit(){\rconsole.log('submit');\rconsole.log(this); // \u003cbutton type=\"submit\" ...\r console.log(arguments); // Arguments [MouseEvent ...\r}\rfunction debounce(fn, timer){ let t = null; return function(){ let context = this;\rlet args = arguments; if(t) clearTimeout(t); t = setTimeout(()=\u003e{\rfn.apply(context, args); }, timer); }\r}\r 这就是一个非立即执行的防抖实现，缺陷是第一次点击也需要等待 1s 后才会有反馈。 ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:1:2","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Coding"],"content":"立即执行版本 第一次点击时让函数立即执行。不再点击的 1s 后，新的点击将成为第一次点击，再次执行函数。 function debounce(fn, timer){ let t = null; return function(){ let context = this;\rlet args = arguments; let firstClick = !t;\rif(t) clearTimeout(t); if(firstClick) {\rfn.apply(context, args); }; t = setTimeout(()=\u003e{\rt = null;\r}, timer); }\r}\r ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:1:3","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Coding"],"content":"Throttle 节流的实现方式是减少函数的触发频率，同样有非立即执行和立即执行两种实现。 ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:2:0","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Coding"],"content":"定时器版本 非立即执行我们自然想到用定时器实现： function throttle(fn, timer) {\rlet t = null;\rreturn function() {\rlet context = this;\rlet args = arguments;\r// 计时未到 timer 时不会执行函数\r if (!t) {\rt = setTimeout(() =\u003e {\rfn.apply(context, args)\rt = null;\r}, timer)\r}\r}\r}\r ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:2:1","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Coding"],"content":"时间戳版本 立即执行我们要计算时间差，所以用时间戳实现： function throttle(fn, timer){\rlet begin = 0;\rreturn function(){\rlet now = new Date().getTime();\rif (now - begin \u003e timer) {\rfn.apply(this, arguments);\rbegin = now;\r}\r}\r}\r 实际上，结合非立即执行和立即执行的两种实现方式，你可以构造出具有更多功能的防抖函数和节流函数，满足业务需求。 参考资料 性能优化之防抖和节流 ","date":"2020-11-10","objectID":"/2020-11-10-js-closure/:2:2","tags":["JavaScript"],"title":"了解防抖与节流","uri":"/2020-11-10-js-closure/"},{"categories":["Coding"],"content":"以 useEffect 为圆心，其他 Hooks 为半径，构建 React Hooks 的知识圆环。为什么会想出这样一个标题呢？Hooks 的知识点过于分散，很多朋友在读过 React 官方文档后，还是不知道 Hooks 如何在实际项目中使用。本文希望从 useEffect 的具体用法中引出其他 Hooks，从而构建出完整的 React Hooks 知识体系。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:0:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"心智模型 学习 Hooks 的使用，重点是心智模型的转变。useEffect 的心智模型是实现状态同步，而不是响应生命周期事件。每次触发时 useEffect，它都会捕获本次调用时组件中的数据，也就是所谓的 Capture Value 特性：组件每次渲染都有自己的数据，组件内的函数(包括 effects，事件处理函数，定时器或者 API 调用等)会捕获该次渲染的组件数据。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:1:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"状态同步 首先看这段代码，请判断最终计时器中的 count 和 组件中的 count 分别是多少？ function Counter() {\rconst [count, setCount] = useState(0);\rconsole.log(\"组件中的count\", count);\ruseEffect(() =\u003e {\rconsole.log(\"触发useEffect\");\rconst id = setInterval(() =\u003e {\rconsole.log(\"计时器中的count\", count);\rsetCount(count + 1);\r}, 1000);\rreturn () =\u003e {\rconsole.log(\"销毁了定时器\");\rclearInterval(id);\r}\r}, []);\rreturn \u003ch1\u003e{count}\u003c/h1\u003e;\r}\r 答案分别是 0 和 1，多少有点基础的人都能想通或者猜对。现在更改需求，让组件中的 count 每秒加 1。我们有两种写法： 不对依赖数组撒谎 // 每次因 count 变化触发的重渲染都会触发 useEffect\rfunction Counter() {\rconst [count, setCount] = useState(0);\rconsole.log(\"组件中的count\", count);\ruseEffect(() =\u003e {\rconsole.log(\"触发useEffect\");\rconst id = setInterval(() =\u003e {\rconsole.log(\"计时器中的count\", count);\rsetCount(count + 1);\r}, 1000);\rreturn () =\u003e {\rconsole.log(\"销毁了定时器\");\rclearInterval(id);\r}\r}, [count]);\rreturn \u003ch1\u003e{count}\u003c/h1\u003e;\r}\r 每次重渲染创建 Counter 组件时都会触发 useEffect，销毁上一次的计数器，并创建新的计数器。因此组件中的 count 和计时器中的 count 是同步的。 让 Effect 自给自足 // 移除 useEffect 的非必需的依赖，减少不必要的触发。\rfunction Counter() {\rconst [count, setCount] = useState(0);\rconsole.log(\"组件中的count\", count);\ruseEffect(() =\u003e {\rconsole.log(\"触发useEffect\");\rconst id = setInterval(() =\u003e {\rconsole.log(\"计时器中的count\", count);\r// 这里接收的函数描述 count 如何变化(action)\r setCount(c =\u003e c + 1);\r}, 1000);\rreturn () =\u003e {\rconsole.log(\"销毁了定时器\");\rclearInterval(id);\r}\r}, []);\rreturn \u003ch1\u003e{count}\u003c/h1\u003e;\r}\r 通过控制台我们发现，计时器中的 count 始终为 0，怎么解释？useEffect 只在组件初次渲染后触发一次，它创建了计时器，计时器记住了当时的 count。既然计时器中的 count 始终为 0，那么 setCount 是怎样让组件状态同步的呢？想搞清楚这一点就不得不提 useReducer 了。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:2:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"useReducer 事实上，useState 是预置了如下 reducer 的 useReducer，相关 源码 ： function basicStateReducer\u003cS\u003e(state: S, action: BasicStateAction\u003cS\u003e): S {\rreturn typeof action === 'function' ? action(state) : action;\r}\r 也就是说，setCount 接收的 action 函数是在下一次函数组件渲染时，在 useState 中调用的。描述动作和执行动作分开进行，感觉有 Redux 的内味了？没错，React 还为 useReducer 提供了配套的 dispatch 方法： const [state, dispatch] = useReducer(reducer, initialArg, init);\r 再次更改需求，我们不让计时器每秒加 1，而是由输入的 step 控制。还是对比两种写法： 不对依赖数组撒谎 function Counter() {\rconst [count, setCount] = useState(0);\rconst [step, setStep] = useState(0);\ruseEffect(() =\u003e {\rconst id = setInterval(() =\u003e {\rsetCount(count =\u003e count + step);\r}, 1000);\rreturn () =\u003e clearInterval(id);\r}, [step]);\r...\r}\r 让 Effect 自给自足 const initialState = {\rcount: 0,\rstep: 0,\r};\rfunction reducer(state, action) {\rconst { count, step } = state;\rif (action.type === 'tick') {\rreturn { count: count + step, step };\r} else if (action.type === 'step') {\rreturn { count, step: action.step };\r} else {\rthrow new Error();\r}\r}\rfunction Counter() {\rconst [state, dispatch] = useReducer(reducer, initialState);\rconst { count, step } = state;\ruseEffect(() =\u003e {\rconst id = setInterval(() =\u003e {\rdispatch({ type: 'tick' });\r}, 1000);\rreturn () =\u003e clearInterval(id);\r}, []);\rreturn (\r\u003cdiv\u003e\r\u003ch1\u003e{count}\u003c/h1\u003e\r\u003cinput value={step} onChange={e =\u003e {\rdispatch({\rtype: 'step',\rstep: Number(e.target.value)\r});\r}} /\u003e\r\u003cdiv/\u003e\r);\r}\r 移除 useEffect 的非必需的依赖，就能减少不必要的触发，是一种性能优化思路。还有一种思路是保持 useEffect 的依赖不变，也能减少不必要的触发，这会用到 useCallback 和 useMemo。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:3:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"useCallback React 判断组件中的数据是否发生改变时使用了 Object.is 进行比较。当 useEffect 的依赖数组的元素为引用数据类型时，每次的比较结果都是发生改变，这就失去了依赖数组本身的意义(条件式地触发 useEffect)。看这段代码，我们希望复用网络请求逻辑，这样可行吗？ function SearchResults() {\rconst getFetchUrl = (query) =\u003e {\rreturn 'https://hn.algolia.com/api/v1/search?query=' + query;\r}; useEffect(() =\u003e {\rconst url = getFetchUrl('react');\r// Fetch data and do something ...\r}, [getFetchUrl]); useEffect(() =\u003e {\rconst url = getFetchUrl('redux');\r// Fetch data and do something ...\r}, [getFetchUrl]);\r...\r}\r 当我们写这段代码时，我们发现网络请求将无限重复，因为函数调用会生成不同引用。一个可能的解决办法是把 getFetchUrl 从依赖中去掉，前提是你能确保它不受数据流变化的影响，否则就会出现意想不到的 bugs。 然而 useEffect 的设计意图就是要强迫你关注数据流的变化，然后去同步状态。当不能把函数从依赖中去掉时，我们可以使用 useCallback 来包装函数从而确保函数的引用相等： /** useCallback 在其依赖变化时，才生成新的函数\r* 现在依赖为空，getFetchUrl 永远调用同一个函数 */\rconst getFetchUrl = useCallback((query) =\u003e {\rreturn 'https://hn.algolia.com/api/v1/search?query=' + query;\r}, []); 更改 getFetchUrl 后就能避免网络请求重复的问题了。useCallback 本质上是对函数添加了一层依赖检查，让函数只在需要改变的时候才改变。 useCallback 的另一个使用场景：当父组件传递函数给子组件的时候，由于父组件的更新会导致该函数重新生成，从而传递给子组件的函数引用发生变化，这就会导致子组件也会更新，这时我们可以通过 useCallback 来缓存该函数，然后传递给子组件同一个函数避免子组件更新(子组件需用 memo 包装)，看这篇 文章 的例子。 useMemo 扩展了 useCallback 的功能，useCallback 只能缓存函数，而 useMemo 可以缓存任何类型的值，同样是为了确保引用相等。除此之外，useMemo 还可以用于避免重复计算。 ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:4:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"useRef 现在来看这个例子，我们连续点击 Add count 按钮时，3s 后会发生什么？ function Counter() {\rconst [count, setCount] = useState(0);\ruseEffect(() =\u003e {\rsetTimeout(() =\u003e {\rconsole.log(count);\r}, 3000);\r});\rreturn (\r\u003cdiv\u003e\r\u003ch1\u003e{count}\u003c/h1\u003e\r\u003cbutton onClick={()=\u003esetCount(count+1)}\u003eAdd count\u003c/button\u003e\r\u003cdiv/\u003e\r);\r}\r 3s 后会在控制台依次打印 count 的值 1，2，3 …，然而在一些场景中，我们只想得到最新的 count 值，该怎么做？这就会用到 useRef，useRef 返回一个可变的 ref 对象，它的属性 current 被初始化为传入的参数，并且 useRef 始终返回同一个 ref 对象。 function Counter() {\rconst [count, setCount] = useState(0);\rconst latestCount = useRef(count);\ruseEffect(() =\u003e {\rlatestCount.current = count;\rsetTimeout(() =\u003e {\rconsole.log(latestCount.current);\r}, 3000);\r});\rreturn (\r\u003c\u003e\r\u003ch1\u003e{count}\u003c/h1\u003e\r\u003cbutton onClick={()=\u003esetCount(count+1)}\u003eAdd count\u003c/button\u003e\r\u003c/\u003e\r );\r}\r 现在我们连续点击会发现 3s 后控制台将多次打印最新的 count 值，这证明我们修改的是同一个 ref 对象。除了用来缓存变量，useRef 还能获得 DOM 元素，需要在元素上绑定 ref 属性： function RefDemo() {\rconst titleRef = useRef();\rfunction changeDOM() {\rtitleRef.current.innerHTML = 'hello world';\rtitleRef.current.style.color = 'red';\r}\rreturn (\r\u003cdiv\u003e\r\u003ch2 ref={titleRef}\u003eRefDemo\u003c/h2\u003e\r\u003cbutton onClick={changeDOM}\u003e修改DOM\u003c/button\u003e\r\u003c/div\u003e\r);\r}\r ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:5:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"思考 暂时就先这样吧，后面还会再补充。 参考资料 A Complete Guide to useEffect ","date":"2020-11-02","objectID":"/2020-11-02-react-hooks/:6:0","tags":["React"],"title":"以 useEffect 为圆心","uri":"/2020-11-02-react-hooks/"},{"categories":["Coding"],"content":"现在，我们遵循 React 16.8 的代码体系结构，一步一步地构建我们自己的 mini React。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:0:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"基础回顾 开始之前，我们先回顾 React 是怎么将 JSX 转换成 DOM 节点的： const element = \u003ch1 title=\"foo\"\u003eHello\u003c/h1\u003e\rconst container = document.getElementById(\"root\")\rReactDOM.render(element, container)\r 第一行使用 JSX 来创建元素，但 JSX 不是有效的 JS 代码。React 用 Babel 将 JSX 代码转换为原生 JS 代码。转换过程就是调用 createElement 函数，并将 JSX 的元素类型、props 属性和 childen 元素作为参数依次传入： const element = \u003ch1 title=\"foo\"\u003eHello\u003c/h1\u003e\r// Babel 调用 createElement 函数完成转换\rconst element = React.createElement(\r\"h1\",\r{ title: \"foo\" },\r\"Hello\"\r)\r// createElement 根据参数生成 object\rconst element = {\rtype: \"h1\",\rprops: {\rtitle: \"foo\",\rchildren: \"Hello\",\r},\r}\r 这就是 React 元素的本质，包含 type 和 props 属性的对象(还有其他属性，我们只关注这两个)。现在我们就能用 element 生成 DOM 节点了。 ​const container = document.getElementById(\"root\")\r​\rconst node = document.createElement(element.type)\rnode[\"title\"] = element.props.title\r​\rconst text = document.createTextNode(\"\")\rtext[\"nodeValue\"] = element.props.children\r​\rnode.appendChild(text)\rcontainer.appendChild(node)\r ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:1:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"渲染阶段 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"createElement 现在我们来实现自己的 createElement 函数。注意一个细节，JSX 叶子节点可能是基本数据类型。我们把它包装为对象，统一数据类型(React 不会包装基本类型值或创建空数组，我们这样做是为了数据判断和修改的方便)。 function createElement(type, props, ...children) {\rreturn {\rtype,\rprops: {\r...props,\rchildren: children.map(child =\u003e\rtypeof child === \"object\" ? child : createTextElement(child)\r)\r}\r};\r}\rfunction createTextElement(text) {\rreturn {\rtype: \"TEXT_ELEMENT\",\rprops: {\rnodeValue: text,\rchildren: []\r}\r};\r}\r ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:1","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"render 创建 DOM 节点并添加元素的 props 属性。 function render(element, container) {\rconst dom =\relement.type == \"TEXT_ELEMENT\"\r? document.createTextNode(\"\")\r: document.createElement(element.type);\rconst isProperty = key =\u003e key !== \"children\";\rObject.keys(element.props)\r.filter(isProperty)\r.forEach(name =\u003e {\rdom[name] = element.props[name];\r});\relement.props.children.forEach(child =\u003e render(child, dom));\rcontainer.appendChild(dom);\r}\r 现在将我们的库取名 Didact，让 Babel 调用我们的库转换 JSX。 const Didact = {\rcreateElement,\rrender\r};\r/** @jsx Didact.createElement */\rconst element = (\r\u003cdiv style=\"background: salmon\"\u003e\r\u003ch1\u003eHello World\u003c/h1\u003e\r\u003ch2 style=\"text-align:right\"\u003efrom Didact\u003c/h2\u003e\r\u003c/div\u003e\r);\rconst container = document.getElementById(\"root\");\rDidact.render(element, container);\r 这样就实现了 JSX 的转换和渲染，在 codesandbox 中试试看。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:2","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Concurrent 在我们加入更多特性之前我们先对代码进行一次重构。因为递归调用存在一个问题：渲染开始就会一直阻塞主进程。如果浏览器需要处理一些高优先级的任务(像用户输入或者保持动画流畅)，需要等到所有元素渲染完成之后再进行处理，这是不好的用户体验。 let nextUnitOfWork = null\r​\rfunction workLoop(deadline) {\rlet shouldYield = false\rwhile (nextUnitOfWork \u0026\u0026 !shouldYield) {\r// 迭代子任务\r nextUnitOfWork = performUnitOfWork(\rnextUnitOfWork\r)\rshouldYield = deadline.timeRemaining() \u003c 1\r}\rrequestIdleCallback(workLoop)\r}\r​// 主进程空闲时才会调用回调函数\rrequestIdleCallback(workLoop)\r​// 执行当前子任务并返回下一个子任务\rfunction performUnitOfWork(nextUnitOfWork) {\r// TODO\r}\r 现在我们拆分整个任务为一个个小的子任务，浏览器可以在执行完每个小任务后中断渲染流程去处理其他事情。因为我们使用 reqeustIdleCallback 来创建一个循环任务(React 现在使用 scheduler)，它在主进程空闲时才会执行回调函数，它为回调函数提供一个 deadline 参数，据此我们可以知晓还剩多少时间浏览器会拿回控制权。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:3","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Fibers 我们使用 fiber 树连接所有子任务，为每个元素创建一个 fiber，每个 fiber 对应一个子任务。假如我们渲染如下一颗元素树： Didact.render(\r\u003cdiv\u003e\r\u003ch1\u003e\r\u003cp /\u003e\r\u003ca /\u003e\r\u003c/h1\u003e\r\u003ch2 /\u003e\r\u003c/div\u003e,\rcontainer\r)\r 生成对应的 fiber 树： \r在渲染中，我们将 container 创建为 root 并将其设置为 nextUnitOfWork。而元素的 fiber 由 performUnitOfWork 生成，我们将为每个 fiber 做三件事： 1.将元素添加到 DOM 中。 2.为元素的子元素创建 fiber。 3.寻找下一个子任务。 现在我们从 render 中提取出创建 DOM 节点的逻辑，稍后我们会使用它。 function createDom(fiber) {\rconst dom = fiber.type == \"TEXT_ELEMENT\"? document.createTextNode(\"\"): document.createElement(fiber.type)\rconst isProperty = key =\u003e key !== \"children\"\rObject.keys(fiber.props)\r.filter(isProperty)\r.forEach(name =\u003e {\rdom[name] = fiber.props[name]\r})\r​\rreturn dom\r}\r 在 render 函数中，我们将 nextUnitOfWork 的 DOM 属性设置为 container。 function render(element, container) {\rnextUnitOfWork = {\rdom: container,\rprops: {\rchildren: [element],\r},\r}\r}\r​\rlet nextUnitOfWork = null\r 接下来在 performUnitOfWork 中完成每个 fiber 的三件事。 function performUnitOfWork(fiber) {\r// 需要与父节点的 DOM 连接时才创建 DOM 节点\r if (!fiber.dom) {\rfiber.dom = createDom(fiber)\r}\r​\rif (fiber.parent) {\rfiber.parent.dom.appendChild(fiber.dom)\r}\r​ // 为子元素创建 newFiber，dom 属性为空\r const elements = fiber.props.children\rlet index = 0\rlet prevSibling = null\r​\rwhile (index \u003c elements.length) {\rconst element = elements[index]\r​\rconst newFiber = {\rtype: element.type,\rprops: element.props,\rparent: fiber,\rdom: null,\r}\rif (index === 0) {\rfiber.child = newFiber\r} else {\rprevSibling.sibling = newFiber\r}\r​\rprevSibling = newFiber\rindex++\r}\r// 寻找下一个子任务，优先级依次是子节点、兄弟节点、叔叔节点。\r if (fiber.child) {\rreturn fiber.child\r}\rlet nextFiber = fiber\rwhile (nextFiber) {\rif (nextFiber.sibling) {\rreturn nextFiber.sibling\r}\rnextFiber = nextFiber.parent\r}\r}\r ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:4","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Commit 处理元素时我们每次向 DOM 添加一个新节点。但浏览器是会中断渲染过程的，这样用户会看到不完整的 UI。我们怎么避免这种情况呢？答案是重构操作 DOM 的代码。 首先在删除 performUnitOfWork 中添加 DOM 节点的代码： // if (fiber.parent) {\r// fiber.parent.dom.appendChild(fiber.dom)\r// }\r 然后在 render 中用 wipRoot 保存 fiber root 节点。 function render(element, container) {\rwipRoot = {\rdom: container,\rprops: {\rchildren: [element],\r},\r}\rnextUnitOfWork = wipRoot\r}\r​\rlet nextUnitOfWork = null\rlet wipRoot = null\r 直到本次全部元素渲染结束时，我们才将整个 fiber 树提交到 DOM 中。 function commitRoot() {\r// 将所有元素的 fiber 递归附加到 DOM commitWork(wipRoot.child)\rwipRoot = null\r}\r​\rfunction commitWork(fiber) {\rif (!fiber) {\rreturn\r}\rconst domParent = fiber.parent.dom\rdomParent.appendChild(fiber.dom)\rcommitWork(fiber.child)\rcommitWork(fiber.sibling)\r}\rfunction workLoop(deadline) {\rlet shouldYield = false\rwhile (nextUnitOfWork \u0026\u0026 !shouldYield) {\rnextUnitOfWork = performUnitOfWork(\rnextUnitOfWork\r)\rshouldYield = deadline.timeRemaining() \u003c 1\r} ​ // 直到没有下一个子任务，将整个 fiber 树提交到 DOM 节点中\r if (!nextUnitOfWork \u0026\u0026 wipRoot) {\rcommitRoot()\r}\rrequestIdleCallback(workLoop)\r}\r​// 主进程空闲时才会调用回调函数\rrequestIdleCallback(workLoop)\r ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:2:5","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"更新阶段 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:3:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Reconciliation 到目前为止，我们只是将元素添加到了 DOM 中，但是我们怎么去更新或者删除节点呢？(diff) 在每个 fiber 中添加 alternate 属性保存上一次提交到 DOM 中的 fiber。先在 wipRoot 中添加： function commitRoot() {\rcommitWork(wipRoot.child)\r// 渲染结束时存储当前的 fiber root\r currentRoot = wipRoot\rwipRoot = null\r}\r​\rfunction render(element, container) {\rwipRoot = {\rdom: container,\rprops: {\rchildren: [element],\r},\ralternate: currentRoot,\r}\rnextUnitOfWork = wipRoot\r}\r​\rlet nextUnitOfWork = null\r// 增加 currentRoot 用于保存当前提交到 DOM 中的 fiber 树\rlet currentRoot = null\rlet wipRoot = null\r 将 performUnitOfWork 中创建新 fiber 的逻辑移到 reconcileChildren 函数中，给每个子 fiber 添加 alternate 和 effectTag 属性(effectTag 属性用于 Commit 阶段)： // 协调(比较和复用)当前 fiber 的所有子 fiber\rfunction reconcileChildren(wipFiber, elements) {\rlet index = 0\rlet oldFiber = wipFiber.alternate \u0026\u0026 wipFiber.alternate.child\rlet prevSibling = null\rwhile ( index \u003c elements.length || oldFiber != null ) {\rconst element = elements[index]\rlet newFiber = null\rconst sameType = oldFiber \u0026\u0026 element \u0026\u0026 element.type == oldFiber.type\r// 需要添加新的 fiber\r if (element \u0026\u0026 !sameType) {\rnewFiber = {\rtype: element.type,\rprops: element.props,\rdom: null,\rparent: wipFiber,\ralternate: null, effectTag: \"PLACEMENT\",\r}\r}\r// 需要更新原来的 fiber\r if (sameType) {\rnewFiber = {\rtype: oldFiber.type,\rprops: element.props,\rdom: oldFiber.dom,\rparent: wipFiber,\r// oldFiber 被替换时才需要用 alternate 保存\r alternate: oldFiber, effectTag: \"UPDATE\",\r}\r}\r// 需要删除原来的 fiber\r if (oldFiber \u0026\u0026 !sameType) {\roldFiber.effectTag = \"DELETION\"\r}\rif (oldFiber) {\roldFiber = oldFiber.sibling\r}\rif (index === 0) {\rwipFiber.child = newFiber\r} else if (element) {\rprevSibling.sibling = newFiber\r}\rprevSibling = newFiber\rindex++\r}\r}\r ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:3:1","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Commit 现在我们需要修改 commitWork 函数完成 DOM 的修改。 function commitWork(fiber) {\rif (!fiber) {\rreturn\r}\rconst domParent = fiber.parent.dom\rif (\rfiber.effectTag === \"PLACEMENT\" \u0026\u0026\rfiber.dom != null\r) {\rdomParent.appendChild(fiber.dom)\r} else if (\rfiber.effectTag === \"UPDATE\" \u0026\u0026\rfiber.dom != null\r) {\rupdateDom(\rfiber.dom,\rfiber.alternate.props,\rfiber.props\r)\r} else if (fiber.effectTag === \"DELETION\") {\rdomParent.removeChild(fiber.dom)\r}\rcommitWork(fiber.child)\rcommitWork(fiber.sibling)\r}\r 这里的 updateDom 就是用来更新 DOM 节点的属性。 const isProperty = key =\u003e key !== \"children\" \u0026\u0026 !isEvent(key)\rconst isEvent = key =\u003e key.startsWith(\"on\")\rconst isNew = (prev, next) =\u003e key =\u003e prev[key] !== next[key]\rconst isGone = (prev, next) =\u003e key =\u003e !(key in next)\rfunction updateDom(dom, prevProps, nextProps) {\r// 删除旧的属性\r Object.keys(prevProps)\r.filter(isProperty)\r.filter(isGone(prevProps, nextProps))\r.forEach(name =\u003e {\rdom[name] = \"\"\r})\r// 删除旧的事件监听\r Object.keys(prevProps)\r.filter(isEvent)\r.filter(\rkey =\u003e\r!(key in nextProps) ||\risNew(prevProps, nextProps)(key)\r)\r.forEach(name =\u003e {\rconst eventType = name\r.toLowerCase()\r.substring(2)\rdom.removeEventListener(\reventType,\rprevProps[name]\r)\r})\r// 设置新的属性\r Object.keys(nextProps)\r.filter(isProperty)\r.filter(isNew(prevProps, nextProps))\r.forEach(name =\u003e {\rdom[name] = nextProps[name]\r})\r// 添加新的事件监听\r Object.keys(nextProps)\r.filter(isEvent)\r.filter(isNew(prevProps, nextProps))\r.forEach(name =\u003e {\rconst eventType = name\r.toLowerCase()\r.substring(2)\rdom.addEventListener(\reventType,\rnextProps[name]\r)\r})\r}\r 在 codesandbox 中查看完整代码。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:3:2","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"函数组件 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:4:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Commit 现在，我们考虑在已有代码的基础上，增加对函数组件和 Hooks 的支持。看这个函数组件： /** @jsx Didact.createElement */\rfunction App(props) {\rreturn \u003ch1\u003eHi {props.name}\u003c/h1\u003e\r}\rconst element = \u003cApp name=\"foo\" /\u003e\rconst container = document.getElementById(\"root\")\rDidact.render(element, container)\r 如果我们将 jsx 转换为 js，Babel 的解析方式会是这样： function App(props) {\rreturn Didact.createElement(\r\"h1\",\rnull,\r\"Hi \",\rprops.name\r)\r}\r// 这里虽然会调用 createElement，但并不会调用 App 获取子元素\rconst element = Didact.createElement(App, {name: \"foo\"}, )\r 观察 Babel 的解析后会发现： 我们不能为函数 App 创建 DOM 节点，因为没有 html 标签，只能渲染它的子元素。 子元素不会通过 createElement 的第三个参数传递，子元素需手动调用函数获取。 为函数创建子 fiber 我们可以这样做： function updateFunctionComponent(fiber) {\r// 由于 Babel 调用 createElement，得到的 fiber.type 就是函数名\r const children = [fiber.type(fiber.props)] reconcileChildren(fiber, children)\r}\r 我们需要修改 commitWork，因为函数的 fiber 没有 DOM 节点。我们要考虑如果在 fiber 树中存在无 DOM 节点的 fiber 时，如何连接 DOM： 要找到一个 DOM 节点的父节点，我们需要找到一个包含 DOM 节点的 fiber。 当需要移除一个 fiber 节点时，我们需要找到一个包含 DOM 节点的子节点。 function commitWork(fiber) {\rif (!fiber) {\rreturn\r}\r// 寻找到包含 DOM 的父节点\r let domParentFiber = fiber.parent\rwhile (!domParentFiber.dom) {\rdomParentFiber = domParentFiber.parent\r}\rconst domParent = domParentFiber.dom\r​\rif (\rfiber.effectTag === \"PLACEMENT\" \u0026\u0026\rfiber.dom != null\r) {\rdomParent.appendChild(fiber.dom)\r} else if (\rfiber.effectTag === \"UPDATE\" \u0026\u0026\rfiber.dom != null\r) {\rupdateDom(\rfiber.dom,\rfiber.alternate.props,\rfiber.props\r)\r} else if (fiber.effectTag === \"DELETION\") {\r// 寻找到包含 DOM 的子节点\r commitDeletion(fiber,domParent);\r}\rcommitWork(fiber.child)\rcommitWork(fiber.sibling)\r}\rfunction commitDeletion(fiber, domParent) {\rif (fiber.dom) {\rdomParent.removeChild(fiber.dom)\r} else {\rcommitDeletion(fiber.child, domParent)\r}\r}\r ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:4:1","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"Hooks 最后一步，既然我们使用了函数组件，那么就要给它加上状态。 首先更新为函数创建子 fiber 的函数： let wipFiber = null\rlet hookIndex = null\r​\rfunction updateFunctionComponent(fiber) {\rwipFiber = fiber\r// 记录当前 hook 的索引\r hookIndex = 0\r// 支持在同一个组件中多次调用 useState 函数\r wipFiber.hooks = []\rconst children = [fiber.type(fiber.props)]\rreconcileChildren(fiber, children)\r}\r 然后我们写自己的 useState 函数： function useState(initial) {\rconst oldHook = wipFiber.alternate \u0026\u0026 wipFiber.alternate.hooks \u0026\u0026 wipFiber.alternate.hooks[hookIndex]\r// 如果存在旧的 hook，我们从旧的 hook 中拷贝状态到新的 hook\r const hook = {\rstate: oldHook ? oldHook.state : initial,\rqueue:[]\r}\r// 拿到 action(更新状态的回调函数) 处理 state\r const actions = oldHook ? oldHook.queue : []\ractions.forEach(action =\u003e {\rhook.state = action(hook.state)\r})\r// setState 将 action 添加到 hook 的 queue 中\r​ const setState = action =\u003e {\rhook.queue.push(action)\rwipRoot = {\rdom: currentRoot.dom,\rprops: currentRoot.props,\ralternate: currentRoot,\r}\r// 重新渲染这颗 fiber tree\r nextUnitOfWork = wipRoot\r}\rwipFiber.hooks.push(hook)\rhookIndex++\r// 返回 state 和 setState\r return [hook.state, setState]\r}\r 就这样，我们构建出了我们自己的 mini React，在 codesandbox 中查看完整代码。 ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:4:2","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"经验总结 本文的目的之一是让你更轻松地深入学习 React，这就是我们在几乎所有地方都使用与 React 相同的变量和函数名称的原因。但是我们构建的代码库并没有包含很多的 React 特性以及优化，以下是 React 与我们的实现做得不同的地方： 我们的渲染阶段会遍历整棵树，而 React 会跳过那些没有发生改变的子树。 我们会在提交阶段遍历整个树，而 React 只会保留产生影响的 fiber 节点。 我们为每个 fiber 创建一个新的对象，而 React 会复用之前树上的 fiber 节点。 我们在渲染阶段收到一个新的更新时，会丢弃之前的工作树，从根节点重新开始。而 React 给每一个更新标记一个过期时间戳，通过这个时间戳来决定各个更新之间的优先级。 除此之外还有很多… 参考资料 Build your own React ","date":"2020-10-18","objectID":"/2020-10-18-mini-react/:5:0","tags":["React"],"title":"构建自己的 mini React","uri":"/2020-10-18-mini-react/"},{"categories":["Coding"],"content":"本文是我最近阅读一篇英文技术文章后写的小结。阅读前请注意，本文不涉及任何 Recoil 源码。仿写的代码并不是 Recoil 真正的实现方式，本文只仿造实现了 Recoil 中两个重要的 API 接口：Atom 和 Selector。 如果你不熟悉 Recoil，请先阅读我的这篇 文章 或者阅读它的 官方文档。然后新建 React 项目： npx create-react-app recoil-clone --typescript\r 在根目录下新建 coiled.tsx 文件，下面的代码都在这个文件中实现。 ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:0:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"状态基类 定义一个 Stateful 表示共享状态的基类，Atom 和 Selector 需继承这个基类。为了监听状态的变化，我们使用观察者模式。这种设计模式在 RxJS 之类的库中很常见，我将从头开始编写一个简单的同步版本。 interface Disconnect {\rdisconnect: () =\u003e void;\r}\rexport class Stateful\u003cT\u003e {\r// Set 是 callback 的集合\r private listeners = new Set\u003c() =\u003e void\u003e();\rconstructor(protected value: T) {}\r// 取值函数\r snapshot(): T {\rreturn this.value;\r}\r// 此处才会调用所有的监听者\r private emit() {\rfor (const listener of Array.from(this.listeners)) {\rconsole.log('调用监听者: ' + listener);\rlistener();\r}\r}\r// update 方法可以被 Stateful 的子类 Atom 和 Selector 继承\r protected update(value: T) {\rif (this.value !== value) {\rthis.value = value;\rconsole.log('新值: ' + this.value);\rthis.emit();\r}\r}\r// 订阅就加入监听者的 Set 集合，此方法接收 callback，返回也是 callback subscribe(callback: () =\u003e void): Disconnect {\rconsole.log('注册监听者：' + callback);\rthis.listeners.add(callback);\rreturn {\rdisconnect: () =\u003e {\rconsole.log('注销监听者：' + callback);\rthis.listeners.delete(callback);\r},\r};\r}\r}\r ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:1:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"自定义 hook 下面是只读 hook 的实现方式。atom 和 selector 均可读，因此参数只需满足 Stateful 类型。这里注册的监听者 updateState 巧妙地利用了函数组件的重渲染机制，因为 useState 的参数为引用数据类型，{} === {} 的值为 false，因此只要调用 updateState 函数就会重渲染组件。关于 React 组件何时会重渲染可以读这篇 文章。 export function useCoiledValue\u003cT\u003e(value: Stateful\u003cT\u003e): T {\r// 只要调用 updateState 就会触发重渲染\r const [, updateState] = useState({});\ruseEffect(() =\u003e {\rconsole.log('渲染结束调用 useEffect, 添加监听者')\r// 注册 updateState 为监听者, 监听者是 callback 的 Set 集合\r const { disconnect } = value.subscribe(() =\u003e updateState({}));\rreturn () =\u003e disconnect();\r}, [value]);\rconsole.log('此时 useCoiledValue 的值: ' + value.snapshot());\rreturn value.snapshot();\r}\r 下面是读写 hook 的实现方式，这里的读写 hook 只适用于 atom，默认 selector 不可写。 export function useCoiledState\u003cT\u003e(atom: Atom\u003cT\u003e): [T, (value: T) =\u003e void] {\rconst value = useCoiledValue(atom);\rreturn [value, useCallback(value =\u003e atom.setState(value), [atom])];\r}\r ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:2:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"Atom Atom 继承 Stateful，需要一个默认的写值方法。 export class Atom\u003cT\u003e extends Stateful\u003cT\u003e {\rpublic setState(value: T) {\rsuper.update(value);\r}\r}\r 暴露的接口函数是仿写 Recoil 中的 atom 函数。 export function atom\u003cV\u003e(value: { key: string; default: V }): Atom\u003cV\u003e {\rreturn new Atom(value.default);\r}\r ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:3:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"Selector Selector 继承 Stateful，Selector 是 Atom 或其他 Selector 的派生值，因此需要添加依赖。 export class Selector\u003cT\u003e extends Stateful\u003cT\u003e {\r// 将 dep 加入 Set 集合\r private registeredDeps = new Set\u003cStateful\u003cany\u003e\u003e();\rprivate addDep\u003cV\u003e(dep: Stateful\u003cV\u003e): V {\rif (!this.registeredDeps.has(dep)) {\r// 注册 updateSelector 为监听者，并将 dep 加入 Set 集合\r dep.subscribe(() =\u003e this.updateSelector());\rthis.registeredDeps.add(dep);\r}\rreturn dep.snapshot();\r}\r// 调用 generate 直接返回当前的 dep 值\r private updateSelector() {\rthis.update(this.generate({ get: dep =\u003e this.addDep(dep) }));\r}\rconstructor(private readonly generate: SelectorGenerator\u003cT\u003e) {\rsuper(undefined as any);\rthis.value = generate({ get: dep =\u003e this.addDep(dep) });\r}\r}\r// selector 接收 atom 或者其他 selector 作为依赖\rtype SelectorGenerator\u003cT\u003e = (context: { get: \u003cV\u003e(dep: Stateful\u003cV\u003e) =\u003e V }) =\u003e T;\r 暴露的接口函数是仿写 Recoil 中的 selector 函数。 export function selector\u003cV\u003e(value: {\rkey: string;\rget: SelectorGenerator\u003cV\u003e;\r}): Selector\u003cV\u003e {\rreturn new Selector(value.get);\r}\r ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:4:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"使用 将 index.tsx 作如下修改后，启动项目 yarn start，查看浏览器的 cosole 面板，项目成功运行。 import React from 'react';\rimport ReactDOM from 'react-dom';\rimport { atom, useCoiledState, useCoiledValue, selector } from './coiled';\rimport './App.css';\rconst textState = atom\u003cstring\u003e({\rkey: 'textState', default: '', });\rconst charCountState = selector\u003cnumber\u003e({\rkey: 'charCountState',\rget: ({get}) =\u003e {\rconst text = get(textState);\rreturn text.length;\r},\r});\rfunction TextInput() {\rconst [text, setText] = useCoiledState(textState);\rconst onChange = (event: any) =\u003e {\rsetText(event.target.value);\r};\rreturn (\r\u003cdiv\u003e\r\u003cinput type=\"text\" value={text} onChange={onChange} /\u003e\r\u003cbr /\u003e\rEcho: {text}\r\u003c/div\u003e\r);\r}\rfunction CharacterCount() {\rconst count = useCoiledValue(charCountState);\rreturn \u003c\u003eCharacter Count: {count}\u003c/\u003e;\r }\rfunction App() {\rreturn (\r\u003cdiv className=\"App\"\u003e\r\u003cTextInput /\u003e\r\u003cCharacterCount /\u003e\r\u003c/div\u003e\r);\r}\rReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\r 在 codesandbox 中查看完整代码。 ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:5:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"思考 我们仿造 Recoil 实现了自己的状态共享。但请思考以下内容： Selectors 不会取消对 atoms 的监听。这意味着当你不再使用他们时，会造成内存泄漏。 Selectors 和 Atoms 在重渲染前仅做一个浅比较。在某些场景下，使用深比较更加合理。 Recoil 使用唯一 key 值标识每一个 atom 或 selector，并且它被用作支持 “App-wide observation” 的元数据。这里的实现仅仅是为了保持 API 相似。 Recoil 在 selectors 里支持异步，这里没有实现这个特性。 我在 github 上发现了 jotai 项目。它与我的仿写非常相似，并且支持异步。 参考资料 Rewriting Facebook’s “Recoil” React library … ","date":"2020-10-07","objectID":"/2020-10-07-recoil-clone/:6:0","tags":["React","Recoil"],"title":"实现仿 Recoil 的状态共享","uri":"/2020-10-07-recoil-clone/"},{"categories":["Coding"],"content":"我们知道，如今流行的前端框架都是 SPA(单页应用)，在投入生产时会出现中首屏加载慢，不利于 SEO 等问题。于是，现代前端同构框架应运而生。Next.js 是 React 的同构框架，它的页面由 React 组件构成。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:0:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"路由系统 Next.js 的路由系统基于文件路径自动映射，一般约定在根目录的 pages 文件夹内： pages/index.js –\u003e / pages/about.js –\u003e /about pages/blog/[slug].js –\u003e /blog/:slug( slug 是动态生成的) pages/post/[...all].js–\u003e /post/*(匹配 /post,/post/a,/post/a/b 等) Next.js 创建的是多页应用，pages 内的每个文件都是单个页面。Next.js 中用形如 [params] 文件(文件夹)表示动态路由页面。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:1:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"路由跳转 Next.js 中路由跳转方式有两种，使用的 api 分别是 next/link 和 next/router。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"next/link 从 next/link 导入的 \u003cLink\u003e 是 React 组件，可接收以下属性: href 是导航到的路径，是页面跳转的必需属性，href 可以是字符串或者对象 \u003cLink href=\"/about?name=jackylin\"\u003e\r//这里 href 有两层 {}, github page 无法识别语法，只能写为一层了\r\u003cLink href={ pathname: \"/about\", query: { name: \"jackylin\" },}\u003e\r as 是浏览器 url 栏显示的路径，当 href 中包含动态页面 ([param]) 时使用 const pids = ['id1', 'id2', 'id3']\r{\rpids.map((pid, index) =\u003e (\r\u003cLink href='/post/[pid]' as={`/post/${pid}`} key='index'\u003e\r\u003ca\u003ePost {pid}\u003c/a\u003e\r\u003c/Link\u003e\r))}\r passHref 将 \u003cLink\u003e 的 href 传递给子项，当子项是包装 \u003ca\u003e 的组件时，此属性必需 prefetch 预加载，将页面提前加载到本地缓存 官方文档还有一些其他 属性 和用法示例，需要注意的是 \u003cLink\u003e 只能有一个子项。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"next/router 相较于 next/link，next/router 能自定义配置复杂的路由跳转。next/router 提供如下 api： useRouter 是 React hook，只能用于函数组件 withRouter 是高阶组件，可用于类组件和函数组件 他们的实例对象 router 具有以下的属性，方法，事件等。 属性：pathname 是文件名，query 是查询参数，asPath 是浏览器中显示的路径。 方法：router.push(url, as, options) 是路由跳转方法，跳转的页面路径(url)必需。url 可以是字符串形式，也可以是对象形式。在需路由跳转的元素上绑定点击事件。 export default function ReadPost({ post }) {\rconst router = useRouter()\rreturn (\r\u003cspan\ronClick={() =\u003e {\rrouter.push({\rpathname: '/post/[pid]',\rquery: { pid: post.id },\r})\r}}\r\u003e\r查看文章\r\u003c/span\u003e\r)\r}\r 对比前面讲的 \u003cLink\u003e 组件，能看出 \u003cLink\u003e 组件其实是封装了 router，点击事件等。 事件：Next.js 在路由跳转的生命周期内置了一些的钩子事件，若我们有监听路由变化的需求，可订阅这些钩子事件来实现需求。具体用法请参阅 官方文档。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"路由传参 Next.js 支持查询字符串格式的参数传递，参数以字符串或者对象的格式传递: \u003cLink\u003e 的 href 属性或者 router.push 中的 url。参数的接收可以用 useRouter 或 withRouter: // router 直接读取参数\rconst Post = () =\u003e {\rconst router = useRouter();\rreturn (\r\u003cdiv\u003e文章编号：{router.query.pid}\u003c/div\u003e\r)\r}\rexport default Post\r //使用 withRouter 接收参数时，router 作为组件参数\rconst Post = ({ router }) =\u003e {\rreturn (\r\u003cdiv\u003e文章编号：{router.query.pid}\u003c/div\u003e\r)\r}\rexport default withRouter(Post)\r ","date":"2020-09-29","objectID":"/2020-09-29-next/:2:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"获取数据 Next.js 中获取数据的方法有 getServerSideProps，getStaticProps 和 getStaticPaths。还有一个 getInitialProps，官方文档已不推荐使用。这些方法都是服务端的异步方法，只能在 pages 文件夹内使用。 Next.js 有两种预渲染形式： 服务端渲染(SSR)：html 在每次访问路由时都会重新生成。对应的数据获取方法：getServerSideProps。由于“服务端渲染”比“静态生成”慢，因此常用于数据频繁更新的页面。 静态生成(SSG)：html 是在构建时生成的，并且会在每次请求时重用。对应的数据获取方法： getStaticProps 和 getStaticPaths。这对于可以在用户请求之前就预渲染的页面非常有用，可以将其与客户端渲染结合使用以引入其他数据。 Next.js 引入了自动静态优化的功能，就是说如果页面中没有使用 SSR 方法，Next.js 在 build 阶段就会生成 html，访问页面路由直接返回生成的 html，以此来提升性能。 选择 SSR 还是 SSG？ 如果页面内容真动态(例如来源数据库且经常变化)，使用 SSR。 如果是静态页面或者伪动态(来源数据库但是不变化)，使用 SSG。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"getServerSideProps 在数据频繁更新的页面使用，每次访问路由时都会调用。getServerSideProps 方法是升级了 9.3 之前的 getInitialProps 方法。 const Blog = ({ data }) =\u003e {\rreturn \u003cdiv\u003etitle: {data.title}\u003c/div\u003e\r}\r// 在每次页面请求时才会运行，在构建时不运行。\rexport async function getServerSideProps() {\rconst res = await fetch('https://jsonplaceholder.typicode.com/todos/1')\rconst data = await res.json()\rreturn { props: {data} }\r}\rexport default Blog\r ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"getStaticProps 页面内容取决于外部数据时使用。 // posts 依赖外部数据\rconst Blog = ({ posts }) =\u003e {\rreturn \u003cdiv\u003etitle: {posts.title}\u003c/div\u003e\r}\r// 此函数只在构建时被调用一次，后面不会再次调用\rexport async function getStaticProps() {\r// 调用外部 API 获取内容\r const res = await fetch('https://jsonplaceholder.typicode.com/todos/1')\rconst posts = await res.json()\r// 在构建时将接收到 `posts` 参数\r return {\rprops: {\rposts,\r},\r}\r}\rexport default Blog\r ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"getStaticPaths 页面路径取决于外部数据时使用，结合 getStaticProps 使用。 const Post = ({ post }) =\u003e {\rreturn (\r\u003cdiv\u003e文章id: {post.id}, 文章标题: {post.title}\u003c/div\u003e\r)\r}\r// 此函数只在构建时被调用一次，后面不会再次调用\rexport async function getStaticPaths() {\r// 取全部文章数据\r const res = await fetch('https://jsonplaceholder.typicode.com/todos')\rconst posts = await res.json()\rconst paths = posts.map(post =\u003e `/posts/${post.id}`)\r// fallback为 false，表示不在 getStaticPaths 的路径是 404 页面。\r return { paths, fallback: false }\r}\r// params 来自 paths: [{ params: { ... } }]\rexport async function getStaticProps({ params }) {\r// 取具体文章数据\r const res = await fetch(`https://jsonplaceholder.typicode.com/todos/${params.id}`)\rconst post = await res.json()\rreturn { props: { post } }\r}\rexport default Post\r api 的更多细节用法请阅读 官方文档。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:3:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"其他功能 ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:0","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"自定义配置 Next.js 在 pages 文件夹内的默认配置文件有 _app.js,_document.js,404.js 等。 以 _app.js 为例，它的功能是初始化当前路由的页面组件，接口如下： /**\r* Component 是当前路由的页面组件，每次路由切换时，Component 都会更新\r* pageProps 是初始属性，该初始属性由某个数据获取方法预先加载到你的页面中，否则它将是一个空对象\r*/\rfunction MyApp({ Component, pageProps }) {\rreturn \u003cComponent {...pageProps} /\u003e\r}\rexport default MyApp\r 比如我们要使用 recoil 进行状态管理，所有页面组件都应该为 \u003cRecoilRoot\u003e 的子组件。 import { RecoilRoot } from 'recoil'\rexport default function MyApp({ Component, pageProps }) {\rreturn (\r\u003cRecoilRoot\u003e\r\u003cComponent {...pageProps} /\u003e\r\u003c/RecoilRoot\u003e\r)\r}\r 其他配置文件的作用请阅读 官方文档。 ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:1","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"自定义构建 Next.js 根目录 next.config.js 可配置项目构建。例如扩展默认 webpack 配置，接口如下： module.exports = {\rwebpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) =\u003e {\r// Note: we provide webpack above so you should not `require` it\r config.plugins.push(new webpack.IgnorePlugin(/\\/__tests__\\//))\r// Important: return the modified config\r return config\r},\r}\r 例如在 Next.js 默认的 babel 配置中添加一个 loader： // https://github.com/vercel/next.js/tree/canary/packages/next-mdx\rmodule.exports = {\rwebpack: (config, options) =\u003e {\rconfig.module.rules.push({\rtest: /\\.mdx/,\ruse: [\roptions.defaultLoaders.babel,\r{\rloader: '@mdx-js/loader',\roptions: pluginOptions.options,\r},\r],\r})\rreturn config\r},\r}\r ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:2","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":"api 路由 Next.js 提供简单的后端 api 能力，在 pages/api 内的文件都将映射为 /api/* 的后端接口。它们不会和页面一起打包。 // pages/api/post.js\r\rimport {getPosts} from 'lib/posts'\rconst Posts = async (req, res) =\u003e {\rconst posts = await getPosts()\rres.statusCode = 200\rres.setHeader('Content-Type', 'application/json')\rres.end(JSON.stringify(posts))\r}\rexport default Posts\r 目前 Next.js 没有提供数据库和测试相关的功能，需自行配置或与其他框架配合使用。 参考资料 Next.js 官方文档 Next.js 简明教程 手把手带你入门 NextJs ","date":"2020-09-29","objectID":"/2020-09-29-next/:4:3","tags":["Next.js","React"],"title":"Next.js 概览","uri":"/2020-09-29-next/"},{"categories":["Coding"],"content":" 在计算机科学中，函数式编程是一种编程范式，其中通过应用和组合函数来构造程序。它是一种声明式编程范式，其中函数定义是每个返回一个值的表达式树，而不是一系列更改程序状态的命令性语句。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:0:0","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"声明式与命令式 假设我们有个需求：把下面字符串变成每个单词首字母大写。 var string = 'functional programming is great';\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:0","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"命令式 如果你没有听说过函数式编程，用传统的编程思路，很自然的写出如下 命令式编程 代码： var string = 'functional programming is great';\rvar arrays = string.split(' ');\rvar newArray = [];\rfor (var i = 0; i \u003c arrays.length; i++){\rvar str = arrays[i].slice(0, 1).toUpperCase() + arrays[i].slice(1);\rnewArray.push(str);\r}\rvar newString = newArray.join(' ');\r 这样当然能完成任务，结果是产生了一堆临时变量。光是变量名就不好想，同时过程中掺杂了大量逻辑，一个函数需要从头读到尾才知道它具体做了什么，并且一旦出问题很难定位。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:1","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"声明式 声明式编程 被看做是形式逻辑的理论，把计算看做推导。常见的声明式编程有数据库查询(SQL语句)，正则表达式，函数式编程等。函数式编程倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 var string = 'functional programming is great';\rvar newString = string\r.split(' ')\r.map(str =\u003e str.slice(0, 1).toUpperCase() + str.slice(1))\r.join(' ');\r 函数式编程的核心思想：通过函数转换数据，组合多个函数来求结果。 对比两种编程思想：命令式编程考虑我该如何做，而声明式编程考虑我要做什么。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:1:2","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"核心概念-纯函数 函数式编程中的“函数”指满足以下特性的函数，也被称为 纯函数： 输出仅取决于输入(无状态，每次的执行结果都是可预测和易测试的) 不产生副作用(只计算输出值，不修改输入值，不做其他任何操作) 因此纯函数更像数学中的函数，只是描述输入与输出之间映射关系的表达式。 一个典型的纯函数设计是 redux 中的 reducer。好的我懂了，但是为什么要强调纯函数呢？因为纯函数的特性决定了它的众多优点： ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:0","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"易读易推理 纯函数容易阅读和推理，因为所有依赖关系都由参数提供。这意味着我们只需阅读函数的声明即可快速了解函数的作用及其依赖关系，而不用担心函数内有其他行为(副作用)。 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:1","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"移植性 对于常见的普通函数，同一函数不能直接在移植到别的上下文中使用，通常会为了实现同一类功能而编写不同的函数。 // 普通函数\rvar signUp = function(attrs) {\rvar user = saveUser(attrs);\rwelcomeUser(user);\r};\r// 依赖 Db\rvar saveUser = function(attrs) {\rvar user = Db.save(attrs);\r...\r};\r// 依赖 Email\rvar welcomeUser = function(user) {\rEmail(user, ...);\r...\r};\r 编写纯函数的好处是它需要的东西都在输入参数中已经声明，所以它方便移植到别的地方，因为它的依赖关系是很清晰的。 // 纯函数\rvar signUp = function(Db, Email, attrs) {\rreturn function() {\rvar user = saveUser(Db, attrs);\rwelcomeUser(Email, user);\r};\r};\rvar saveUser = function(Db, attrs) {\r...\r};\rvar welcomeUser = function(Email, user) {\r...\r};\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:2","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"引用透明性 因为纯函数内部没有全局引用，所以在任何使用纯函数的地方中把纯函数替换成它的执行结果，都不会对程序的整体运行产生影响，不会产生隐性问题。 const greet = (name) =\u003e {\rreturn `hello, ${name}`;\r};\rconsole.log(greet('beijing'));\r// 可做如下等价替换\rconsole.log('hello, beijing');\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:3","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"可缓存 纯函数对相同输入总有相同输出，可以根据输入来做缓存，相同的输入可以不做重新计算。 // 下面的代码我们可以发现相同的输入，再第二次调用的时候都是直接取的缓存\rlet squareNumber = memoize((x) =\u003e { return x*x; });\rsquareNumber(4);\r//=\u003e 16\rsquareNumber(4); // 从缓存中读取输入值为 4 的结果\r//=\u003e 16\rsquareNumber(5);\r//=\u003e 25\rsquareNumber(5); // 从缓存中读取输入值为 5 的结果\r//=\u003e 25\r 这是怎么实现的呢? 请看下面的代码: const memoize = (f) =\u003e {\r// 由于使用了闭包，所以函数执行完后 cache 不会立刻被回收\r const cache = {};\rreturn () =\u003e {\rvar arg_str = JSON.stringify(arguments);\r// 利用 cache 做一个简单的缓存，当这个参数之前使用过时，我们立即返回结果就行\r cache[arg_str] = cache[arg_str] || f.apply(f, arguments);\rreturn cache[arg_str];\r};\r};\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:4","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"并行处理 纯函数不会访问共享的内存，因此不用担心线程的执行顺序，对任何纯表达式的求值都是线程安全的。 var x = f(a);\rvar y = g(b);\rvar z = h(c);\r// 线程安全\rvar result = x + y + z;\r 前三个表达式之间没有数据依赖关系，它们的执行顺序可以颠倒，或者并行执行也互不干扰。只要它们能在分配给 result 之前执行。 说了这么多优点，其实纯函数的优秀的原因是因为它不使用全局引用： 大神语录 Shared mutable state is the root of all evil(共享的可变状态是万恶之源) – Pete Hunt ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:2:5","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"应用和组合函数 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:0","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"高阶函数 在数学和计算机科学中，高阶函数 是至少执行以下一项的函数： 将一个或多个函数作为参数(即过程参数) 返回一个函数作为其结果 ES6 中常用的高阶函数包括：map，filter，reduce，find，some，every 等。 // 数组求和\rconst arr = [5, 7, 1, 8, 4];\r// 不使用高阶函数\rlet sum = 0;\rfor (let i = 0; i \u003c arr.length; i++) {\rsum = sum + arr[i];\r}\rconsole.log(sum); //25\r\r// 使用高阶函数\rconst sum = arr.reduce((accumulator, currentValue) =\u003e accumulator + currentValue,0);\rconsole.log(sum); //25\r\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:1","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"闭包 通常情况下我们说的 闭包 指的是函数内部的函数。闭包的形成条件： 存在内、外两层函数 内层函数对外层函数的局部变量进行了引用 闭包的用途：定义一些作用域局限的持久化变量，这些变量可用来做缓存或者计算的中间量等。 闭包的弊端：持久化变量不会被正常释放，持续占用内存造成内存浪费，所以需要额外的手动清理机制。 // 匿名函数创造了一个闭包，实现简单的缓存工具\rconst cache = (function() {\rconst store = {};\rreturn {\rget(key) {\rreturn store[key];\r},\rset(key, val) {\rstore[key] = val;\r}\r}\r}());\rconsole.log(cache) //{get: ƒ, set: ƒ}\rcache.set('a', 1);\rcache.get('a'); // 1\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:2","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"柯里化 柯里化 是一种将多参函数拆解为多个单参函数序列的技术。 function curryIt(fn) {\r// 参数fn函数的参数个数\r var n = fn.length;\rvar args = [];\rreturn function(arg) {\rargs.push(arg);\rif (args.length \u003c n) {\rreturn arguments.callee; // 返回这个函数的引用\r } else {\rreturn fn.apply(this, args);\r}\r};\r}\rfunction add(a, b, c) {\rreturn [a, b, c];\r}\r// c 是内部匿名函数\rvar c = curryIt(add); // 可以分步传参\rvar c1 = c(1); // 将 1 加入 args 中，返回 c 的引用\rvar c2 = c1(2); var c3 = c2(3); // [1, 2, 3]\r\r// 也可以直接调用\rvar c3 = c(1)(2)(3); // [1, 2, 3]\r 可以看出，柯里化是一种函数的“预加载”技术，可以通过闭包实现对参数的缓存。 类似的概念有将多参函数拆解为任意参数个数的部分函数应用： // Currying f(a)(b)(c)\rvar f = a =\u003e b =\u003e c =\u003e a + b + c;\r// Partial application f(a)(b,c) var f = a =\u003e (b, c) =\u003e a + b + c;\r ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:3","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"函数组合 柯里化是函数的拆解，函数组合就是多个函数组合为一个函数。compose 简单实现： var compose = (f, g) =\u003e x =\u003e f(g(x));\rvar g = x =\u003e x + 1;\rvar f = x =\u003e x * 5;\rvar fg = compose(f, g); fg(2); // 15\r 我们要合成的函数可能不止两个，更通用的 compose 实现： function compose(...args) {\rreturn function(x) {\rvar composeFun = args.reduceRight(function(first, second) {\r//从右边开始迭代，这里实际是把右边放入左边\r return second(first); }, x);\rreturn composeFun;\r}\r};\r// 简化为箭头函数\rvar compose = (...args)=\u003e(x)=\u003e args.reduceRight((f,s)=\u003es(f),x);\r 现在我们可以自由组合函数： function addHello(str){\rreturn 'hello ' + str;\r}\rfunction toUpperCase(str) {\rreturn str.toUpperCase();\r}\rfunction reverse(str){\rreturn str.split('').reverse().join('');\r}\rvar composeFn=compose(reverse,toUpperCase,addHello);\rcomposeFn('ttsy'); // YSTT OLLEH\r 最后，软件工程没有银弹。每种编程范式各有利弊，我们要根据实际需求选择合适的编程范式。 参考资料 维基百科 JavaScript函数式编程入门经典 ","date":"2020-09-02","objectID":"/2020-09-02-js-functional/:3:4","tags":["JavaScript"],"title":"浅析 JS 函数式编程","uri":"/2020-09-02-js-functional/"},{"categories":["Coding"],"content":"如果你想了解 Javascript 的编译原理，那么你就得了解 AST(Abstract Syntax Tree)，目前前端常用的一些插件或者工具，比如 JS 转译、代码压缩、CSS 预处理器、ESLint、Prettier 等功能的实现，都是建立在 AST 的基础之上的。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:0:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"JS 编译流程 首先是 JS 引擎读取 JS 文件中的字符流，然后通过 词法分析 生成 tokens，之后再通过 语法分析 生成 AST，最终 JS 引擎将 AST 编译成字节码或机器码，然后再运行。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"词法分析 词法分析，也称为扫描(scanner)，简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的 Token。Token 是 JS 代码在语法含义上不可分割的最小单元。除此之外，还会过滤掉源程序中的注释和空白字符(换行符、空格、制表符等)。 最终，整个代码被分割进一个 tokens 的数组中。如下代码： const href = 'https://github.com/'\r 经过词法分析生成类似这样的 tokens： [\r{\r\"type\": \"Keyword\",\r\"value\": \"const\"\r},\r{\r\"type\": \"Identifier\",\r\"value\": \"href\"\r},\r{\r\"type\": \"Punctuator\",\r\"value\": \"=\"\r},\r{\r\"type\": \"String\",\r\"value\": \"'https://github.com/'\"\r}\r]\r ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:1","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"语法分析 语法分析会将词法分析出来的 tokens 转化成有语法含义的 AST 结构。同时，验证语法，如果语法有错，抛出语法错误。 {\r\"type\": \"Program\",\r\"body\": [\r{\r\"type\": \"VariableDeclaration\",\r\"declarations\": [\r{\r\"type\": \"VariableDeclarator\",\r\"id\": {\r\"type\": \"Identifier\",\r\"name\": \"href\"\r},\r\"init\": {\r\"type\": \"Literal\",\r\"value\": \"https://github.com/\",\r\"raw\": \"'https://github.com/'\"\r}\r}\r],\r\"kind\": \"const\"\r}\r],\r\"sourceType\": \"script\"\r}\r 这里 可以看到代码的转换。这里 有 tokens 和 AST 的简单 JS 实现。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:1:2","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"AST 节点规范 业界已经有很多成熟的解析库，常用的库都集成在 AST Explorer 中，可以实现代码与符合 The ESTree Spec 的 AST 之间的相互转换。下面对规范里的 ES5 的 API 做简要说明。 ESTree AST 中每个节点都要实现以下的 Node 接口，loc 字段表示相关代码的位置信息： interface Node {\rtype: string;\rloc?: SourceLocation;\r}\rinterface SourceLocation {\rsource: string | null;\rstart: Position;\rend: Position;\r}\rinterface Position {\rline: number; // \u003e= 1\r column: number; // \u003e= 0\r}\r ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Programs 根节点 interface Program \u003c: Node {\rtype: \"Program\";\rbody: [ Statement ];\r}\r AST 的顶部， body 包含了多个 Statement(语句)节点。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:1","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Patterns 模式 interface Pattern \u003c: Node { }\r 在 ES6 的解构赋值中有意义，如 let {name} = user，其中{name}部分为 ObjectPattern, 对于 ES5，唯一的子类是 Identifier ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:2","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Expression 表达式 interface Expression \u003c: Node { }\r 表达式，子类很多，有二元表达式(n*n)、函数表达式(var fun = function(){})、数组表达式(var arr = [])、对象表达式(var obj = {})、赋值表达式( a=1)等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:3","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Identifier 标识符 interface Identifier \u003c: Expression, Pattern {\rtype: \"Identifier\";\rname: string;\r}\r 写代码时自定义的名称，如变量名，函数名，属性名等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:4","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Literal 字面量 interface Literal \u003c: Expression {\rtype: \"Literal\";\rvalue: string | boolean | null | number | RegExp;\r}\r 从 value 的类型可以看出，字面量就是值，他的类型有字符串，布尔，数值，null 和正则。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:5","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Statement 语句 interface Statement \u003c: Node { }\r 语句，子类有很多， 块语句、 if/switch语句、 return语句、 for/while语句、 with语句等。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:6","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Declaration 声明 interface Declaration \u003c: Statement { }\r 声明，子类主要有变量申明、函数声明。 ES6，7，8，… 的更多类型补充可以看这一篇 文章。 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:2:7","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"AST 的运用 将原代码转化为 AST，修改 AST，再重新转化为新代码就能完成代码转译。Babel 将最新语法的 JS 代码转化为 ES5 的原理就是这样的。 \rBabel 操作 AST 会用到以下工具包： @babel/parser 用于将代码转换为 AST @babel/traverse 用于对 AST 的遍历，包括节点增删改查、作用域等处理 @babel/generator 用于将 AST 转换成代码 @babel/types 用于 AST 节点操作的 Lodash 式工具库,各节点构造、验证等 更多api详见 Babel手册。 下面是用一个例子讲述具体操作步骤： var obj = {\rfn(){\rconsole.log(\"hello\")\r}\r}\r 我们需要把以上代码转换成下面这样： const obj = {\rfn(){\rconsole.log(\"hello\",\"world\")\r}\r}\r 将两份代码在 AST Explorer 中打开。选择 @babel/parser 为解析器，右边有选项隐藏不需要的属性。对比两颗 AST 发现差异是 kind 和 arguments，因此代码如下： const parser = require(\"@babel/parser\");\rconst traverse = require(\"@babel/traverse\").default;\rconst generate = require(\"@babel/generator\").default;\rconst t = require(\"@babel/types\");\rlet sourceCode = `\rvar obj = {\rfn(){\rconsole.log(\"hello\")\r}\r}\r`\rlet ast = parser.parse(sourceCode);\rtraverse(ast, {\rVariableDeclaration(path) {\rlet { kind } = path.node\rif (kind === \"var\") {\rkind = \"const\"\r}\r},\rCallExpression(path) {\rlet { callee, arguments } = path.node\rif (t.isMemberExpression(callee) \u0026\u0026 callee.object.name === \"console\" \u0026\u0026 callee.property.name === \"log\") {\rarguments.push(t.stringLiteral(\"world\"))\r}\r}\r})\rconsole.log(generate(ast).code);\r 这里 还有更多例子。 参考资料 JS之 执行过程 JS 语法树学习 Javascript抽象语法树 ","date":"2020-08-23","objectID":"/2020-08-23-ast/:3:0","tags":["AST","JavaScript"],"title":"入门 AST 抽象语法树","uri":"/2020-08-23-ast/"},{"categories":["Coding"],"content":"Webpack 是一个前端构建工具，前端构建工具的作用就是把开发环境的代码转化成运行环境代码。一般来说，开发环境的代码是为了更好的阅读，而运行环境的代码则是为了能够更快地执行。因此开发环境和运行环境的代码形式也不相同。比如，开发环境的代码，要通过混淆压缩后才能放在线上运行，这样代码体积更小，但对代码执行不会有任何影响。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:0:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"应用场景 一般的构建工具可以处理但不限于以下场景： 代码压缩 将 JS、CSS 代码混淆压缩，让代码体积更小，加载更快。 语法编译 编写CSS时使用 Less、Sass，编写 JS 时使用 ES6、TypeScript 等，这些标准目前都无法被浏览器兼容，因此需要构建工具编译，例如使用 Babel 编译 ES6 语法。 模块化处理 CSS 和 JS 的模块化语法，目前无法被浏览器兼容。因此开发环境可以使用既定的模块化语法，但是需要构建工具将模块化语法编译为浏览器可识别形式。例如使用 Webpack、Rollup 等处理 JS 模块化。 使用 webpack，构建的前端项目是高度可配置的(替换 react，vue 默认 cli 工具)。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:1:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"核心概念 以下概念提取自 webpack 的官方文档，学习更多细节请参阅官方文档。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Entry 入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。 进入入口起点后, webpack 会找出有哪些模块和库是入口起点(直接和间接)依赖的。 每个依赖项随即被处理,最后输出到称之为 bundles 的内存文件中。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:1","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Output output 属性指定 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。 基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:2","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Module 模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:3","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Chunk 代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:4","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Loader loader 让 webpack 能够去处理那些非 JS 文件(webpack 自身只理解 JS)。 loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。 本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图(和最终的 bundle)可以直接引用的模块。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:5","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"Plugin loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。 插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:2:6","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"构建流程 Webpack 在启动后，会从 Entry 开始，递归解析 Entry 依赖的所有 Module，每找到一个 Module，就会根据 Module.rules 里配置的 Loader 规则进行相应的转换处理，对 Module 进行转换后，再解析出当前 Module 依赖的Module，这些 Module 会以 Entry 为单位进行分组，即为一个 Chunk。因此一个 Chunk 就是一个 Entry 及其所有依赖的 Module 合并的结果。最后 Webpack 会将所有的 Chunk 转换成文件输出 Output。在整个构建流程中，Webpack 会在恰当的时机执行 Plugin 里定义的逻辑，从而完成 Plugin 插件的优化任务。 简单的解释就是这样，详细构建流程请看这篇文章。 ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:3:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"配置入门 下面以一个配置一个 react 开发环境为例，学习 webpack 的基本配置方法。 新建文件夹 webpack-demo，终端进入文件夹执行 npm init 初始化项目。 安装 react: yarn add react react-dom 安装 webpack: yarn add webpack webpack-cli webpack-dev-server -D webpack-cli 提供了一组用于运行和设置 webpack 的命令 Webpack-dev-server 提供 http 服务，实时重载(hot模式)，cors 配置，端口配置等 安装 babel: yarn add @babel/core @babel/preset-react @babel/preset-env babel-loader -D @babel/core 是核心依赖项 @babel/preset-react 添加对 JSX 支持 @babel/preset-env 添加对 ES6 的支持 babel-loader 使用 Babel 和 webpack 转换 react 代码为 JS 安装 CSS Loaders: yarn add css-loader style-loader -D css-loader 从收集 CSS 并将 CSS 转化为字符串 style-loader 将从 css-loader 中获得的字符串嵌入在 html 中的 style 标签中 安装插件: yarn add html-webpack-plugin -D html-webpack-plugin 用于将生成的 output 文件嵌入到指定 html 文件 准备文件: 在根文件夹下创建 src 和 dist 文件夹，在 src 文件夹下创建 main.js，app.js，index.css， 在 dist 文件夹下创建 index.html。 创建 webpack.config.js，这是默认的 webpack 配置文件： //webpack.config.js\rconst path = require('path');\rconst HtmlWebpackPlugin = require('html-webpack-plugin');\rmodule.exports = {\rentry: './src/main.js',\routput: {\rpath: path.join(__dirname, '/dist'),\rfilename: 'bundle.js'\r},\rdevServer: {\rport: 8080\r},\rmodule: {\rrules: [\r{\rtest: /\\.jsx?$/,\rexclude: /node_modules/,\rloader: 'babel-loader',\r},\r{\rtest: /\\.css$/,\ruse: ['style-loader', 'css-loader']\r}\r]\r},\rplugins: [\rnew HtmlWebpackPlugin({\rtemplate: './dist/index.html'\r})\r]\r}\r “entry”: 这是入口 js，webpack将从此处开始打包。 “output”: 打包的文件将位于 “/dist/bundle.js”。 “devServer”: 它定义了 weback-dev-server 的配置，开发服务器的默认端口是8080。 模块规则-这些是转译规则： “test”: 正则表达式，指定哪种文件需要通过 loader 转译。 “exclude”: 指定 loader 应忽略的文件。 “use”: 应用 loader 的数组，注意是从右往左加载 loader。 babel 转译的配置文件 .babelrc： {\r\"presets\":[\"@babel/preset-env\", \"@babel/preset-react\"]\r}\r 在 package.json 中添加脚本： \"start\": \"webpack-dev-server --mode development --open --hot\",\r\"build\": \"webpack --mode production\"\r 将创建的空文件补充完整： \u003c!-- dist/index.html --\u003e\r\u003c!DOCTYPE html\u003e\r\u003chtml lang=\"en\"\u003e\r\u003chead\u003e\r\u003cmeta charset=\"UTF-8\"\u003e\r\u003ctitle\u003eReact Web\u003c/title\u003e\r\u003c/head\u003e\r\u003cbody\u003e\r\u003cdiv id=\"root\"\u003e\u003c/div\u003e\r\u003c!-- html-webpack-plugin 插件生成如下标签\r\u003cscript src='bundle.js'\u003e\u003c/script\u003e --\u003e\r\u003c/body\u003e\r\u003c/html\u003e\r // src/main.js\r\rimport React from 'react';\rimport ReactDOM from 'react-dom';\rimport App from './App.js';\rReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\r // src/app.js \rimport React, { Component } from 'react';\rimport './index.css';\rclass App extends Component {\rrender() {\rreturn (\r\u003cdiv\u003e\r\u003ch1\u003eHello!!\u003c/h1\u003e\r \u003ch2\u003eWelcome to your React App..!\u003c/h2\u003e\r \u003c/div\u003e\r );\r}\r}\rexport default App;\r /* src/index.css */\r* {\rmargin: 0;\rpadding: 0;\r}\r 运行代码: yarn start，打包文件: yarn run build，动手试试吧！ 参考资料 webpack 官方文档 webpack打包原理? 看完这篇你就懂了! 实现一个简单的Webpack ","date":"2020-08-16","objectID":"/2020-08-16-webpack/:4:0","tags":["Webpack"],"title":"Webpack 概念梳理","uri":"/2020-08-16-webpack/"},{"categories":["Coding"],"content":"WebSocket 是一种服务端和客户端之间的双向通信协议，和 HTTP 一样是基于 TCP 协议的应用层协议，并且 WebSocket 在握手阶段依赖于 HTTP 连接。 WebSocket 广泛应用于多用户实时交流，服务端数据持续变化的场景。比如社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等需要高实时的场景。 学习 WebSocket，请看这篇教程。在 node.js 中，通常使用 socket.io 这个库。socket.io 封装了 WebSocket 服务端 JS 库，同时也提供客户端的 JS 库。Socket.IO 支持以事件为基础的实时双向通讯。它可以兼容各种浏览器或移动设备，从而让开发者可以聚焦到功能的实现而不是平台的兼容性。 ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:0:0","tags":["WebSocket"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"Socket.IO 常用 api 常用服务端 api： socket.on('eventName', msg =\u003e {}) /*服务器端监听客户端emit的事件，事件名称可以和客户端是重复的，但是并没有任何关联。\rsocket.io内置了一些事件比如connection，disconnect，exit事件*/\rsocket.emit('eventName', msg) //服务端各自的socket向各自的客户端发送数据\r\rsocket.broadcast('eventName', msg) //服务端向其他客户端发送消息，不包括自己的客户端\r\rsocket.join(channel) //创建一个频道（非常有用，尤其做分频道的时候，比如斗地主这种实时棋牌游戏）\r\rio.sockets.in(channel) //加入一个频道\r\rio.to(channel).emit('eventName', msg)\r//向一个频道发送消息，包括自己的客户端\r\rsocket.broadcast.to(channel).emit('eventName', msg) //向一个频道发送消息，不包括自己的客户端\r\rio.emit('eventName', msg)\r//向所有客户端发送数据\r\rio.sockets.adapter.rooms //获取所有的频道\r 常用客户端 api： //客户端\r io.connect(url) //客户端连接上服务器端，可简写为 io(url)，无跨域时为 io()\r\rsocket.on('eventName', msg =\u003e {}) //客户端监听服务器端事件\r\rsocket.emit('eventName', msg) //客户端向服务器端发送数据\r\rsocket.disconnect() //客户端断开链接\r 更多的 api 请参阅 Socket.IO 的官方文档。这里有一篇搭建实时聊天室的文章，注意文中的 index.html 和 client.js 中的线上服务器地址 realtime.plhwin.com:3000 已经没有了，改为本地地址 localhost:3000 就能运行代码了。index.html 里的 \u003cscript src=\"/socket.io/socket.io.js\"\u003e\u003c/script\u003e\r 指向的文件是其实是 \u003cscript src=\"../server/node_modules/socket.io-client/dist/socket.io.js\"\u003e\u003c/script\u003e\r 整体的开发思路就是服务端和客户端其中一端触发事件，另一端就监听事件。文中的示例程序只用到了事件触发 socket.emit 和事件监听 socket.on。下文的示例程序展示了 Socket.IO 中更多 api 的用法。用户进入聊天室时需要选择房间，进入相同房间的用户才能内部交流，不同房间之间的内部信息不能互通。 \r","date":"2020-08-11","objectID":"/2020-08-11-websocket/:1:0","tags":["WebSocket"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"服务端实现 WebSocket 依赖于 http，这里需要安装 socket.io 和 express // server.js\r\rconst path = require('path');\rconst http = require('http');\rconst express = require('express');\rconst socketio = require('socket.io');\rconst formatMessage = require('./utils/messages');\rconst {\ruserJoin,\rgetCurrentUser,\ruserLeave,\rgetRoomUsers\r} = require('./utils/users');\rconst app = express();\rconst server = http.createServer(app);\rconst io = socketio(server);\r// Set static folder\rapp.use(express.static(path.join(__dirname, 'public')));\rconst botName = 'ChatCord Bot';\r// Run when client connects\rio.on('connection', socket =\u003e {\rsocket.on('joinRoom', ({ username, room }) =\u003e {\rconst user = userJoin(socket.id, username, room);\rsocket.join(user.room);\r// Welcome current user\r socket.emit('message', formatMessage(botName, 'Welcome to ChatCord!'));\r// Broadcast when a user connects\r socket.broadcast\r.to(user.room)\r.emit(\r'message',\rformatMessage(botName, `${user.username}has joined the chat`)\r);\r// Send users and room info\r io.to(user.room).emit('roomUsers', {\rroom: user.room,\rusers: getRoomUsers(user.room)\r});\r});\r// Listen for chatMessage\r socket.on('chatMessage', msg =\u003e {\rconst user = getCurrentUser(socket.id);\rio.to(user.room).emit('message', formatMessage(user.username, msg));\r});\r// Runs when client disconnects\r socket.on('disconnect', () =\u003e {\rconst user = userLeave(socket.id);\rif (user) {\rio.to(user.room).emit(\r'message',\rformatMessage(botName, `${user.username}has left the chat`)\r);\r// Send users and room info\r io.to(user.room).emit('roomUsers', {\rroom: user.room,\rusers: getRoomUsers(user.room)\r});\r}\r});\r});\rconst PORT = process.env.PORT || 3000;\rserver.listen(PORT, () =\u003e console.log(`Server running on port ${PORT}`));\r ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:2:0","tags":["WebSocket"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"客户端实现 需要先在 html 中引入 socket.io-client，才能使用 io \u003c!-- public/chat.html --\u003e\r\u003cscript src=\"/socket.io/socket.io.js\"\u003e\u003c/script\u003e\r\u003cscript src=\"js/main.js\"\u003e\u003c/script\u003e\r 这里的静态资源文件是由 express 加载的，没有跨域，可省略 io 括号里的地址 // public/js/main.js\r\rconst chatForm = document.getElementById('chat-form');\rconst chatMessages = document.querySelector('.chat-messages');\rconst roomName = document.getElementById('room-name');\rconst userList = document.getElementById('users');\r// Get username and room from URL\rconst { username, room } = Qs.parse(location.search, {\rignoreQueryPrefix: true\r});\rconst socket = io();\r// Join chatroom\rsocket.emit('joinRoom', { username, room });\r// Get room and users\rsocket.on('roomUsers', ({ room, users }) =\u003e {\routputRoomName(room);\routputUsers(users);\r});\r// Message from server\rsocket.on('message', message =\u003e {\rconsole.log(message);\routputMessage(message);\r// Scroll down\r chatMessages.scrollTop = chatMessages.scrollHeight;\r});\r// Message submit\rchatForm.addEventListener('submit', e =\u003e {\re.preventDefault();\r// Get message text\r const msg = e.target.elements.msg.value;\r// Emit message to server\r socket.emit('chatMessage', msg);\r// Clear input\r e.target.elements.msg.value = '';\re.target.elements.msg.focus();\r});\r// Output message to DOM\rfunction outputMessage(message) {\rconst div = document.createElement('div');\rdiv.classList.add('message');\rdiv.innerHTML = `\u003cp class=\"meta\"\u003e${message.username}\u003cspan\u003e${message.time}\u003c/span\u003e\u003c/p\u003e\r\u003cp class=\"text\"\u003e\r${message.text}\u003c/p\u003e`;\rdocument.querySelector('.chat-messages').appendChild(div);\r}\r// Add room name to DOM\rfunction outputRoomName(room) {\rroomName.innerText = room;\r}\r// Add users to DOM\rfunction outputUsers(users) {\ruserList.innerHTML = `\r${users.map(user =\u003e `\u003cli\u003e${user.username}\u003c/li\u003e`).join('')}`;\r}\r 更多内容请看源码。 附：源码地址 参考资料 WebSocket 教程 Socket.IO 官方文档 ChatCord 源码 ","date":"2020-08-11","objectID":"/2020-08-11-websocket/:3:0","tags":["WebSocket"],"title":"基于 Socket.IO 的实时聊天室","uri":"/2020-08-11-websocket/"},{"categories":["Coding"],"content":"最近，Facebook 官方开源了一个状态管理库 Recoil，我们来学习一下。Recoil 是基于 Immutable 的数据流管理方案，这是它值得学习的重要原因。Recoil非常易于学习，它的 API 简单强大，对于已经习惯使用 hooks 的人来说很自然。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:0:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"核心概念 Recoil 中的核心概念只有 Atom(原子状态) 和 Selector(派生状态)。 \r","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"Atom Atom 是状态的单位。它们可更新也可订阅。当 atom 被更新，每个被订阅的组件都将使用新值进行重渲染。如果多个组件使用相同的 atom，则这些组件共享 atom 的状态。可以使用 atom 替代组件内部的 state。atom 也可以在运行时创建。 Atom 是使用 atom 函数创建的： function atom\u003cT\u003e({\rkey: string,\rdefault: T | Promise\u003cT\u003e | RecoilValue\u003cT\u003e,\rdangerouslyAllowMutability?: boolean,\r}): RecoilState\u003cT\u003e\r key：标识 atom 的字符串，必须相对于其他 atom/selector 是唯一值 default：atom 的初始值，可以是静态值，Promise，或返回值类型相同的另一个 atom/seletor 最后一个参数是允许 Mutable，由于 Recoil 默认的 Immutable 特性带来的可预测性更利于调试和维护，一般不设置这个值 定义一个 atom，用来获取输入字符: const textState = atom({\rkey: 'textState', // unique ID (with respect to other atoms/selectors)\r default: '', // default value (aka initial value)\r});\r ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:1","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"Selector selector 是一个纯函数，入参为 atom 或其他 selector。selector 被用于计算基于 atom 的派生数据，这使得我们避免了冗余 state，将最小粒度的状态存储在 atom 中，而其它所有内容根据最小粒度的状态进行有效计算。当上游 atom/selector 更新时，将重新执行 selector 函数。组件可以像 atom 一样订阅 selector，当 selector 发生变化时，重新渲染相关组件。 Selector 是使用 selector 函数创建的： function selector\u003cT\u003e({\rkey: string,\rget: ({\rget: GetRecoilValue\r}) =\u003e T | Promise\u003cT\u003e | RecoilValue\u003cT\u003e,\rset?: (\r{\rget: GetRecoilValue,\rset: SetRecoilState,\rreset: ResetRecoilState,\r},\rnewValue: T | DefaultValue,\r) =\u003e void,\rdangerouslyAllowMutability?: boolean,\r}): RecoilValueReadOnly\u003cT\u003e | RecoilState\u003cT\u003e\r type ValueOrUpdater\u003cT\u003e = T | DefaultValue | ((prevValue: T) =\u003e T | DefaultValue);\rtype GetRecoilValue = \u003cT\u003e(RecoilValue\u003cT\u003e) =\u003e T;\rtype SetRecoilState = \u003cT\u003e(RecoilState\u003cT\u003e, ValueOrUpdater\u003cT\u003e) =\u003e void;\rtype ResetRecoilState = \u003cT\u003e(RecoilState\u003cT\u003e) =\u003e void;\r key：标识 selector 的字符串，必须相对于其他 atom/selector 是唯一值 get：get 参数中 get，可以从其他 atom/selector 取值，从而利用依赖关系计算 seletor，传递给此函数的 atom/selector 隐式添加到这个 seletor 的依赖项列表中 set?：设置了该属性，selector 才会返回可写的 state 定义一个 selector，依赖的 atom 是我们上面定义的 textState，用来获取输入字符长度 : const charCountState = selector({\rkey: 'charCountState', // unique ID (with respect to other atoms/selectors)\r get: ({get}) =\u003e {\rconst text = get(textState);\rreturn text.length;\r},\r});\r 测试 atom 和 selector 示例 demo 从组件的角度来看，selector 和 atom 具有相同的功能，因此可以交替使用。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:1:2","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"订阅或更新状态 前面讲述如何用 atom 和 selector 定义 state，下面是 state 的取值和更新函数： useRecoilState：返回 atom/selector 的值和 set 函数，类似 useState。 useRecoilValue：仅返回 atom/selector 的值。 useSetRecoilState：仅返回 atom/seletor 的 set 函数。 useResetRecoilState：重置 atom/selector 到默认值并读取。 在组件中使用这些 hooks 与使用其他 hooks 的方式基本相同： import React from 'react';\rimport { atom, useRecoilState, selector, useRecoilValue } from 'recoil';\rconst textState = atom({\rkey: 'textState', // unique ID (with respect to other atoms/selectors)\r default: '', // default value (aka initial value)\r});\rconst charCountState = selector({\rkey: 'charCountState', // unique ID (with respect to other atoms/selectors)\r get: ({ get }) =\u003e {\rconst text = get(textState);\rreturn text.length;\r},\r});\rexport const CharacterCounter = () =\u003e {\rconst [char, setChar] = useRecoilState(textState);\r// selector 没有定义 set，用 useRecoilValue 取值 const charCount = useRecoilValue(charCountState);\rreturn (\r\u003cdiv\u003e\r\u003cinput\rtype=\"text\"\rvalue={char}\ronChange={(e) =\u003e setChar(e.target.value)}\r/\u003e\r\u003cdiv\u003eEcho: {char}\u003c/div\u003e\r\u003cdiv\u003eCharacter Count: {charCount} \u003c/div\u003e\r\u003c/div\u003e\r);\r};\rexport default CharacterCounter;\r atom，selector 的 state 的取值和更新函数是相同的，selector 未定义 set 只能用 useRecoilValue 取值，定义 set 之后也能用 useRecoilState，因此 atom 应该是基于 selector 的一个特定封装，帮我们封装好了 set，get，而无须自定义。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:2:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"异步支持 在 selector 的数据流图中, Recoil 可以让你随意的混合使用同步和异步函数。只需从 selector get 回调中返回一个 Promise，接口完全一样。因为这些只是 selector，其他的 selector 也可以依赖它们来进一步变更数据。selector 是纯函数，是对只读数据库查询进行建模的好方法，其中重复查询可提供一致的数据。 import React from 'react';\rimport {selector, useRecoilValue} from 'recoil';\rconst myQuery = selector({\rkey: 'MyDBQuery',\rget: async () =\u003e {\rconst response = await fetch(getMyRequestUrl());\rreturn response.json();\r},\r});\rfunction QueryResults() {\rconst queryResults = useRecoilValue(myQuery);\rreturn (\r\u003cdiv\u003e\r{queryResults.foo}\r\u003c/div\u003e\r);\r}\rfunction ResultsSection() {\rreturn (\r\u003cReact.Suspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\r\u003cQueryResults /\u003e\r\u003c/React.Suspense\u003e\r );\r}\r atom 是基于 selector 封装，也支持 Promise 做默认 state。不过官方的建议是当其从其他状态或异步请求时派生的 state，应该使用 selector。 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:3:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"参数查询 有时我们希望通过传递参数动态定义 state，你可以使用 atomFamily 或 selectorFamily 实现这类需求， atom 与 atomFamily，selector 与 selectorFamily 的区别仅仅是定义 state 的时候是否需要参数： const myDataQuery = selectorFamily({\rkey: 'MyDataQuery',\rget: (queryParameters) =\u003e async ({get}) =\u003e {\rconst response = await asyncDataRequest(queryParameters);\rif (response.error) {\rthrow response.error;\r}\rreturn response.data;\r},\r});\rfunction MyComponent() {\rconst data = useRecoilValue(myDataQuery({userID: 132}));\rreturn \u003cdiv\u003e...\u003c/div\u003e;\r}\r 目前 Recoil 还属于实验阶段，能确定的是 Recoil 将兼容 React 并发模式。 我们可以在 Recoil 中学到 React Hook 时代的状态管理的基本模式： state 的读与写分离，做到最优按需渲染。 原子存储的数据相互无关联，关联的数据使用派生值的方式推导。 派生的值必须严格缓存，并在命中缓存时引用保证严格相等。 参考资料 Recoil 官方文档 精读《recoil》 ","date":"2020-07-27","objectID":"/2020-07-27-recoil/:4:0","tags":["Recoil"],"title":"Recoil 基础","uri":"/2020-07-27-recoil/"},{"categories":["Coding"],"content":"权限管理是所有后台系统的都会涉及的一个重要组成部分，主要目的是对不同的人访问资源进行权限的控制，避免因权限控制缺失或操作不当引发的风险问题，如操作错误，隐私数据泄露等问题。 迄今为止最为普及的权限设计模型是RBAC模型,基于角色的访问控制（Role-Based Access Control)，而 RBAC 模型又可以细分为 RBAC0，RBAC1，RBAC2，RBAC3。 本文介绍 RBAC0, 这是权限最基础也是最核心的模型，其他复杂模型也是建立在 RBAC0 之上的。关于 RBAC 还有很多重要理论，具体可参考知乎上的这篇 权限系统设计 和这篇 RBAC理念。本文将带领读者体会 RBAC0 的实践运用，实现 RBAC0 的关键在建立 用户-角色-权限 之间的多对多关系。 \r","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:0:0","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"实例 请注意，本文不涉及具体代码讲解。如需具体代码的讲解，请移步到 后端代码讲解 和 前端代码讲解，在这两篇文章末尾附有源码地址。作者的讲解逻辑严密，注重细节，非常优秀，无需我再赘述。本文只演示实例程序，带领读者理解 RBAC0 权限设计模型。 实例程序将网站用户分为三个角色: Admin(管理员), Moderator(版主), User(普通用户)。 所有页面路由：home, rigister, login, profile, user, mod, admin ","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:0","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"正常访问截图 对所有未登录用户开放的页面(访客页面): home, register, login \r对网站用户开放的页面： 对 User 开放的页面(用户页面)：访客页面, profile, user \r 对 Moderator 开放的页面：用户页面, mod(导航栏中增加 Moderator Board) 对 Admin 开放的页面：用户页面, admin(导航栏中增加 Admin Board) 正常访问其他页面的更多截图看 这里，或者自己运行前后端代码，修改用户角色需用 postman 向后端接口发送 http 请求或者直接修改数据表。 ","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:1","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"越权访问截图 未登录用户访问 user 页面： \rUser 访问 admin 页面： \rUser, Admin 访问 mod 页面, Moderator 访问 admin 页面的显示结果同理。 当一个用户同时具有 User, Moderator, Admin 角色时，就有了所有页面的访问权力。 \r根据用户角色来决定页面的数据，这样就实现了 RBAC0 的基本模型。 参考资料 可能是史上最全的权限系统设计 RBAC理念 实例程序讲解 --","date":"2020-07-13","objectID":"/2020-07-13-rbac0/:1:2","tags":["Node.js"],"title":"RBAC0 权限设计实例","uri":"/2020-07-13-rbac0/"},{"categories":["Coding"],"content":"这次使用 antd 和 TypeScript 实践一个简单 todolist, 为什么又是 todolist？这个问题好比问为什么写代码第一句是 hello world 一样。只是简单的练手，写什么不重要。这次的代码中暂时还没有实现数据持久化，状态管理等，只是把页面上能够看到的功能实现了。后续我将尝试其他的数据流管理方案。 页面长这样，响应 pc 端，移动端: \r页面上有一个搜索框，过滤列表项。点击添加按钮，弹出会话框，添加列表数据。下面是三个标签选项，点击不同的标签显示不同的列表内容。列表中每一项中的三个图标分别实现的是编辑数据，修改完成状态和删除这一项的功能。 这个 todolist 实例只实现了 Todo，ModalForm(对话框)，TodoList(标签选项下的列表) 组件。ModalForm，TodoList 是 Todo 的子组件。这三个组件就足够完成上述的功能了。 ","date":"2020-06-30","objectID":"/2020-06-30-antd/:0:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"定义数据模型 export interface ITodo {\rid: number;\rtext: string;\rdone: boolean;\r}\r ","date":"2020-06-30","objectID":"/2020-06-30-antd/:1:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"状态提升 由于没有引入 redux 状态管理库，为了方便组件间的数据传递，一个比较好的做法是将多个组件需要共享的状态提升到它们最近的父组件上(状态提升)。这里的父组件是 Todo 组件。 需要共享的状态有： 1.编辑 TodoList 组件中的 todo 时，需要让对话框显示(showModal) 2.编辑 TodoList 组件中的 todo 时，弹出的对话框需要获得 todo.id(todoId) 3.根据弹出对话框的位置，决定对话框的标题(modalTitle) 先在 Todo 组件中定义需要共享的数据字段： // Todo.ts\rconst [showModal, setShowModal] = useState(false);\rconst [todoId, setTodoId] = useState(1); const [modalTitle, setModalTitle] = useState('');\r 弹出的对话框可能是添加或编辑 todo： export enum ModalType {\rEdit = 'EDIT',\rAdd = 'ADD',\r}\r 根据弹出对话框的位置决定对话框标题: // Todo.ts\r\rconst onShowModal = (type: ModalType, id?: number) =\u003e {\rif (type === ModalType.Add) {\rsetModalTitle('添加任务');\r}\rif (type === ModalType.Edit) {\rsetModalTitle('编辑任务');\rsetTodoId(id!); //记录 TodoList 组件传递的 todoId\r }\rsetShowModal(true);\r};\r 如果是在 Todo 组件的添加按钮: //Todo.ts\r\r\u003cButton type=\"primary\"\rclassName={styles.newTodo}\ronClick={() =\u003e onShowModal(ModalType.Add)}\u003e\r添加\r\u003c/Button\u003e\r 在 Todo 组件点击添加按钮时，显示对话框组件，提交表单时用内部实现的 itemId 作为 todo.id： // ModalForm.ts\r\rconst ModalForm: FC\u003cIModalFormProps\u003e = (props) =\u003e {\rconst { visible, onClose, addTodo, modalTitle } = props;\rconst [itemId, setItemId] = useState(1);\rconst [form] = Form.useForm();\rconst onFinish = () =\u003e {\rconst text: string = form.getFieldValue('content').trim();\rif (modalTitle === '添加任务') {\raddTodo(itemId, text, false);\rsetItemId(itemId =\u003e itemId + 1);\r}\rform.setFieldsValue({ content: '' });\ronClose();\r};\r 在 ts 中需要用 interface 声明父组件传过来的 props 的类型。 // ModalForm.ts\r\rinterface IModalFormProps {\rvisible: boolean;\rmodalTitle: string;\ronClose: () =\u003e void;\raddTodo: (id: number, text: string, flag: boolean) =\u003e void;\r}\r 如果是在 TodoList 中的编辑按钮：Todo 组件将 onShowModal 方法传递给 TodoList 子组件，TodoList 就能让对话框组件显示并传递 todoId 给 Todo 组件： // TodoList.ts\r\r\u003cEditOutlined\rclassName={styles.icon}\ronClick={() =\u003e onShowModal(ModalType.Edit, todo.id)}\r/\u003e\r 在弹出编辑对话框之前，Todo 组件将已经获取到 todoId 传递给对话框组件: // Todo.ts\r\r\u003cModalForm\rmodalTitle={modalTitle}\rtodoId={todoId}\rvisible={showModal}\ronClose={onClose}\raddTodo={addTodo}\rupdateText={updateText}\r/\u003e\r 得到 todoId 就能在对话框提交时更新 todo 了，对话框组件中完善提交表单方法: // ModalForm.ts\r\rconst { visible, onClose, addTodo, modalTitle, todoId, updateText } = props;\rconst onFinish = () =\u003e {\rconst text: string = form.getFieldValue('content').trim();\rif (modalTitle === '添加任务') {\raddTodo(itemId, text, false);\rsetItemId(itemId =\u003e itemId + 1);\r}\rif (modalTitle === '编辑任务') {\rupdateText(todoId, text);\r}\rform.setFieldsValue({ content: '' });\ronClose();\r};\r ","date":"2020-06-30","objectID":"/2020-06-30-antd/:2:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"列表的增删改查 先在 Todo 组件中定义列表数据状态： //Todo.ts\r\rconst [lists, setlists] = useState\u003cITodo[]\u003e([]);\r 接下来实现列表的增删改查： // Todo.ts\r\rconst addTodo = (id: number, text: string, done: boolean) =\u003e {\rconst Item = { id, text, done };\rsetlists([Item, ...lists]);\rmessage.success('新增成功');\r};\rconst deleteTodo = (id: number) =\u003e {\rconst newlists = lists.filter(i =\u003e i.id !== id)\rsetlists([...newlists]);\rmessage.success('删除成功');\r};\rconst toggleDone = (id: number) =\u003e {\rconst newlists = lists.map(i =\u003e\ri.id === id\r? {\r...i,\rdone: !i.done\r}\r: i\r)\rsetlists([...newlists]);\r}\rconst updateText = (id: number, text: string) =\u003e {\rconst newlists = lists.map(i =\u003e\ri.id === id\r? {\r...i,\rtext\r}\r: i\r)\rsetlists([...newlists]);\rmessage.success('编辑成功');\r}\r 代办项，已完成，清单三个标签过滤列表： // Todo.ts\r\rconst todoList = lists.filter(item =\u003e !item.done);\rconst doneList = lists.filter(item =\u003e item.done);\r ","date":"2020-06-30","objectID":"/2020-06-30-antd/:3:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"实现搜索功能 先在 Todo 组件中定义搜索数据状态： //Todo.ts\r\rconst [searchText, setSearchText] = useState('');\r 实现按搜索字段过滤数据的方法： // Todo.ts \rconst getFilter = (lists: ITodo[], searchText: string) =\u003e {\rif (searchText.trim() !== '') {\rreturn lists.filter(todo =\u003e todo.text.toLowerCase().includes(searchText.toLowerCase()));\r}\rreturn lists;\r};\r Todo 组件将列表数据先用 getFilter 方法过滤再传递给 TodoList 子组件： //Todo.ts\r\r\u003cTabs defaultActiveKey=\"1\" size={\"large\"}\u003e\r\u003cTabPane tab={\u003cBadge status=\"warning\" text=\"待办项\" /\u003e} key=\"1\"\u003e\r\u003cTodoList\rlists={getFilter(todoList, searchText)}\rupdateText={updateText}\rtoggleDone={toggleDone}\rdeleteTodo={deleteTodo}\ronShowModal={onShowModal}/\u003e\r\u003c/TabPane\u003e\r \u003c/Tabs\u003e\r 上面是待办项列表的数据传递，如果是已完成或清单组件，只需将 getFilter 的第一个参数替换为 doneList 或 lists，所有功能就完成了。 续：发现了一个状态管理库 Easy Peasy, 个人感觉比 redux 简洁。这里有一个 todolist 例子。 附：源码地址 ","date":"2020-06-30","objectID":"/2020-06-30-antd/:4:0","tags":["React"],"title":"antd + TS 的简单 demo","uri":"/2020-06-30-antd/"},{"categories":["Coding"],"content":"数据分页获取 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"引入依赖，连接数据库 在 spring-boot 项目的根目录 pom.xml 添加依赖，相关依赖有 lombok, mybatis-plus, druid, swagger, mysql 驱动等。 \u003cdependency\u003e\r\u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e\r\u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e\r\u003cversion\u003e3.1.0\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e\r\u003cartifactId\u003elombok\u003c/artifactId\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e\r\u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e\r\u003cversion\u003e1.1.9\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003emysql\u003c/groupId\u003e\r\u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e\r\u003cscope\u003eruntime\u003c/scope\u003e\r\u003cversion\u003e8.0.12\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eio.springfox\u003c/groupId\u003e\r\u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e\r\u003cversion\u003e2.8.0\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eio.springfox\u003c/groupId\u003e\r\u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e\r\u003cversion\u003e2.8.0\u003c/version\u003e\r\u003c/dependency\u003e\r 然后在 src/main/resources 文件夹下添加 application.properties 或 application.yml 文件配置数据库连接。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:1","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建数据表 本地连接数据库，然后导入脚本，创建数据表。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:2","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建 entity 及 mapper 创建文章实体(entity) @Data\r@EqualsAndHashCode(callSuper = false)\r@Accessors(chain = true)\r@ApiModel(value = \"Article对象\", description = \"\")\rpublic class Article implements Serializable {\rprivate static final long serialVersionUID = 1L;\r@TableId(value = \"id\", type = IdType.AUTO)\rprivate Integer id;\r@ApiModelProperty(value = \"标题\")\rprivate String title;\r@ApiModelProperty(value = \"内容\")\rprivate String content;\r@ApiModelProperty(value = \"用户主键\")\rprivate Integer uId;\r@ApiModelProperty(value = \"热度\")\rprivate Integer score;\r@ApiModelProperty(value = \"版块主键/为0时表示未设置\")\rprivate Integer bId;\r@JsonFormat(pattern = \"yyyy-MM-dd\", timezone = \"GMT+8\")\rprivate Date createDate;\r@JsonFormat(pattern = \"yyyy-MM-dd\", timezone = \"GMT+8\")\rprivate Date updateDate;\r@TableField(exist = false)\rprivate User user;\r@TableField(exist = false)\rprivate Block block;\r}\r lombok 的注解： @Data 相当于 @Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode 这5个注解的合集。 存在继承,编译时有警提示，加上@EqualsAndHashCode(callSuper=false), 只比较当前的类字段。 @Accessors(chain = true)链式调用为真, setter方法返回当前对象 序列化对象，便于存储，便于传输。 mybatis-plus 的注解： @TableId 主键的映射,主键的生成策略,自动生成。 @TableField(exist = false) 不映射数据表字段。 swagger 的注解： @Api 开头的是 swagger 的注解。 对应的 Mapper 只需继承 BaseMapper，基本的 crud 方法 mybatis-plus 已经封装好了。 @Mapper\r@Component\rpublic interface ArticleMapper extends BaseMapper\u003cArticle\u003e {\r}\r @Component 注解代表需要被 Spring IoC 容器管理，才能实现依赖注入。 然后在启动类中加入 @MapperScan(\"\") 就可以完成 spring-boot 到数据表的映射。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:1:3","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建 service 创建 service，我们想要分页获取数据，先配置 mybatis-plus 分页插件： @Configuration\r@MapperScan(\"com.forum.buge_server.mapper*\")\rpublic class MybatisPlusConfig {\r/**\r* 加载分页插件\r* * @return\r*/\r@Bean\rpublic PaginationInterceptor paginationInterceptor() {\rreturn new PaginationInterceptor();\r}\r}\r 定义 service 接口 public interface ArticleService extends IService\u003cArticle\u003e {\rIPage\u003cArticle\u003e getArticlePageing(IPage\u003cArticle\u003e iPage, LambdaQueryWrapper\u003cArticle\u003e wrapper);\r}\r service 实现类 在实现类里注入 mapper, 完成分页获取数据。selectPage 方法接收两个参数，第一个是 IPage 对象，第二个参数是条件构造器 QueryWrapper。我们需要在 controller 中传递这两个参数。 @Service\rpublic class ArticleServiceImpl extends ServiceImpl\u003cArticleMapper, Article\u003e implements ArticleService {\r@Autowired\rArticleMapper articleMapper;\r@Override\rpublic IPage\u003cArticle\u003e getArticlePageing(IPage\u003cArticle\u003e iPage, LambdaQueryWrapper\u003cArticle\u003e wrapper) {\rIPage\u003cArticle\u003e articleIPage = articleMapper.selectPage(iPage, wrapper);\rreturn articleIPage;\r}\r}\r ","date":"2020-06-18","objectID":"/2020-06-18-forum/:2:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"创建 controller 我们需要传递 IPage 对象，QueryWrapper 对象给 service，然后从返回的 IPage 对象中取得查询到的数据。 @RestController\r@RequestMapping(\"/open\")\rpublic class OpenController {\r@Autowired\rArticleService articleService;\r@ApiOperation(\"分页查询文章，时间排序\")\r@PostMapping(\"/article/new\")\rpublic Object getArticleNew(Integer current, Integer size) {\r// 分页条件\r IPage\u003cArticle\u003e page = new Page\u003c\u003e(current, size);\r// 查询条件\r LambdaQueryWrapper\u003cArticle\u003e wrapper = new LambdaQueryWrapper\u003c\u003e();\r// 根据时间顺序查询\r wrapper.orderByDesc(Article::getCreateDate);\rIPage\u003cArticle\u003e articlePageing = articleService.getArticlePageing(page, wrapper);\r// 当前页数\r long atCurrent = articlePageing.getCurrent();\r// 当前页的数据\r List\u003cArticle\u003e records = articlePageing.getRecords();\rfor (Article article : records) {\rarticle.setContent(\"\");\rarticle.setUser(userService.getById(article.getUId()));\rarticle.setBlock(blockService.getById(article.getBId()));\r}\r// 组装Dto\r PageResult pageResult = new PageResult();\rpageResult.setCurrent(atCurrent);\rpageResult.setList(records);\rreturn new JsonResult(200, \"查询成功\", pageResult);\r}\r}\r 这样就实现了数据时间排序的分页获取。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:3:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"JWT 登录验证 添加依赖 \u003cdependency\u003e\r\u003cgroupId\u003eio.jsonwebtoken\u003c/groupId\u003e\r\u003cartifactId\u003ejjwt\u003c/artifactId\u003e\r\u003cversion\u003e0.7.0\u003c/version\u003e\r\u003c/dependency\u003e\r 写一个 jwt 工具类 @Component\r@Data\rpublic class JwtConfig {\rprivate String secret = \"abcdefg1234567\";\rprivate long expire = 3600 * 60 * 60;\rprivate String header = \"token\";\r/**\r* 生成token\r* * @param subject\r* @return\r*/\rpublic String createToken(String subject) {\rDate nowDate = new Date();\rDate expireDate = new Date(nowDate.getTime() + expire * 1000);// 过期时间\r\rreturn Jwts.builder().setHeaderParam(\"typ\", \"JWT\").setSubject(subject).setIssuedAt(nowDate)\r.setExpiration(expireDate).signWith(SignatureAlgorithm.HS512, secret).compact();\r}\r/**\r* 获取token中注册信息\r* * @param token\r* @return\r*/\rpublic Claims getTokenClaim(String token) {\rtry {\rreturn Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();\r} catch (Exception e) {\r// e.printStackTrace();\r return null;\r}\r}\r/**\r* 验证token是否过期失效\r* * @param expirationTime\r* @return\r*/\rpublic boolean isTokenExpired(Date expirationTime) {\rreturn expirationTime.before(new Date());\r}\r}\r 里面写了 token 的生成和解密的方法。 添加 jwt 拦截器, 除了注册，登录和 get 请求的 uri 地址，都需要验证 token。 @Component\rpublic class TokenInterceptor extends HandlerInterceptorAdapter {\rJwtConfig jwtConfig = new JwtConfig();\r@Override\rpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\rthrows Exception {\rif (request.getMethod().equals(\"OPTIONS\")) {\rreturn true;\r}\r/** 地址过滤 */\rString uri = request.getRequestURI();\rif (uri.contains(\"/api/login\") || uri.contains(\"/api/reg\") || uri.contains(\"/sys/login\")\r|| uri.contains(\"/api/get\")) {\rreturn true;\r}\r/** Token 验证是否存在 */\rString token = request.getHeader(jwtConfig.getHeader());\rif (StringUtils.isEmpty(token)) {\rtoken = request.getParameter(jwtConfig.getHeader());\r}\rif (StringUtils.isEmpty(token)) {\rthrow new SignatureException(jwtConfig.getHeader() + \"不能为空\");\r}\rClaims claims = null;\r// 判断是否有效\r try {\rclaims = jwtConfig.getTokenClaim(token);\rif (claims == null || jwtConfig.isTokenExpired(claims.getExpiration())) {\rthrow new SignatureException(jwtConfig.getHeader() + \"失效，请重新登录。\");\r}\r} catch (Exception e) {\rthrow new SignatureException(jwtConfig.getHeader() + \"失效，请重新登录。\");\r}\r/** 设置 identityId 用户身份ID */\rrequest.setAttribute(\"identityId\", claims.getSubject());\rreturn true;\r}\r}\r ","date":"2020-06-18","objectID":"/2020-06-18-forum/:4:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"点赞关注收藏评论 点赞，关注，收藏，评论功能都可以用单表实现。点赞，收藏，评论功能就是在分别在likes, collection, comment 表中记录 uid(用户),aid(文章) 实现关联，而关注则是在 follow 表中记录两个 uid 实现关联，下面给出点赞功能的逻辑实现，关注，收藏，评论功能的逻辑同点赞功能。 @PostMapping(\"/add/like\")\rpublic Object setLike(Integer aid, HttpServletRequest request) {\rClaims token = jwtConfig.getTokenClaim(request.getHeader(\"token\"));\rString subject = token.getSubject();\rLambdaQueryWrapper\u003cLikes\u003e queryWrapper = new LambdaQueryWrapper\u003c\u003e();\rqueryWrapper.eq(Likes::getUid, Integer.valueOf(subject));\rqueryWrapper.eq(Likes::getAId, aid);\rLikes one = likeService.getOne(queryWrapper);\rif (one == null) {\rboolean save = likeService.save(new Likes().setAId(aid).setUid(Integer.valueOf(subject)));\rreturn new JsonResult(200, \"点赞成功!\");\r} else {\rboolean b = likeService.removeById(one.getId());\rreturn new JsonResult(200, \"已取消点赞!\");\r}\r}\r ","date":"2020-06-18","objectID":"/2020-06-18-forum/:5:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"搜索和浏览记录 搜索使用 mysql 的模糊查询实现。 @PostMapping(\"/search/article\")\rpublic Object searchArticle(String title) {\rLambdaQueryWrapper\u003cArticle\u003e articleWrapper = new LambdaQueryWrapper\u003c\u003e();\rarticleWrapper.like(Article::getTitle, title);\rList\u003cArticle\u003e list = articleService.list(articleWrapper);\rfor (Article article : list) {\rarticle.setContent(\"\");\rarticle.setUser(userService.getById(article.getUId()));\rarticle.setBlock(blockService.getById(article.getBId()));\r}\rreturn new JsonResult(200, \"\", list);\r}\r 浏览记录，进入文章详情页面后，如果用户是登录状态，就加入 History 表。 History 表有三个字段，uid(用户), aid(文章), time(访问时间)。如果已经在 History 表中存在记录，则更新时间。 @GetMapping(\"/article/{id}\")\rpublic Object getArticleById(@PathVariable(\"id\") Integer id, HttpServletRequest request) {\rClaims token = jwtConfig.getTokenClaim(request.getHeader(\"token\"));\r// 在登陆状态下保存到历史表中\r if (token != null) {\rString subject = token.getSubject();\rLambdaQueryWrapper\u003cHistory\u003e queryWrapper = new LambdaQueryWrapper\u003c\u003e();\rqueryWrapper.eq(History::getAid, id);\rqueryWrapper.eq(History::getUid, Integer.valueOf(subject));\rHistory one = historyService.getOne(queryWrapper);\r// 如果已存在记录，则更新时间\r History history = new History().setAid(id).setTime(new Date()).setUid(Integer.valueOf(subject));\rif (one == null) {\rhistoryService.save(history);\r} else {\rone.setTime(new Date());\rhistoryService.updateById(one);\r}\r}\rArticle byId = articleService.getById(id);\rbyId.setUser(userService.getById(byId.getUId()));\rbyId.setBlock(blockService.getById(byId.getBId()));\r// 每次访问热度加1\r articleService.updateById(new Article().setId(id).setScore(byId.getScore() + 1));\rreturn new JsonResult(200, \"查询成功\", byId);\r}\r 每次访问文章详情页，文章热度发生变化，首页热度排序的内容将重新排序。 项目启动主类 @SpringBootApplication\rpublic class BugeServerApplication {\rpublic static void main(String[] args) {\rSpringApplication.run(BugeServerApplication.class, args);\r}\r}\r spring boot提供了一个统一的注解@SpringBootApplication。 代表了@Configuration, @EnableAutoConfiguration, @ComponentScan。 @Configuration 和 @Bean。使用这两个注解就可以创建一个简单的spring配置类，可以用来替代相应的xml配置文件。@Configuration的注解类标识这个类可以使用Spring IoC容器作为bean定义的来源。@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。 @EnableAutoConfiguration：能够自动配置spring的上下文，试图猜测和配置你想要的bean类，通常会自动根据你的类路径和你的bean定义自动配置。 @ComponentScan：会自动扫描指定包下的全部标有@Component的类，并注册成bean，当然包括@Component下的子注解@Service, @Repository, @Controller。 ","date":"2020-06-18","objectID":"/2020-06-18-forum/:6:0","tags":["Spring Boot"],"title":"MyBatis-Plus 实现论坛 Api","uri":"/2020-06-18-forum/"},{"categories":["Coding"],"content":"本文记录 react-beautiful-dnd 这个拖拽库的使用，我们将完成一个类似 trello 的看板应用。最终实现的效果如下：List 是一个可横向拖放的列表，Card 可在不同的 List 列表之间拖放。左上方的搜索框能够搜索筛选卡片，右上方的按钮能够实现撤销重做功能。 \r","date":"2020-05-18","objectID":"/2020-05-18-trello/:0:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"拖拽库的使用 react-beautiful-dnd 这个库使用 render-props 完成组件逻辑复用。react-beautiful-dnd 有 3 个主要组件：DragDropContext，Droppable和Draggable。这三者的关系如下： \rDragDropContext 表示一个全局拖拽上下文。Droppable 表示可以被拖入的容器，Draggable 是可被拖放的组件。 DragDropContext 提供了以下三个钩子： onDragStart 拖动开始时执行。 onDragUpdate 拖动过程中的执行。 onDragEnd 拖拽结束时执行，且 onDragEnd 必须设定。 我们需要在 Board 组件内建立可拖动范围，则需要这样写： // components/Board.js\r\rconst Board = () =\u003e {\r// onDragEnd 需实现\r const onDragEnd = result =\u003e {};\rreturn (\r\u003cDragDropContext onDragEnd={onDragEnd}\u003e\r...\r\u003c/DragDropContext\u003e\r);\r}\r Droppable： Droppable 必须设定 droppableId Droppable 使用 render-props 意味着内部须使用一个函数，该函数接收参数 provided 对象, 然后将参数 provided 的属性传递给封装后的可拖放的容器组件 将 Board 组件建立成可拖放的容器组件，像这样写： // components/Board.js\r\r// 需嵌套在 DragDropContext 内\r// 包裹 List 的容器，List 在 Board 容器内横向拖动\r\u003cDroppable droppableId='all-lists' direction='horizontal' type='list'\u003e\r{ provided =\u003e (\r// 封装后的可拖放的容器组件\r \u003cListContainer ref={provided.innerRef}\r{...provided.droppableProps}\u003e\r// 遍历所有的列表，将列表数据传递给每个列表\r {Object.keys(lists).map((key, index) =\u003e {\rconst list = lists[key];\rconst listCards = list.cards.length \u003e 0 ? list.cards : [];\rreturn (\r\u003cList\rkey={list.id}\rid={list.id}\rtitle={list.title}\rcards={listCards}\rindex={index}\r/\u003e\r);\r})}\r{provided.placeholder}\r\u003c/ListContainer\u003e\r)}\r\u003c/Droppable\u003e\r Draggable： Draggable 必须设定 draggableId，index(由父组件传入) Draggable 与 Droppable 一样是 render-props，接收 provided 对象，返回值是封装后的可拖放组件 将 List 组件建立成可拖放组件，像这样写： // components/List.js\r\r// 设置每个 List 都是可拖动的\rconst List = ({ id, title, cards = [], index }) =\u003e {\r...\rreturn (\r\u003cDraggable draggableId={id} index={index}\u003e\r{ provided =\u003e (\r// 封装后的可拖放组件\r \u003cListContainer ref={provided.innerRef}\r{...provided.draggableProps}\r// dragHandleProps 绑定的组件 ListContainer 可拖动\r{...provided.dragHandleProps}\u003e ...\r\u003c/ListContainer\u003e\r)}\r\u003c/Draggable\u003e\r);\r}\r 同理设置 Card 组件可在 List 组件内部拖动，先要将 List 内部封装成可拖放的容器，像这样写: // components/List.js\r\r// 需嵌套在 List 组件返回的 ListContainer 内\r// 包裹 Card 的容器，Card 在 List 容器内可拖放\r\u003cDroppable droppableId={id} type=\"card\"\u003e\r{provided =\u003e (\r\u003cCardContainer ref={provided.innerRef}\r{...provided.droppableProps}\u003e\r// 遍历每个 List 中所有的卡片，将卡片数据传给每张卡片\r {cards.map((card, index) =\u003e (\r\u003cCard\rkey={card.id}\rid={card.id}\rtext={card.text}\rlistId={id}\rindex={index}\r/\u003e\r))}\r{provided.placeholder}\r\u003c/CardContainer\u003e\r)}\r\u003c/Droppable\u003e\r 将 Card 组件封装成可拖放组件，像这样写: // components/Card.js\r\rconst Card = ({ id, text, index, listId }) =\u003e {\r...\rreturn (\r\u003cDraggable draggableId={id} index={index}\u003e\r{provided =\u003e (\r\u003cCardContainer\rclassName='card'\rref={provided.innerRef}\r{...provided.draggableProps}\r// dragHandleProps 绑定的组件 CardContainer 可拖动\r{...provided.dragHandleProps}\u003e\r\u003c/CardContainer\u003e\r)}\r\u003c/Draggable\u003e\r);\r}\r ","date":"2020-05-18","objectID":"/2020-05-18-trello/:1:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"状态管理 初始化列表数据: // morkData.js\r\rimport { uuid } from 'uuidv4';\rconst getCard = text =\u003e ({\rid: uuid(),\rtext\r});\rexport const ListState = [\r{\rid: uuid(),\rtitle: 'To Do',\rcards: [\rgetCard('To do task'),\rgetCard('TO FILTER: To do task'),\r]\r},\r{\rid: uuid(),\rtitle: 'Doing',\rcards: [\rgetCard('Doing task'),\rgetCard('TO FILTER: Doing task'),\r]\r},\r{\rid: uuid(),\rtitle: 'Done',\rcards: [\rgetCard('Done task'),\rgetCard('TO FILTER: Done task'),\r]\r},\r];\r 记录状态变更用 DragDropContext 上的钩子函数 onDragEnd，onDragEnd 接收一个 result 对象，result 记录了拖拽过程中的状态变化，result 结构如下： const result = {\rdraggableId: 1, // 移动的组件 id\r type: 'list',\rsource: {\rdroppableId: 1, // 移动前所在的容器 id\r index: 2, // 组件在移动前的容器内的位置\r },\rdestination: {\rdroppableId: 3, // 移动后所在的容器 id\r index: 1, // 组件在移动后的容器内的位置\r }\r}\r 我们需要写拖放组件后的状态变化逻辑，因为我们的列表数据中的 cards 数组发生了变化，但我们还没有把新的状态渲染到 list 组件中，拖放组件后需要重新排序，现在去实现在 Board 组件中定义的 onDragEnd 钩子函数： // components/Board.js\r\rconst onDragEnd = ({ draggableId, type, source, destination }) =\u003e {\rif (destination) {\rdispatch(\rsort(\rsource.droppableId, destination.droppableId,\rsource.index,\rdestination.index,\rdraggableId,\rtype\r)\r);\r}\r};\r action 用 payload 传递接收到的数据： // actions/listActions.js\r\rimport { CONSTANTS } from '.';\r...\rexport const sort = (\rdroppableIdStart, droppableIdEnd, droppableIndexStart, droppableIndexEnd, draggableId,\rtype\r) =\u003e {\rreturn {\rtype: CONSTANTS.DRAGGED, // 动作是拖放，可能是列表，也可能是卡片\r payload: {\rdroppableIdStart, //开始时所在的 container id\r droppableIdEnd, //结束时所在的 container id\r droppableIndexStart, //开始所在 container 里的索引\r droppableIndexEnd, //结束时所在的 container 里的索引\r draggableId, // 移动的组件 id\r type\r}\r};\r};\r reducer 实现状态变化逻辑并返回新状态，始终用新状态替换原来的状态，不要直接在原来的对象上操作，因为我们将会对每个状态做记录，这有利于我们实现撤销重做功能。 // reducers/listReducer.js\r\rcase CONSTANTS.DRAGGED: { // 当完成拖放动作时\r const {\rdroppableIdStart,\rdroppableIdEnd, droppableIndexStart,\rdroppableIndexEnd,\rtype\r} = action.payload;\rconst newState = [...state]; //深拷贝不改变原列表\r if (type === 'list') {\rconst moveList = newState.splice(droppableIndexStart, 1);\rnewState.splice(droppableIndexEnd, 0, ...moveList);\rconsole.log('Drag list', newState);\rreturn newState;\r}\rconst sourceListIndex = newState.findIndex(list =\u003e droppableIdStart === list.id);\rconst sourceList = newState[sourceListIndex];\rconst sourceCards = [...sourceList.cards]; //深拷贝不改变原数组\r const moveCard = sourceCards.splice(droppableIndexStart, 1);\rif (droppableIdStart !== droppableIdEnd) { //不同列之间移动卡片\r const destinationListIndex = newState.findIndex(list =\u003e droppableIdEnd === list.id);\rconst destinationList = newState[destinationListIndex];\rconst destinationCards = [...destinationList.cards];\rdestinationCards.splice(droppableIndexEnd, 0, ...moveCard);\rnewState[destinationListIndex] = {\r...newState[destinationListIndex],\rcards: destinationCards\r};\r} else { //同列中改变卡片次序\r sourceCards.splice(droppableIndexEnd, 0, ...moveCard);\r}\rnewState[sourceListIndex] = {\r...newState[sourceListIndex],\rcards: sourceCards\r};\rconsole.log('Drag card', newState);\rreturn newState;\r}\r 这样就实现了移动列表和移动卡片的状态变化逻辑，剩下的列表和卡片的增删改查的状态变化逻辑的实现就比较容易了。 ","date":"2020-05-18","objectID":"/2020-05-18-trello/:2:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"搜索卡片 在界面上实现卡片的搜索功能，实际上就是实现筛选卡片功能。我们已经在每个 List 组件中遍历其中的 Card，筛选功能就是每个 List 组件根据搜索框的输入内容选择性的遍历 Card，修改 List 组件如下： // components/List.js\r\r...\r\u003cDroppable droppableId={String(id)} type=\"card\"\u003e\r{(provided, snapshot) =\u003e (\r\u003cCardListContainer ref={provided.innerRef}\risDraggingOver={snapshot.isDraggingOver}\r{...provided.droppableProps}\u003e\r// 筛选出每个 List 中符合搜索条件的 cards\r {getFilteredCards(cards, searchText).map((card, index) =\u003e (\r\u003cCard\rkey={card.id}\rid={card.id}\rtext={card.text}\rlistId={id}\rindex={index}\r/\u003e\r))}\r{provided.placeholder}\r\u003c/CardListContainer\u003e\r)}\r\u003c/Droppable\u003e\r 实现其中的 getFilteredCards 方法： const getFilteredCards = (cards, searchText) =\u003e {\rif (searchText) {\rconsole.log(searchText);\rreturn cards.filter(card =\u003e card.text.toLowerCase().includes(searchText.toLowerCase()));\r}\rreturn cards;\r};\r ","date":"2020-05-18","objectID":"/2020-05-18-trello/:3:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"撤销重做功能 实现撤销重做功能可用 redux-undo 这个库，自己实现也不复杂，下面就自己实现: 实现方法是自定义一个接收 reducer 为参数，返回新 reducer 的函数(reducer enhancer)，监听 listReducer 的变化并做记录。实现思路来自 redux 官方文档。原本创建 store 时需要导出的 reducer 如下： // reducers/index.js\r\rconst rootReducer = combineReducers({\rlists: listReducer,\r...\r});\rexport default rootReducer;\r combineReducers 接收值为 reducer 的函数作为参数，我们只要实现一个返回值为 reducer 的函数(reducer enhancer)就行： const rootReducer = combineReducers({\rboard: stateEnhancer(listReducer),\r...\r});\rexport default rootReducer;\r board 对应的值是将 listReducer 封装后的新 reducer，这样每次调用 listReducer 时也会调用 stateEnhancer，因为函数的参数发生了变化，函数就会重新执行。 // reducers/stateEnhancer.js\r\rimport { CONSTANTS } from '../actions';\rconst stateEnhancer = reducer =\u003e {\rconst initialState = {\rpreviousStates: [],\rcurrentState: reducer(undefined, {}), // currentState 取 reducer 的返回值\r futureStates: []\r};\r// 调用 reducer 时就会调用 stateEnhancer, 并返回封装后的 reducer\r return (state = initialState, action) =\u003e {\r// console.log(state.currentState);\r const { previousStates, currentState, futureStates } = state;\rswitch (action.type) {\rcase CONSTANTS.UNDO_ACTION:\rconst previous = previousStates[previousStates.length - 1];\rconst newPreviousStates = previousStates.slice(0, previousStates.length - 1);\rreturn {\rpreviousStates: newPreviousStates,\rcurrentState: previous,\rfutureStates: [currentState, ...futureStates]\r};\rcase CONSTANTS.REDO_ACTION:\rconst next = futureStates[0];\rconst newFutureStates = futureStates.slice(1);\rreturn {\rpreviousStates: [...previousStates, currentState],\rcurrentState: next,\rfutureStates: newFutureStates\r};\rdefault:\rconst newCurrentState = reducer(currentState, action);\rif (currentState === newCurrentState) { //初始化列表\r console.log('init');\rreturn state;\r}\rconsole.log('list change'); // 列表变化时\r return {\rpreviousStates: [...(previousStates || []), currentState],\rcurrentState: newCurrentState,\rfutureStates: []\r};\r}\r};\r};\rexport default stateEnhancer;\r 我们用了三个数组记录 listReducer 的变化，按下撤销或者重做功能按钮时，就能在不同的 listReducer 之间切换。并且我们可以根据 previousStates， futureStates 是否为空来判断撤销，重做按钮是否可用： \u003cDoBtn onClick={undo} disabled={previousStates.length === 0} className='btn'\u003e\r\u003ci className=\"fas fa-undo\"\u003e\u003c/i\u003e\r\u003c/DoBtn\u003e\r\u003cDoBtn onClick={redo} disabled={futureStates.length === 0} className='btn' \u003e\r\u003ci className=\"fas fa-redo\"\u003e\u003c/i\u003e\r\u003c/DoBtn\u003e\r 附：源码地址 参考资料 React Beautiful Dnd 快速使用筆記 redux 文档 - 实现撤销历史 ","date":"2020-05-18","objectID":"/2020-05-18-trello/:4:0","tags":["React"],"title":"写一个可拖拽的 Trello","uri":"/2020-05-18-trello/"},{"categories":["Coding"],"content":"React 组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。 React 组件分为两类，class 组件和函数组件。hooks 的出现让函数组件拥有了状态(state), 因此让自定义 hook 成为了继 render-props 和高阶组件(HOC)之后的第三种状态共享方案。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:0:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"class 组件的状态共享 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:1:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"render-props 具有 render prop 的组件接受一个函数，该函数返回一个 React 元素并调用它(回调函数)而不是实现自己的渲染逻辑。 react官网示例： class Cat extends React.Component {\rrender() {\rconst mouse = this.props.mouse;\rreturn (\r\u003cimg src=\"/cat.jpg\" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /\u003e\r);\r}\r}\rclass Mouse extends React.Component {\rconstructor(props) {\rsuper(props);\rthis.handleMouseMove = this.handleMouseMove.bind(this);\rthis.state = { x: 0, y: 0 };\r}\rhandleMouseMove(event) {\rthis.setState({\rx: event.clientX,\ry: event.clientY\r});\r}\rrender() {\rreturn (\r\u003cdiv style={{ height: '100vh' }} onMouseMove={this.handleMouseMove}\u003e\r{/*使用`render`属性来动态确定要渲染的内容。*/}\r{this.props.render(this.state)}\r\u003c/div\u003e\r);\r}\r}\rclass MouseTracker extends React.Component {\rrender() {\rreturn (\r\u003cdiv\u003e\r\u003ch1\u003e移动鼠标!\u003c/h1\u003e\r{/*将 Mouse 组件中的 state 传递给 Cat 组件*/}\r\u003cMouse render={mouse =\u003e (\r\u003cCat mouse={mouse} /\u003e\r)}/\u003e\r\u003c/div\u003e\r);\r}\r}\r 注意 Mouse 组件中的 this.props.render 是绑定在标签模板上的render(外部传入)。这样就实现了鼠标位置状态的共享, Cat 组件能够根据鼠标位置动态移动 cat 图片。这个示例实现了 react 组件的理想状态：有状态的组件无渲染，有渲染的组件无状态。 因为 Cat 组件只是一个渲染模板，它也可以替换成如下的函数组件: const Cat = (props) =\u003e {\rconst mouse = this.props.mouse;\rreturn (\r\u003cimg src=\"/cat.jpg\" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /\u003e\r);\r}\r}\r UI与状态分离，便于逻辑的复用。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:1:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"高阶组件(HOC) 高阶组件是参数为组件，返回值为新组件的函数，高阶组件是函数。 const EnhancedComponent = higherOrderComponent(WrappedComponent);\r 示例： function high(WrappedComponent){\rreturn class extends React.Component{\rconstructor(){\rthis.state={\ropen:false\r}\r}\rcomponentDidMount(){\rconsole.log('haha')\r}\rchange=()=\u003e{\rthis.setState((state)=\u003e{//用到state需要使用回调函数修改state的值\r return {open:!state.open}\r})\r}\rrender(){\r//使用新数据渲染被包装的组件\r return \u003cWrappedComponent open={this.state.open} change={this.change} /\u003e\r}\r}\r}\rclass ToggleButton extends Component{//不带有自身的状态能够实现组件的复用\r constructor(props){\rsuper(props)\r}\rrender(){\rlet {open,change}=this.props; // 来自 high 的数据\r return \u003cFragment\u003e\r\u003cbutton type=\"primary\" onClick={change}\u003e\rtoggle Modal\r\u003c/button\u003e\r\u003cdiv\u003e{open}\u003c/div\u003e //拿到open值\r \u003c/Fragment\u003e\r}\r}\r// high 是一个高阶组件，传入组件作为参数，组件就能接收 high 的数据\rexport default high(ToggleButton)；\r 每个经过高阶组件处理过的组件都会复用高阶组件里边的所有逻辑，原则上高阶组件是一个纯函数，不会修改传入的组件，只是返回包装好的新组件。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:1:2","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"函数组件的状态共享 Hooks 可以让你在函数组件中使用状态(state)以及其他的 React 特性。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:2:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"自定义 hook Hook 是 React 中的一类特殊的 JavaScript 函数。自定义名为 useFriendStatus 的 hook，它通过调用 useState 和 useEffect 来订阅一个好友的在线状态。 import React, { useState, useEffect } from 'react';\rfunction useFriendStatus(friendID) {\rconst [isOnline, setIsOnline] = useState(null);\rfunction handleStatusChange(status) {\rsetIsOnline(status.isOnline);\r}\ruseEffect(() =\u003e {\rChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\rreturn () =\u003e {\rChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\r};\r});\rreturn isOnline;\r}\r 自定义 Hook 更像是一种约定而不是功能。如果函数的名字以 “use” 开头并调用其他 Hook，我们就说这是一个自定义 Hook。 现在我们可以在下面两个组件中使用它： function FriendStatus(props) {\rconst isOnline = useFriendStatus(props.friend.id);\rif (isOnline === null) {\rreturn 'Loading...';\r}\rreturn isOnline ? 'Online' : 'Offline';\r}\r function FriendListItem(props) {\rconst isOnline = useFriendStatus(props.friend.id);\rreturn (\r\u003cli style={{ color: isOnline ? 'green' : 'black' }}\u003e\r{props.friend.name}\r\u003c/li\u003e\r);\r}\r 这两个组件的 state 是完全独立的，Hook 是一种复用状态逻辑的方式，它不复用 state 本身。传入不同的 props，得到的 state 也不同。同样是实现了 UI 与状态分离，便于逻辑的复用。 但是使用 Hook 会有几个额外的规则： 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用 不要在普通 Javascript 函数中调用 在 React 的函数组件调用 Hook 在自定义的 Hook 中调用 Hook 自定义的 hook 必须以 “use” 开头 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:2:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"状态管理 实现状态管理的前提是能够状态共享，这就是为什么前面会先说状态共享。不同类型的组件实现状态共享的方法不同，状态管理的方案也不同。下面是一个计数器的状态管理的不同实现方案。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:3:0","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"class 组件的状态管理 class 组件的状态管理，通常方案是使用第三方库 Redux，结合 React-Redux 使用： $ npm i redux react-redux -S\r Redux 流程图 \r当 UI 的 state 变化时，组件 dispatch 发送 action 信号, reducer 接收来自 action 的信号更新 state, 然后 store 将新的 state 传递给组件，重新渲染 UI。 先创建 store，接收 reducer 为参数: import { createStore } from 'redux'\rimport reducer from './reducer'\r//创建store\rconst store = createStore(reducer)\rexport default store;\r 再写 action，写 action 之前先了解一下 connect 函数 // React Redux 的 `connect` 函数\rconst connect(mapStateToProps, mapDispatchToProps)(Component);\r 可能看起来有些怪, 这样写你就明白了： //先传递两个参数将 connect 封装成高阶函数\rconst higherOrderComponent = connect(mapStateToProps, mapDispatchToProps);\r//再得到新包装的组件 EnhancedComponent\rconst EnhancedComponent = higherOrderComponent(Component);\r action 就是 dispatch 中的参数。 // connect.js\rimport { connect } from 'react-redux'\rconst mapStateToProps = (state) =\u003e {\rreturn { count: state.count, message: state.message }\r}\rconst mapDispatchToProps = (dispatch) =\u003e {\rreturn {\rincrement: (data) =\u003e { dispatch({ type: \"INCREMENT\", num: data, message: \"Incremented\" }) },\rdecrement: (data) =\u003e { dispatch({ type: \"DECREMENT\", num: data, message: \"Decremented\" }) },\rreset: () =\u003e { dispatch({ type: \"RESET\", message: \"Reset\" }) }\r}\r}\r//封装了一个高阶组件，注意高阶组件是函数\rexport default connect(mapStateToProps, mapDispatchToProps)\r 最后写 reducer，接收 action 更新 state: const initialState = { count: 0, message: \"\" }\rconst reducer = (state = initialState, action) =\u003e {\rswitch (action.type) {\rcase \"INCREMENT\":\rreturn {\rcount: state.count + action.num,\rmessage: action.message\r}\rcase \"DECREMENT\":\rreturn {\rcount: state.count - action.num,\rmessage: action.message\r}\rcase \"RESET\":\rreturn {\rcount: 0,\rmessage: action.message\r}\rdefault:\rreturn state;\r}\r}\rexport default reducer;\r 创建一个组件测试计数器: import React, { Component } from 'react'\rimport connect from './connect'\rclass Count extends Component {\rrender() {\rlet { count, message, increment, decrement, reset } = this.props; //来自 connect\r\rreturn (\r\u003cdiv\u003e\r{count}\r\u003cbutton onClick={() =\u003e increment(1)}\u003e+1\u003c/button\u003e\r\u003cbutton onClick={() =\u003e decrement(3)}\u003e-3\u003c/button\u003e\r\u003cbutton onClick={() =\u003e reset()}\u003ereset\u003c/button\u003e\r{message}\r\u003c/div\u003e\r)\r}\r}\r// 导入的 './connect' 是高阶组件，传入 Count 组件, Count就能接收 store 中的数据\rexport default connect(Count)\r 根组件注册 store，并导入 count 组件： import React from 'react'\rimport ReactDOM from 'react-dom';\rimport { Provider } from 'react-redux'\rimport store from './store'\rimport Count from './count'\rfunction App() {\rreturn (\r\u003cProvider store={store}\u003e\r\u003cCount /\u003e\r\u003c/Provider\u003e\r);\r}\rconst rootElement = document.getElementById(\"root\");\rReactDOM.render(\u003cApp /\u003e, rootElement)\r 此时启动项目你发现已经能够计数了，但是我们并没有直接操作 store 啊，其实是 connect 帮我们做了这件事，可以看一下精简版的 connect 源码： import React, { Component } from 'react';\rimport PropTypes from 'prop-types';\rconst connect = (mapStateToProps, mapDispatchToProps) =\u003e (WrappedComponent) =\u003e {\rclass Connect extends Component {\rstatic contextTypes = {\rstore: PropTypes.object,\r};\rconstructor() {\rsuper();\rthis.state = { allProps: {} }\r}\rcomponentWillMount() {\rconst { store } = this.context;\rthis._updateProps();\rstore.subscribe(this._updateProps);\r}\r_updateProps = () =\u003e {\rconst { store } = this.context;\rlet stateProps = mapStateToProps(store.getState());\rlet dispatchProps = mapDispatchToProps(store.dispatch);\rthis.setState({\rallProps: {\r...stateProps,\r...dispatchProps,\r...this.props,\r}\r});\r};\rrender () {\rreturn \u003cWrappedComponent {...this.state.allProps} /\u003e\r}\r}\rreturn Connect;\r};\rexport default connect;\r 你会发现 store 实际上是通过 Context 创建的，Context 是 React 中的 API 方法: Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。 有了状态共享方法(高阶组件)和数据传递的方法(Context), 就能让在整个组件树中的各个组件都很方便的读取状态修改状态, 就实现了 React-Redux，下面我会用 hooks 实现类似的全局状态管理。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:3:1","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"函数组件的状态管理 实际上 React 已经为我们实现了相应的 hooks, 我们需要做的只是将这些 hooks 灵活的组合在一起。就能够实现状态管理了，还是以实现计数器的为例。 实现一个 React-redux 中的 store 只需以下代码： //store.js\rimport React, { createContext, useContext, useReducer } from 'react';\rimport reducer from './reducer';\rconst StoreContext = createContext();\rconst initialState = { count: 0, message: \"\" };\rexport const StoreProvider = ({ children }) =\u003e {\rconst [state, dispatch] = useReducer(reducer, initialState);\rreturn (\r\u003cStoreContext.Provider value={{ state, dispatch }}\u003e\r{children}\r\u003c/StoreContext.Provider\u003e\r )\r}\rexport const useStore = () =\u003e useContext(StoreContext);\r useReducer 是 useState 的替代方案。它接收一个形如 (state, action) =\u003e newState 的 reducer，以及初始状态 initialState，返回值是当前的 state 以及与其配套的 dispatch 方法。 useContext 的参数必须是 context 对象，让你能够读取 context 的值以及订阅 context 的变化。调用了 useContext 的组件会在 context 值变化时重新渲染。你仍然需要在上层组件树中使用 \u003cMyContext.Provider\u003e 来为下层组件提供 context。 OK, 我们的简版 React-redux 就做好了。 写 action, 我们的状态数据从 useCounter 里获取: //storeApi.js\rimport { useStore } from \"./store\";\rexport const useCounter = () =\u003e {\rconst { state, dispatch } = useStore();\rreturn {\rcount: state.count,\rmessage: state.message,\rincrement: (data) =\u003e dispatch({ type: \"INCREMENT\", num: data, message: \"Incremented\" }),\rdecrement: (data) =\u003e dispatch({ type: \"DECREMENT\", num: data, message: \"Decremented\" }),\rreset: () =\u003e dispatch({ type: \"RESET\", message: \"Reset\" })\r}\r}\r 写reducer, 去掉 initialState, 我们已经写在了 useReducer 里, 原因是： 注意 React 不使用 state = initialState 这一由 Redux 推广开来的参数约定。有时候初始值依赖于 props，因此需要在调用 Hook 时指定。 // reducer.js\rconst reducer = (state, action) =\u003e {\rswitch (action.type) {\rcase \"INCREMENT\":\rreturn {\rcount: state.count + action.num,\rmessage: action.message\r}\rcase \"DECREMENT\":\rreturn {\rcount: state.count - action.num,\rmessage: action.message\r}\rcase \"RESET\":\rreturn {\rcount: 0,\rmessage: action.message\r}\rdefault:\rreturn state;\r}\r}\rexport default reducer;\r 写个组件，测试一下: //Count.js\rimport React from \"react\";\rimport { useCounter } from \"./storeApi\";\rexport const Count = () =\u003e {\rconst { count, message, increment, decrement, reset } = useCounter();\rreturn (\r\u003cdiv\u003e\r{count}\r\u003cbutton onClick={() =\u003e increment(1)}\u003e+1\u003c/button\u003e\r\u003cbutton onClick={() =\u003e decrement(3)}\u003e-3\u003c/button\u003e\r\u003cbutton onClick={() =\u003e reset()}\u003e Reset\u003c/button\u003e\r{message}\r\u003c/div\u003e\r)\r}\r 修改根组件如下： import React from \"react\";\rimport ReactDOM from \"react-dom\";\rimport { StoreProvider } from \"./store\";\rimport { Count } from \"./Count\";\rfunction App() {\rreturn (\r\u003cStoreProvider\u003e\r\u003cCount /\u003e\r\u003c/StoreProvider\u003e\r);\r}\rconst rootElement = document.getElementById(\"root\");\rReactDOM.render(\u003cApp /\u003e, rootElement);\r 启动服务，发现能够计数成功，我们的状态管理方案成功了。 ","date":"2020-05-07","objectID":"/2020-05-07-react-hooks-state/:3:2","tags":["React"],"title":"Context + Hooks：状态管理新方案","uri":"/2020-05-07-react-hooks-state/"},{"categories":["Coding"],"content":"本次实践我将使用 Angular 和 Nest.js 写一个带有状态管理，登录验证的全栈 todolist 应用。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:0:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"后端开发 后端开发使用 Nest.js 框架，本次实践是重前端的，因此后端会做得简单一些。后端是在上一次鉴权认证的代码做部分修改。如果有不懂的代码，可以参考之前的文章。此部分的讲解略过。这是后端部分生成的 swagger 接口文档: \r","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:1:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"前端开发 前端使用 Angular 框架。为什么使用 Angular? 以下几点是我选择它的原因： 1.它是前端真正意义上的框架。 2.它的一些理念是相当超前。 3.Nest.js 和 Angular 非常像。 4.前后端开发同构语言。 不过它的缺点也很显著，或者说是我的缺点： 1.学习到会用有较长的时间周期。 2.HMR(hot module replacement) 体验太差。 3.报错信息简直了。 尽管在国内太冷门，不过我仍然看好 Angular 的发展。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:0","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"组件开发 导入 UI 组件库 在样式开发方面，我们使用 angular 官方提供的 Material UI。用一个 MaterialModule，导出我们需要用到的所有样式组件。 @NgModule({\rexports: [\rMatButtonModule,\rMatCardModule,\rMatDialogModule,\rMatIconModule,\rMatInputModule,\rMatListModule,\rMatToolbarModule,\rMatMenuModule,\r],\r})\rexport class MaterialModule { }\r 这样在我们需要用到样式组件时，直接导入 MaterialModule 就好。 顶部导航 在 AppModule 中导入 MaterialModule， 然后在 app.component.html 中写入顶部 header 导航组件。 \u003cheader\u003e\r\u003cmat-toolbar color=\"primary\" class=\"expanded-toolbar\"\u003e\r\u003cdiv\u003e\r\u003cspan\u003e{{title}}\u003c/span\u003e\r\u003cbutton mat-button routerLink=\"/todos\"\u003e\r\u003cmat-icon\u003eview_lists\u003c/mat-icon\u003e\rTodo\r\u003c/button\u003e\r\u003c/div\u003e\r\u003cdiv\u003e\r\u003cbutton mat-button routerLink=\"/login\" *ngIf=\"authService.token.length == 0\"\u003e\r\u003cmat-icon\u003eaccount_box\u003c/mat-icon\u003e\rLogin\r\u003c/button\u003e\r\u003cbutton mat-button routerLink=\"/login\" *ngIf=\"authService.token.length \u003e 0\" (click)=\"logout()\"\u003e\r\u003cmat-icon\u003eexit_to_app\u003c/mat-icon\u003e\rLogout\r\u003c/button\u003e\r\u003c/div\u003e\r\u003c/mat-toolbar\u003e\r\u003c/header\u003e\r\u003cmain\u003e\r\u003crouter-outlet\u003e\u003c/router-outlet\u003e\r\u003c/main\u003e\r\u003c!-- \u003cfooter\u003e\u003c/footer\u003e --\u003e\r 顶部导航写在 header 标签中，router-outlet 是路由插座，当路由跳转时，我们导入的组件会替换掉 router-outlet 标签。登录成功后显示 Logout button，未登录或登出用户后显示 Login button。在 css 中做些样式调整，接下来是路由注册模块。新建一个 app-routing.module.ts 组件： import { NgModule } from '@angular/core';\rimport { Routes, RouterModule } from '@angular/router';\rconst routes: Routes = [\r{\rpath: 'login',\rloadChildren: () =\u003e import('./features/auth/auth.module').then((m) =\u003e m.AuthModule),\r},\r{\rpath: 'todos',\rloadChildren: () =\u003e import('./features/todo/todo.module').then((m) =\u003e m.TodoModule),\r},\r];\r@NgModule({\rimports: [RouterModule.forRoot(routes)],\rexports: [RouterModule],\r})\rexport class AppRoutingModule { }\r 我们注册了路由，因为我们会在导入的模块中进行状态管理，因此这里会用 Angular 中的 Lazy-loading 方式导入模块。这样，当路由匹配 login 时 auth.module.ts 中的 component 成为 main，当路由匹配 todos 时 todo.module.ts 中的 component 成为 main。 登录表单 在 auth.module.ts 只用一个登录组件，导入一些我们需要用到的表单模块。 @NgModule({\rimports: [\rCommonModule,\rFormsModule,\rReactiveFormsModule,\rMaterialModule,\rAuthRoutingModule,\r],\rdeclarations: [\rLoginComponent\r],\r})\rexport class AuthModule { }\r 先创建出 login 组件，可以用 cli 的方式生成：$ nest g component login，也可以手动新建文件：login.component.html，“error$ | async” 是因为我们传递的是 obeservable 对象，我们先不说 login.component.ts, 这一部分在后面的状态管理中再说。 \u003cmat-card\u003e\r\u003cmat-card-content\u003e\r\u003cform [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\"\u003e\r\u003ch2\u003eLogin\u003c/h2\u003e\r\u003cmat-error *ngIf=\"error$ | async\"\u003e\rThe username and password were not recognised\r\u003c/mat-error\u003e\r\u003cmat-form-field class=\"full-width-input\"\u003e\r\u003cinput matInput placeholder=\"Username\" formControlName=\"username\" required\u003e\r\u003cmat-error\u003e\rPlease provide a valid email address\r\u003c/mat-error\u003e\r\u003c/mat-form-field\u003e\r\u003cmat-form-field class=\"full-width-input\"\u003e\r\u003cinput matInput type=\"password\" placeholder=\"Password\" formControlName=\"password\" required\u003e\r\u003cmat-error\u003e\rPlease provide a valid password\r\u003c/mat-error\u003e\r\u003c/mat-form-field\u003e\r\u003cbutton mat-raised-button color=\"primary\"\u003eLogin\u003c/button\u003e\r\u003c/form\u003e\r\u003c/mat-card-content\u003e\r\u003c/mat-card\u003e\r 然后注册路由 auth-routing.module.ts： import { NgModule } from '@angular/core';\rimport { Routes, RouterModule } from '@angular/router';\rimport { LoginComponent } from './login/login.component';\rconst routes: Routes = [\r{\rpath: '',\rcomponent: LoginComponent,\r},\r];\r@NgModule({\rimports: [RouterModule.forChild(routes)],\rexports: [RouterModule],\r})\rexport class AuthRoutingModule { }\r todolist列表 创建 todo.component.html, 捕获 todolist 对应的增删改查事件： \u003cmat-card\u003e\r\u003cng-container *ngIf=\"vm$ | async as vm\"\u003e\r\u003ch2\u003eTodo Lists\u003c/h2\u003e\r\u003cmat-action-list role=\"list\"\u003e\r\u003capp-todo-list-item *ngFor=\"let todo of vm.todos\" [todo]=\"todo\" [loading]=\"vm.loading\"\r(update)=\"showEditDialog($event)\" (remove)=\"showRemoveDialog($event)\"\u003e\u003c/app-todo-list-item\u003e\r\u003c/mat-action-list\u003e\r\u003c/ng-container\u003e\r\u003c/mat-card\u003e\r\u003cdiv class=\"fab-bottom-right\"\u003e\r\u003cbutton mat-fab color=\"accent\" aria-label=\"Add\" (click)=\"showCreateDialog()\"\u003e\r\u003cmat-icon\u003eadd\u003c/mat-icon\u003e\r\u003c/button\u003e\r\u003c/div\u003e\r todo 单项 todolist 模板中的 remove, update 不是 js 原生事件, 我们需要注册对应的 EventEmitter，它是自定义事件触发与事件监听器功能的封装。todolist 列表是父组件，todo 单项是子组件。父子组件通讯需要用到 @Input() 和 @Output() 装饰器， @Input() 是父传子，@Output() 是子传父。todo-list-item.ts: @Component({\rselector: 'ap","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:1","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"登录验证 新建一个 services 文件夹，在其中新建 auth.service.ts 文件： @Injectable({\rprovidedIn: 'root'\r})\rexport class AuthService {\rprivate api: string = environment.apiUrl + '/auth';\rconstructor(private http: HttpClient, private router: Router, private store: Store) { }\rlogin(user: Partial\u003cUser\u003e) {\rreturn this.http.post\u003cUser\u003e(`${this.api}/signIn`, user).pipe(\rmergeMap((user: User) =\u003e {\rthis.token = user.access_token || '';\rthis.router.navigate(['todos']);\rreturn of(user);\r})\r);\r}\rget token() {\rreturn localStorage.getItem('access_token') || '';\r}\rset token(val: string) {\rif (val.length \u003e 0) {\rlocalStorage.setItem('access_token', val);\r}\r}\rlogout() {\rthis.store.dispatch(UserActions.logout());\rlocalStorage.clear();\r}\r}\r 为 token 创建一个setter, getter 方法，登录成功后，为 token 赋值，登出后，将 token 置空。providedIn: ‘root’ 表示我们的 service 是根级作用域。客服端判断用户是否登录成功的方法就是判断我们的 token 是否为空。而服务端将 token 作为验证用户的凭据。用户登录成功后，每次需要用户验证的请求都要求验证 token。我们可以使用拦截器(Interceptor) 对网络请求重新封装。 @Injectable()\rexport class AuthInterceptor implements HttpInterceptor {\rconstructor(public authService: AuthService) { }\rintercept(req: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e {\rconst authToken = this.authService.token;\rconst authReq = req.clone({\rheaders: req.headers.set(\"Authorization\", \"Bearer \" + authToken),\r});\rreturn next.handle(authReq);\r}\r}\r 当我们设置拦截器后，我们需要注册在根模块 app.module.ts 中。 providers: [\r{\rprovide: HTTP_INTERCEPTORS,\ruseClass: AuthInterceptor,\rmulti: true\r}\r],\r 添加了全局拦截器后我们就不必在每个请求接口都手动添加 header 的 bear 参数了。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:2","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"状态管理 状态管理是为了组件之间的数据共享。组件数据发生变化后，不通过不同组件传值这样的方式，而通过一个叫 store 的东西统一管理状态数据，监听状态数据变化。 打印日志 新建一个store文件夹，里面新建 app.state.ts 文件，将路由变化 router 加入到 AppState 中。 import { RouterReducerState } from '@ngrx/router-store';\rexport interface AppState {\rrouter: RouterReducerState;\r}\r 创建一个 reducers 文件夹, 里面新建 logger.reducer.ts: import { ActionReducer } from '@ngrx/store';\rimport { AppState } from '../app.state';\rexport function logger(reducer: ActionReducer\u003cAppState\u003e): ActionReducer\u003cAppState\u003e {\rreturn (state, action) =\u003e {\rconst result = reducer(state, action);\rconsole.groupCollapsed(action.type);\rconsole.log('prev state', state);\rconsole.log('action', action);\rconsole.log('next state', result);\rconsole.groupEnd();\rreturn result;\r};\r}\r 这是参考了 NgRx 在 github 上的官方示例 的做法，实现一个控制台的日志打印，当然我们也可以在浏览器安装 redux 扩展程序。新建 index.ts，开发环境下就有日志打印: import { ActionReducerMap, MetaReducer } from '@ngrx/store';\rimport * as fromRouter from '@ngrx/router-store';\rimport { environment } from '../../../environments/environment';\rimport { logger } from './logger.reducer';\rimport { AppState } from '../app.state';\rexport const reducers: ActionReducerMap\u003cAppState\u003e = {\rrouter: fromRouter.routerReducer,\r};\rexport const metaReducers: MetaReducer\u003cAppState\u003e[] = !environment.production ? [logger] : [];\r 理解状态管理 写本篇文章的目的之一是将状态管理实践验证。之前我有说前端的状态管理相当于后端的数据库。接下来我将一步一步的验证这个说法。下面以用户状态来讲解。 定义初始状态类似于数据库的创建，action 是 store 数据的来源入口，从NgRx官网示意图中我们可以看到它可以来自用户操作(component)，也可以来自网络请求(effects)，reducer 类似于数据表，那 adapter, selector, effects 又分别是什么呢？ \r按照 Redux 的约定，reducer 必须是纯函数，只接收旧状态，只返回新状态。我们操作数据表时，实际上是对数据表中的列做操作，而 adapter 就是 reducer 中的列，对数据的增删改查就是对 adapter 的增删改查。selector 类似于 sql 中的 select 语句。而 effects 负责传递数据，和一些 DOM 操作，使用 NgRx 这套流程时，在 component 中需要做的唯一事情就是 dispatch action, 额外的事情就交给 effects 来做。 下面给出代码实例，可以结合代码来理解这段话。 ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:3","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"代码实例 初始化 reducer 表 初始状态(initialState)是定义在 reducer 中的，user.state.ts: import { EntityState, createEntityAdapter } from '@ngrx/entity';\rimport { User } from 'src/app/models/user.model';\rexport const featureName = 'user';\rexport interface State extends EntityState\u003cUser\u003e {\rneedAuth: boolean;\rselectedId?: string;\rerror?: any;\r}\rexport const adapter = createEntityAdapter\u003cUser\u003e();\rexport const initialState: State = adapter.getInitialState({\rneedAuth: false,\r});\r 注册 reducer 表 featureName 是我们的 reducer 表名，根模块注册时，StoreModule.forRoot(featureName, reducer)。 其他模块注册时，StoreModule.forFeature(featureName, reducer), 当在其他模块注册时，仍然需要在根模块配置 StoreModule.forRoot({})。在局部注册是一种减轻服务器压力的方式。 action 数据来源 定义 Action 作为 store 数据来源，props 接收数据参数。 import { createAction, props } from '@ngrx/store';\rimport { User } from 'src/app/models/user.model';\rexport const login = createAction(\r'[Auth Page] User Login',\rprops\u003c{ user: Partial\u003cUser\u003e }\u003e()\r);\rexport const loginSuccess = createAction(\r'[Auth Page] Login Success',\rprops\u003c{ user: User }\u003e()\r);\rexport const loginFailure = createAction(\r'[Auth Page] Login Failure',\rprops\u003c{ error: any }\u003e()\r);\rexport const logout = createAction('[Auth Page] User Logut');\r effects 钩子函数 effects 钩取相应 action(login) 后，发送网络请求，并触发新的 action(loginSuccess 或者 loginFailure)。effects 与 action 数据交互方式是双向的。 @Injectable()\rexport class UserEffects {\rconstructor(\rprivate actions$: Actions,\rprivate authService: AuthService\r) { }\rlogin$ = createEffect(() =\u003e\rthis.actions$.pipe(\rofType(UserActions.login),\rconcatMap(({ user }) =\u003e\rthis.authService.login(user).pipe(\rmap((result) =\u003e UserActions.loginSuccess({ user: result })),\rcatchError((error) =\u003e of(UserActions.loginFailure({ error })))\r)\r)\r),\r);\r}\r adapter 数据表列 action 传递数据给 reducer 表, reducer 表在 loginSuccess 时就新增一列数据。 export const reducer = createReducer(\rinitialState,\ron(UserActions.login, (state) =\u003e {\rreturn { ...state, needAuth: true };\r}),\ron(UserActions.loginSuccess, (state, { user }) =\u003e {\rreturn adapter.addOne(user, { ...state, needAuth: false });\r}),\ron(UserActions.loginFailure, (state, { error }) =\u003e {\rreturn { ...state, needAuth: true, error };\r}),\ron(UserActions.logout, (state) =\u003e {\rreturn { ...state, needAuth: true };\r}),\r);\r selector 状态切片 我们要将新的状态作用到 component 上，这个时候就需要 selector 在 reducer 中查询，创建 user.selector.ts: const getUserState = createFeatureSelector\u003cState\u003e(featureName);\rconst { selectEntities } = adapter.getSelectors();\rexport const getLogin = createSelector(\rgetUserState,\r(state) =\u003e state.needAuth\r);\rexport const getError = createSelector(getUserState, (state) =\u003e state.error);\rexport const getSelectedId = createSelector(\rgetUserState,\r(state) =\u003e state.selectedId\r);\rexport const getUserEntities = createSelector(getUserState, selectEntities);\rexport const getUser = createSelector(\rgetSelectedId,\rgetUserEntities,\r(id, entities) =\u003e (id ? entities[id] : undefined)\r);\r 在 login.component.ts 中得到新的状态： error$ = this.store.pipe(select(UserSelectors.getError));\rneedAuth$ = this.store.pipe(select(UserSelectors.getLogin));\r 变量中的 $ 表示得到的数据是 Observable 对象。我们可以直接将 Observable 渲染在html 中： \u003cmat-error *ngIf=\"error$ | async\"\u003e\rThe username and password were not recognised\r\u003c/mat-error\u003e\r 也可以取订阅后的布尔值 error$.subscribe(data =\u003e data)。 在 component 中填写完登录表单后, 只需 dispatch action: this.store.dispatch(UserActions.login({ user }));\r 状态数据就在 component, store 之间来回传递。最后的程序如图： \r","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:4","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"思考 看到这里，你会发现，我们绕了一圈做了一件简单的事。但你可以想象，前端框架的组件化开发方式，组件之间的通信基本都是单向数据流，要是没有状态管理，父子组件还好，相隔很远的组件，只能通过一级一级向上传，再一级一级向下传，会更加麻烦。 对于 angular, 简单的数据状态，我们可以直接定义在 service 中，通过 DI(依赖注入) 的方式能够很方便地作用到不同的 component 中。这是 angular 比其他前端框架优秀的地方之一。 附：源码地址 参考资料 NgRx 官方文档 Angular 真的需要状态管理么？ ","date":"2020-04-25","objectID":"/2020-04-25-typescript-fullstack/:2:5","tags":["Angular","Rx"],"title":"用 NgRx 和 Nest 写一个全栈 todolist","uri":"/2020-04-25-typescript-fullstack/"},{"categories":["Coding"],"content":"本文主要讲述如何用 typeorm 建表，建立一对一，一对多，多对多的关系，建立表的外连接。 以及在 typeorm 做查询操作的两种常用方式：Find 选项 和 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:0:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"建表 typeorm 建表时，将 @Entity() 装饰的 class 映射为数据表，entity 中 @PrimaryColumn() 装饰的属性作为表的主键, @PrimaryGeneratedColumn() 表示自动生成主键, @Column() 装饰属性作为表的属性。 @Entity()\rexport class Photo {\r@PrimaryGeneratedColumn()\rid: number;\r@Column({length: 100})\rname: string;\r@Column(\"text\")\rdescription: string;\r@Column()\rviews: number;\r@Column()\risPublished: boolean;\r}\r 数据库中的列类型是根据你使用的属性类型推断的，例如: number 将被转换为 integer，string 将转换为 varchar，boolean 转换为 bool 等。下面我们从实际的例子出发探索如何用 typeorm 建一对一、一对多、多对多的关系。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:1:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"一对一 用户 user 和用户档案 profile 是一对一关系，一个用户只有一份档案。 @Entity('users')\rexport class UserEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rusername: string;\r@OneToOne(type =\u003e ProfileEntity, profile =\u003e profile.user)\r@JoinColumn()\rprofile: ProfileEntity;\r}\r 注意 profile 是 ProfileEntity 类型的，在数据库中存储的类型却是 profile.id 的类型。 @OneToOne 中需要指明对方 entity 的类型，指明对方 entity 的外键。@JoinColumn 必须在且只在关系的一侧的外键上。 @Entity('profiles')\rexport class ProfileEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rgender: string;\r@Column()\rphoto: string;\r@OneToOne(type =\u003e UserEntity, user =\u003e user.profile)\ruser: UserEntity;\r}\r 这将生成以下数据表： +-------------+--------------+----------------------------+\r| users |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| username | varchar(255) | |\r| profileId | int(11) | FOREIGN KEY |\r+-------------+--------------+----------------------------+\r+-------------+--------------+----------------------------+\r| profiles |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| gender | varchar(255) | |\r| photo | varchar(255) | |\r+-------------+--------------+----------------------------+\r ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:2:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"一对多 用户 user 与用户发布的文章 article 是一对多关系，一个用户可发布多篇文章。 @Entity('users')\rexport class UserEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rusername: string;\r@OneToMany(type =\u003e ArticleEntity, article =\u003e article.author)\rarticles: ArticleEntity[];\r}\r @OneToMany，@ManyToOne 中需要指明对方的 entity 类型，指明对方 entity 的外键。 @Entity('articles')\rexport class ArticleEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rtitle: string;\r@ManyToOne(type =\u003e UserEntity, user =\u003e user.articles)\rauthor: UserEntity;\r}\r typeorm 在处理 “一对多”关系时将“一”的主键作为“多”的外键 (即 @ManyToOne 装饰的属性)，建表时有最少的数据表操作代价，避免数据冗余，提高效率。这会生成以下表： +-------------+--------------+----------------------------+\r| articles |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| title | varchar(255) | |\r| authorId | int(11) | |\r+-------------+--------------+----------------------------+\r+-------------+--------------+----------------------------+\r| users |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| username | varchar(255) | |\r+-------------+--------------+----------------------------+\r ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:3:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"多对多 用户 user 对文章 article 的喜欢 favorite 是多对多关系。一个用户可对多篇文章标记喜欢，一篇文章可被多个用户标记喜欢。 @Entity('users')\rexport class UserEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rusername: string;\r@ManyToMany(type =\u003e ArticleEntity, article =\u003e article.favoritedBy)\rfavorites: ArticleEntity[];\r}\r @OneToMany 中需要指明对方的 entity 类型，指明对方 entity 的外键。@JoinTable 必须在且只在关系的一侧的外键上。 @Entity('articles')\rexport class ArticleEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column()\rtitle: string;\r@ManyToMany(type =\u003e UserEntity, user =\u003e user.favorites)\r@JoinTable()\rfavoritedBy: UserEntity[];\r}\r typeorm 的处理方式是将多对多关系转化为两个一对多关系: 用户 user 与 喜欢 favorites 一对多。 文章 article 与被喜欢 favoritedBy 一对多。 多对多关系需要采用中间表的方式处理，这是为了避免笛卡尔积的出现。这会生成以下表： +-------------+--------------+----------------------------+\r| users |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| username | varchar(255) | |\r+-------------+--------------+----------------------------+\r+-------------+--------------+----------------------------+\r| articles |\r+-------------+--------------+----------------------------+\r| id | int(11) | PRIMARY KEY AUTO_INCREMENT |\r| title | varchar(255) | |\r+-------------+--------------+----------------------------+\r+-------------+--------------+----------------------------+\r| articles_favorited_by_users |\r+-------------+--------------+----------------------------+\r| articlesId | int(11) | PRIMARY KEY FOREIGN KEY |\r| usersId | int(11) | PRIMARY KEY FOREIGN KEY |\r+-------------+--------------+----------------------------+\r ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:4:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"增删改查 创建好一对一，一对多，多对多的实体 entity 后，我们如何做增删改查呢？单个实体的 crud 可参考我的这一篇文章。而关联后的实体对象会作为该实体对象的一个属性, 直接对属性进行操作即可。如下是文章被用户喜欢的实现: async favoriteArticle(slug: string, user: UserEntity) {\rconst article = await this.articleRepo.findOne({ where: { slug }});\rarticle.favoritedBy.push(user);\rawait article.save();\rreturn article;\r}\r crud 操作中查询操作是我们最常遇到的，下面讲如何查询，typeorm 支持两种查询方式：Find 选项 和 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:0","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"Find 选项 在 Nest.JS 中，对具体实体的管理（insert, update, delete, load 等)我们使用的是 Repository。对应的查找方法是：Repository.find(FindOptions)。 使用 find 查询只能获得一种类型的结果：entities。 find 选项的完整例子如下： userRepository.find({\rselect: [\"username\"],\rrelations: [\"profile\", \"article\"，\"article.favoritedBy\"],\rwhere: {\rusername: \"Timber\",\r},\rorder: {\rid: \"DESC\"\r},\rskip: 5,\rtake: 10,\rcache: true\r});\r 直接使用 find 是不会查出关联的对象的，要查询的关联对象需要添加到 relations 数组中。 除了 relations 以外，其他选项等同于原生 sql 操作, order 等同于 order by, skip 等同于 offset, take 等同于 limit, cache 是查询缓存。细节请参考 Find 选项。 这种查询有个局限就是只能查询到关联对象的整个实体或主键。而不能 select 关联实体的其他属性。因此更复杂的查询我们需要使用 QueryBuilder。 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:1","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"QueryBuilder 使用QueryBuilder 查询可以获得两种类型的结果：entities 或原始数据。 要获取entities，请使用getOne和getMany。 要获取原始数据，请使用getRawOne和getRawMany。 它能够很方便的帮我们构造出 sql 语句，addSelect() 可以获取关联对象上的其他属性。 if (query.author) {\rconst article = await getRepository(ArticleEntity)\r.createQueryBuilder('article')\r.select(\"article.id\", 'id')\r.addSelect('favoritedBy.username', 'name')\r.leftJoin('article.favoritedBy', 'favoritedBy')\r.where(\"favoritedBy.username = :name\", { name: query.author })\r.getRawMany();\r}\r 获取生成的 sql 语句可以在 getRawMany() 前获取 getSql() 或打印 printSql() 生成的sql语句。细节请参考 Query Builder。 参考资料 Typeorm 官方文档 ","date":"2020-04-10","objectID":"/2020-04-10-typeorm/:5:2","tags":["TypeORM"],"title":"TypeORM 的基本使用","uri":"/2020-04-10-typeorm/"},{"categories":["Coding"],"content":"鉴权(authentication)是指验证用户是否拥有访问系统的权利。传统的鉴权是通过密码来验证的。这种方式的前提是，每个获得密码的用户都已经被授权。 ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:0:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"建立用户表，密码散列 要实现鉴权认证，首先需要一张 user 表。上一次我们用 NestJS 和 Typeorm 做了最基本的 crud 操作, 这次我们用 NestJS 和 node 中最流行的身份验证库 Passport 来完成鉴权认证。为了方便，我们直接沿用上次的代码库。 创建 user module: $ nest g mo user 然后在 user 文件夹新建 user.entity.ts, 其中我们做了密码散列: import { BeforeInsert, Column, Entity, PrimaryGeneratedColumn } from 'typeorm'\rimport * as bcrypt from 'bcryptjs';\r@Entity('user')\rexport class UserEntity {\r@PrimaryGeneratedColumn()\rid: number\r@Column({ length: 20 })\rusername: string\r@Column({ length: 255 })\rpassword: string\r@BeforeInsert()\rasync hashPassword() {\rthis.password = await bcrypt.hash(this.password, 10);\r}\r}\r 在 user.module.ts 中注册 user 表：TypeOrmModule.forFeature([UserEntity]) 上一次我们直接在 module 中写了数据库连接配置，其实更常见的做法是写一个数据库配置文件。可以用环境变量设置数据库连接，这是 typeorm 数据库连接配置的参考地址。在文件夹建立一个 .env 文件： # App\rJWT_SECRET = 'ThisIsASecretKey'\r# Database\rTYPEORM_CONNECTION = mysql\rTYPEORM_HOST = localhost\rTYPEORM_USERNAME = root\rTYPEORM_PASSWORD = 123456\rTYPEORM_DATABASE = test\rTYPEORM_PORT = 3306\rTYPEORM_SYNCHRONIZE = true\rTYPEORM_LOGGING = true\rTYPEORM_ENTITIES = dist/**/*.entity.js\r 其中写了数据库配置和自定义的 jwt 密匙，关于如何生成 jwt 格式的字符串, 可以看这篇文章, 本文只讲如何使用它来做用户登录验证。 在 app.module.ts 的imports数组中修改数据库为注册：TypeOrmModule.forRoot()，然后写入 UserModule。测试一下我们的数据库连接情况：$ npm run start, 控制台打印了 sql 语句，说明我们的连接配置是对的。查看数据库会发现新增加了 user 表。 在 user 文件夹新建 user.dto.ts： import { IsString } from 'class-validator'\rimport { ApiProperty } from '@nestjs/swagger';\rexport class UserDto {\r@ApiProperty()\r@IsString()\rreadonly username: string;\r@ApiProperty()\r@IsString()\rreadonly password: string;\r}\r 然后创建 user service：$ nest g s user，注意在 createUser 方法中一定要先 实例化 user, 再返回创建的对象。否则 user.entity.ts 中的 @BeforeInsert() 装饰的方法不会执行，密码就不会取散列后的值。 import { Injectable } from '@nestjs/common'\rimport { InjectRepository } from '@nestjs/typeorm'\rimport { UserEntity } from './user.entity'\rimport { Repository } from 'typeorm'\rimport { UserDto } from './user.dto'\r@Injectable()\rexport class UserService {\rconstructor(\r@InjectRepository(UserEntity)\rprivate readonly userRepository: Repository\u003cUserEntity\u003e,\r) { }\rasync createUser(userDto: UserDto) {\r// const user = Object.assign(new UserEntity(), userDto)\r const user = this.userRepository.create(userDto);\rreturn await this.userRepository.save(user);\r}\rasync findUsername(username: string) {\rreturn this.userRepository.findOne({ where: { username } })\r}\rasync findAll(): Promise\u003cUserEntity[]\u003e {\rreturn await this.userRepository.find();\r}\r}\r ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:1:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"实现本地认证策略 实现本地认证策略需要先安装以下依赖： yarn add @nestjs/passport passport passport-local\ryarn add -D @types/passport-local\r 说明一下，这一步不是必须的。其实本地认证就是做用户名和密码的核对，我们自己去实现也不算麻烦。但是为了和 NestJS 官网教程保持一致，我们也这样做。 创建 auth module: $ nest g mo auth，在 auth 目录下创建一个 local.strategy.ts 文件： import { Injectable, UnauthorizedException } from '@nestjs/common'\rimport { PassportStrategy } from '@nestjs/passport'\rimport { Strategy } from 'passport-local'\rimport { AuthService } from './auth.service'\r@Injectable()\rexport class LocalStrategy extends PassportStrategy(Strategy) {\rconstructor(private readonly authService: AuthService) {\rsuper()\r}\rasync validate(username: string, password: string) {\rconst user = await this.authService.validateUser(username, password)\rif (!user) {\rthrow new UnauthorizedException()\r}\rreturn user\r}\r}\r 使用 @nestjs/passport ，你需要继承 PassportStrategy 类来配置 passport 策略。通过调用子类中的 super() 方法传递策略选项，通过在子类中实现 validate() 方法，可以提供verify回调。Passport 定义的 所有策略 都是将validate() 方法执行的结果作为 user 属性存储在当前 HTTP Request 对象 上,你也可以自定义此属性的名称。上面文件中的 validateUser 方法需要在 auth.service.ts 自己实现，因为框架不清楚你定义的密码散列方式。 //auth.service.ts\r\r...\rasync validateUser(username: string, pass: string): Promise\u003cany\u003e {\rconst user = await this.userService.findUsername(username);\rconsole.log('-----------Login-----------')\rif (user \u0026\u0026 bcrypt.compareSync(pass, user.password)) {\rreturn user;\r}\rreturn null;\r}\r ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:2:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"实现注册登录功能 创建 auth controller: $ nest g co auth，路由功能： import { UserDto } from './../user/user.dto';\rimport { Body, Controller, Get, Post, UseGuards, Res, Request } from '@nestjs/common'\rimport { AuthGuard } from '@nestjs/passport'\rimport { ApiTags, ApiBearerAuth } from '@nestjs/swagger'\rimport { AuthService } from 'src/auth/auth.service'\r@ApiBearerAuth()\r@ApiTags('Auth')\r@Controller('auth')\rexport class AuthController {\rconstructor(\rprivate readonly authService: AuthService,\r) { }\r@UseGuards(AuthGuard('jwt'))\r@Get('users')\rasync findAll(@Request() req): Promise\u003cany[]\u003e {\rconsole.log('--------------Auth--Success---------------')\rconsole.log(req.user);\rreturn await this.authService.findAll();\r}\r@Post('signUp')\rasync register(@Body() req: UserDto, @Res() res) {\rconst result = await this.authService.register(req);\rres.status(result.statusCode).send(result);\r}\r@UseGuards(AuthGuard('local'))\r@Post('signIn')\rasync login(@Body() @Request() req: UserDto, @Res() res) {\rconsole.log('----------Login--Success-----------')\rconsole.log(req);\rconst result = await this.authService.login(req);\rres.status(result.statusCode).send(result);\r}\r}\r 注意其中的 @UseGuards(AuthGuard(‘local’)) 装饰器，因为我们写了 local.strategy.ts文件，其中继承了 PassportStrategy 类，并实现了 validate 方法。@nestjs/passport 就会为我们实现一个 AuthGuard，我们直接在需要验证的路由前使用就好。@UseGuards(AuthGuard(‘jwt’)) 是我们接下来要讲的 JWT 认证策略。 再补充完整 auth.service.ts 文件： // auth.service.ts\r\rimport { BadRequestException, Injectable, Body, Request } from '@nestjs/common'\rimport { UserService } from '../user/user.service'\rimport { JwtService } from '@nestjs/jwt'\rimport * as bcrypt from 'bcryptjs';\r@Injectable()\rexport class AuthService {\rconstructor(\rprivate readonly userService: UserService,\rprivate readonly jwtService: JwtService,\r) { }\rasync findAll(): Promise\u003cany[]\u003e {\rreturn await this.userService.findAll();\r}\rasync validateUser(username: string, pass: string): Promise\u003cany\u003e {\rconst user = await this.userService.findUsername(username);\rconsole.log('-----------Login-----------')\rif (user \u0026\u0026 bcrypt.compareSync(pass, user.password)) {\rreturn user;\r}\rreturn null;\r}\rasync register(user: any) {\rlet userData: any;\ruserData = await this.userService.findUsername(user.username);\rif (userData) {\rreturn { statusCode: 400, message: 'This username aleady exists' };\r}\rawait this.userService.createUser(user);\ruserData = await this.userService.findUsername(user.username);\rreturn {\rusername: userData.username,\rstatusCode: 201\r};\r}\rasync login(user: any) {\rreturn this.userService.findUsername(user.username).then((userData) =\u003e {\rconst Token = this.createToken(userData);\rreturn {\rusername: userData.username,\raccess_token: Token,\rstatusCode: 200\r}\r});\r}\rcreateToken(user: any) {\rconst payload = { username: user.username, sub: user.id };\rreturn this.jwtService.sign(payload);\r}\r}\r ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:3:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"实现 JWT 认证策略 实现了用户注册登录后，我们需要保护 API，限制有的路由地址需要用户登录后才能访问，有的路由地址需要管理员登录后才能访问。我们这里只实现需要普通用户登录后才能访问的路由。 什么是Token？ 前后端分离模式下，Token 是我们验证用户登录的常用方式。Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器会生成一个Token并将此Token，返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。 为什么要使用Token？ 在很多项目案例中，需要实现账户的功能，客户端所有的功能都基于用户已登陆的前提下才可以使用。这就要求每次客户端向服务器请求数据时都要验证账户是否正确，如果正确则按正常方式返回数据，如果错误则进行拦截并返回错误信息。但是当客户端频繁向服务器请求数据的话，每次服务器都要频繁地查询数据库。而Token正是为了 减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。并取代传统使用session的方法来进行验证。 在 Nest.js 中使用 jwt(json web token), 我们需要安装以下依赖： yarn add @nestjs/jwt passport-jwt\ryarn add -D @types/passport-jwt\r 我们在 auth.service.ts 中已经实现了生成 jwt 字符串的方法，在用户登录路由中就会调用，并返回 jwt 字符串： createToken(user: any) {\rconst payload = { username: user.username, sub: user.id };\rreturn this.jwtService.sign(payload);\r}\r 注意 上面 sign 的参数 payload 是可逆加密的，拿到 token 后是可以解密成明文内容的，所以这部分不要放敏感信息。 我们已经创建了 jwt 字符串作为请求令牌，那么服务端如何根据 jwt 字符串的内容，找到用户信息？ 我们就需要实现 jwt 认证策略，在 auth 文件夹下新建 jwt.strategy.ts 文件： import { Injectable } from '@nestjs/common'\rimport { PassportStrategy } from '@nestjs/passport'\rimport { ExtractJwt, Strategy } from 'passport-jwt'\rimport { JWT_SECRET } from 'config'\r@Injectable()\rexport class JwtStrategy extends PassportStrategy(Strategy) {\rconstructor() {\rsuper({\rjwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\rignoreExpiration: false,\rsecretOrKey: JWT_SECRET,\r})\r}\rasync validate(payload: any) {\rreturn { userId: payload.sub, username: payload.username };\r}\r}\r 解释一下，对于 JWT 策略，Passport 首先验证 JWT 的签名并解码为 JSON 格式内容。仅在 @nestjs/passport 模块验证令牌有效后，才调用 validate() 方法。该方法将解码后的 JSON 作为其单个参数继续传递。否则。将阻止请求，抛出 401 Unauthorized 的异常。 现在来看我们的auth.controller.ts，可以将 validate() 返回值输出到控制台： // auth.controller.ts\r\r@UseGuards(AuthGuard('jwt'))\r@Get('users')\rasync findAll(@Request() req): Promise\u003cany[]\u003e {\rconsole.log('--------------Auth--Success---------------')\rconsole.log(req.user);\rreturn await this.authService.findAll();\r}\r 最后这是我们的 auth.module.ts，其中注册了 jwt 字符串过期时间，我们在 auth.service.ts 中注入了 UserService，记得导入 UserModule。 // auth.module.ts\r @Module({\rimports: [\rPassportModule,\rJwtModule.register({\rsecret: JWT_SECRET,\rsignOptions: { expiresIn: '3600s' },\r}),\rUserModule,\r],\rcontrollers: [AuthController],\rproviders: [AuthService, LocalStrategy, JwtStrategy],\rexports: [AuthService],\r})\rexport class AuthModule { }\r 启动项目：$ npm run start:dev，打开 http://localhost:3000/docs 在 swagger 文档模型中测试我们的 api。先 signUp, 然后 signIn, 登录成功返回 access_token，点击那个锁符号，将 access_token 的值粘贴过去，就能通过认证了。 附：源码地址 参考资料 Nest.JS 官方文档 Typeorm 官方文档 Node.js JWT 范例 ","date":"2020-03-29","objectID":"/2020-03-29-nest-auth/:4:0","tags":["Nest","Passport"],"title":"NestJS + Passport 实现鉴权认证","uri":"/2020-03-29-nest-auth/"},{"categories":["Coding"],"content":"本篇文章将介绍如何用 Spring boot 与 Vue.js 创建一个具有基本 crud 功能的全栈 web 应用，我们将使用 bootstrap 作为项目的 UI 库，适合 web 开发初学者阅读。 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:0:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"后端接口 到 https://start.spring.io/ 去生成和下载 spring 应用，Group 填写 com.jpa，Artifact 填写 spring-jpa-demo， 其他默认选择就好，点击 Generate 就会生成并下载名压缩包，将压缩包解压，并在编辑器中打开。 我们使用 jpa 作为我们的 orm, 连接 mysql 数据库，因此在 pom.xml 中加入以下依赖。 \u003c!-- jpa driver --\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\r\u003cartifactId\u003espring-boot-starter-data-jpa\u003c/artifactId\u003e\r\u003c/dependency\u003e\r\u003c!-- spring web driver --\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\r\u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e\r\u003c/dependency\u003e\r\u003c!-- MySQL database driver --\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003emysql\u003c/groupId\u003e\r\u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e\r\u003c/dependency\u003e\r\u003c!-- Skip test plugin --\u003e\r\u003cplugin\u003e\r\u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e\r\u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e\r\u003cversion\u003e2.22.2\u003c/version\u003e\r\u003cconfiguration\u003e\r\u003cskipTests\u003etrue\u003c/skipTests\u003e\r\u003c/configuration\u003e\r\u003c/plugin\u003e\r ","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"I. 数据库连接 编写数据库连接文件 application.properties，它在 resources 文件夹中。 ## use create when running the app for the first time\r## then change to \"update\" which just updates the schema when necessary\rspring.datasource.url=jdbc:mysql://localhost:3306/notesapi?createDatabaseIfNotExist=true\u0026useSSL=false\u0026serverTimezone=UTC\rspring.datasource.username=root\rspring.datasource.password=root\rspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r## this shows the sql actions in the terminal logs\rspring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect\rspring.jpa.hibernate.ddl-auto=update\rspring.jpa.show-sql=true\rspring.jpa.properties.hibernate.format_sql=true\r##optional, but just in case another application is listening on your default port (8080)\rserver.port = 8034\r 这是我们的 src 文件夹结构，接下来的文件都会在 src 中编写。 \r在 entity文件夹中新建文件 Notes.java，这是我们的数据表映射。 package com.jpa.springjpademo.entity;\rimport javax.persistence.*;\rimport org.hibernate.annotations.CreationTimestamp;\rimport org.hibernate.annotations.GenericGenerator;\rimport org.hibernate.annotations.UpdateTimestamp;\rimport java.util.Date;\r@Entity\r@Table(name = \"notes_table\")\r@GenericGenerator(name = \"jpa-uuid\", strategy = \"uuid\") // 这个是hibernate的注解/生成32位UUID\rpublic class Notes {\r@Id\r@GeneratedValue(generator = \"jpa-uuid\")\r@Column(name = \"notes_id\", nullable = false, length = 32)\rprivate String notes_id;\r// 默认创建时间\r @Column(name = \"create_time\")\r@Temporal(TemporalType.TIMESTAMP)\r@CreationTimestamp\rprivate Date time;\r// 默认更新时间\r @Column(name = \"update_time\")\r@Temporal(TemporalType.TIMESTAMP)\r@UpdateTimestamp\rprivate Date update_time;\r@Column(name = \"title\", nullable = true, length = 100)\rprivate String title;\r@Column(name = \"description\", nullable = true, length = 255)\rprivate String description;\r@Column(name = \"content\", nullable = true)\r@Lob\r@Basic(fetch = FetchType.LAZY)\rprivate String content;\r@Column(name = \"author\", nullable = true, length = 50)\rprivate String author;\rpublic String getId() {\rreturn notes_id;\r}\rpublic void setId(String notes_id) {\rthis.notes_id = notes_id;\r}\rpublic String getTitle() {\rreturn title;\r}\rpublic void setTitle(String title) {\rthis.title = title;\r}\rpublic String getDescription() {\rreturn description;\r}\rpublic void setDescription(String description) {\rthis.description = description;\r}\rpublic String getContent() {\rreturn content;\r}\rpublic void setContent(String content) {\rthis.content = content;\r}\rpublic String getAuthor() {\rreturn author;\r}\rpublic void setAuthor(String author) {\rthis.author = author;\r}\rpublic void setUpdateTime(Date update_time) {\rthis.update_time = update_time;\r}\rpublic Date getUpdateTime() {\rreturn update_time;\r}\r}\r 在 dao 文件夹中新建文件 NotesDao.java, 只需实现 JpaRepository 接口，我们就能够连接到数据库。 package com.jpa.springjpademo.dao;\rimport com.jpa.springjpademo.entity.Notes;\rimport org.springframework.data.jpa.repository.JpaRepository;\rimport org.springframework.stereotype.Repository;\r@Repository\rpublic interface NotesDao extends JpaRepository\u003cNotes, String\u003e {\r}\r 接下来终端执行 $ mvn clean package 下载依赖，编译代码。然后 $ mvn spring-boot:run 运行项目。项目运行起来后刷新数据库，可以看到新生成名为 notesapi 的数据库，其中有一个名为 notes_table 的数据表。表示我们的数据库连接成功。 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:1","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"II. 增删改查 五步实现完整的数据增删改查和接口测试： 1.实现 Conctroller 路由处理 2.实现 Service 数据库操作 3.实现 Exception 异常捕获 4.实现 Cors 跨域配置 5.实现 Swagger 文档配置 下面是详细步骤和代码示例： 实现 Conctroller 路由处理： package com.jpa.springjpademo.controller;\rimport com.jpa.springjpademo.entity.Notes;\rimport com.jpa.springjpademo.service.NotesService;\rimport org.springframework.http.ResponseEntity;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.http.MediaType;\rimport org.springframework.web.bind.annotation.*;\rimport java.util.List;\r@RestController\r@RequestMapping(\"/api/notes\")\rpublic class NotesController {\r@Autowired\rNotesService notesService;\r@RequestMapping(value = \"/all\", method = RequestMethod.GET)\rpublic List\u003cNotes\u003e getAllNotes() {\rreturn notesService.getAllNotes();\r}\r@RequestMapping(value = \"/create\", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)\rpublic Notes addNotes(@RequestBody Notes notes) {\rreturn notesService.addNotes(notes);\r}\r@RequestMapping(value = \"/update\", method = RequestMethod.PUT, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)\rpublic Notes updateNotes(@RequestParam(\"notes_id\") String id, @RequestBody Notes notes) {\rreturn notesService.updateNotes(id, notes);\r}\r@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\rpublic Notes getNotes(@PathVariable(\"id\") String id) {\rreturn notesService.getNotesById(id);\r}\r@RequestMapping(value = \"/delete/all\", method = RequestMethod.DELETE)\rpublic void deleteAllNotes() {\rnotesService.deleteAllNotes();\r}\r@RequestMapping(value = \"/delete\", method = RequestMethod.DELETE)\rpublic ResponseEntity\u003c?\u003e deleteNotes(@RequestParam(\"notes_id\") String id) {\rreturn notesService.deleteNotesById(id);\r}\r}\r 实现 Service 数据库操作： package com.jpa.springjpademo.service;\rimport com.jpa.springjpademo.dao.NotesDao;\rimport com.jpa.springjpademo.entity.Notes;\rimport com.jpa.springjpademo.exception.ResourceNotFoundException;\rimport org.springframework.beans.factory.annotation.Autowired;\rimport org.springframework.http.ResponseEntity;\rimport org.springframework.stereotype.Service;\rimport java.util.List;\r@Service\rpublic class NotesService {\r@Autowired\rNotesDao notesDao;\rpublic List\u003cNotes\u003e getAllNotes() {\rreturn notesDao.findAll();\r}\rpublic Notes addNotes(Notes notes) {\rreturn notesDao.save(notes);\r}\rpublic Notes getNotesById(String id) {\rreturn notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id));\r}\rpublic Notes updateNotes(String id, Notes notes) {\rNotes tnotes = notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id));\rtnotes.setTitle(notes.getTitle());\rtnotes.setDescription(notes.getDescription());\rtnotes.setContent(notes.getContent());\rtnotes.setAuthor(notes.getAuthor());\rreturn notesDao.save(tnotes);\r}\rpublic ResponseEntity\u003c?\u003e deleteNotesById(String id) {\rNotes notes = notesDao.findById(id).orElseThrow(() -\u003e new ResourceNotFoundException(\"Notes\", \"id\", id));\rnotesDao.delete(notes);\rreturn ResponseEntity.ok().build();\r}\rpublic void deleteAllNotes() {\rnotesDao.deleteAll();\r}\r}\r 实现 Exception 异常捕获： package com.jpa.springjpademo.exception;\rimport org.springframework.http.HttpStatus;\rimport org.springframework.web.bind.annotation.ResponseStatus;\r@ResponseStatus(value = HttpStatus.NOT_FOUND)\rpublic class ResourceNotFoundException extends RuntimeException {\rprivate static final long serialVersionUID = 1L;\rprivate String resourceName;\rprivate String fieldName;\rprivate Object fieldValue;\rpublic ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {\rsuper(String.format(\"%s not found with %s : '%s'\", resourceName, fieldName, fieldValue));\rthis.resourceName = resourceName;\rthis.fieldName = fieldName;\rthis.fieldValue = fieldValue;\r}\rpublic String getResourceName() {\rreturn resourceName;\r}\rpublic String getFieldName() {\rreturn fieldName;\r}\rpublic Object getFieldValue() {\rreturn fieldValue;\r}\r}\r 实现 Cors 跨域配置： pac","date":"2020-03-21","objectID":"/2020-03-21-spring/:1:2","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"前端界面 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"I. 初始化配置 先安装好 Vue/cli 工具: $ npm install -g @vue/cli 安装完成后生成 Vue 项目: $ vue create blog-frontend 输入此命令后，我们将看到一个简短的提示。选择 manually select features 选项（手动选择特性）。然后按空格表示选择，我们选择Babel、Router 和 Linter/Formatter。后面选项一路回车就好。 我们使用 bootstrap 库定义基本的 css 样式。在 public 文件夹的 index.html 中加入以下代码： \u003clink rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css\"\u003e\r\u003cscript src=\"https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js\"\u003e\u003c/script\u003e\r\u003cscript src=\"https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js\"\u003e\u003c/script\u003e\r\u003cscript src=\"https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js\"\u003e\u003c/script\u003e\r 安装 axios 处理 http 请求，这是一种基于 Promise 的浏览器 HTTP 客户端： $ yarn add axios 在 src 目录中新建文件夹 utils, 新建文件 helper.js, 对接后端接口: export const server = {\rbaseURL: 'http://localhost:8034/api/notes'\r}\r ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:1","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"II. 创建页面组件 在 component 中新建文件夹 post, 新建三个文件：Create.vue, Edit.vue, Post.vue 新增帖子组件 Create.vue \u003ctemplate\u003e\r\u003cdiv\u003e\r\u003cdiv class=\"col-md-12 form-wrapper\"\u003e\r\u003ch2\u003eCreate Post\u003c/h2\u003e\r\u003cform id=\"create-post-form\" @submit.prevent=\"createPost\"\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"title\"\u003eTitle\u003c/label\u003e\r\u003cinput type=\"text\" id=\"title\" v-model=\"title\" name=\"title\" class=\"form-control\"\rplaceholder=\"Enter title\"/\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"description\"\u003eDescription\u003c/label\u003e\r\u003cinput type=\"text\" id=\"description\" v-model=\"description\" name=\"description\" class=\"form-control\" placeholder=\"Enter Description\"/\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"content\"\u003eWrite Content\u003c/label\u003e\r\u003ctextarea id=\"content\" cols=\"30\" rows=\"5\" v-model=\"content\" class=\"form-control\"\u003e\u003c/textarea\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"author\"\u003eAuthor\u003c/label\u003e\r\u003cinput type=\"text\" id=\"author\" v-model=\"author\" name=\"author\" class=\"form-control\" /\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003cbutton class=\"btn btn-success\" type=\"submit\"\u003eCreate Post\u003c/button\u003e\r\u003c/div\u003e\r\u003c/form\u003e\r\u003c/div\u003e\r\u003c/div\u003e\r\u003c/template\u003e\r 这是 Create.vue 组件 script 标签中的内容 import axios from \"axios\";\rimport { server } from \"../../utils/helper\";\rimport router from \"../../router\";\rexport default {\rdata() {\rreturn {\rtitle: \"\",\rdescription: \"\",\rcontent: \"\",\rauthor: \"111hunter\"\r};\r},\rmethods: {\rcreatePost() {\rlet postData = {\rtitle: this.title,\rdescription: this.description,\rcontent: this.content,\rauthor: this.author\r};\rthis.__submitToServer(postData);\r},\r__submitToServer(data) {\raxios.post(`${server.baseURL}/create`, data).then(data =\u003e {\rrouter.push({ name: \"home\" });\r});\r}\r}\r};\r 修改帖子组件 Edit.vue \u003ctemplate\u003e\r\u003cdiv\u003e\r\u003ch4 class=\"text-center mt-20\"\u003e\r\u003csmall\u003e\r\u003cbutton class=\"btn btn-info\" v-on:click=\"navigate()\"\u003eView All Posts\u003c/button\u003e\r\u003c/small\u003e\r\u003c/h4\u003e\r\u003cdiv class=\"col-md-12 form-wrapper\"\u003e\r\u003ch2\u003eEdit Post\u003c/h2\u003e\r\u003cform id=\"edit-post-form\" @submit.prevent=\"editPost\"\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"title\"\u003eTitle\u003c/label\u003e\r\u003cinput type=\"text\" id=\"title\" v-model=\"post.title\" name=\"title\" class=\"form-control\" placeholder=\"Enter title\"/\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"description\"\u003eDescription\u003c/label\u003e\r\u003cinput type=\"text\" id=\"description\" v-model=\"post.description\" name=\"description\" class=\"form-control\"placeholder=\"Enter Description\"/\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"content\"\u003eWrite Content\u003c/label\u003e\r\u003ctextarea id=\"content\" cols=\"30\" rows=\"5\" v-model=\"post.content\" class=\"form-control\"\u003e\u003c/textarea\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003clabel for=\"author\"\u003eAuthor\u003c/label\u003e\r\u003cinput type=\"text\" id=\"author\" v-model=\"post.author\" name=\"author\" class=\"form-control\" /\u003e\r\u003c/div\u003e\r\u003cdiv class=\"form-group col-md-12\"\u003e\r\u003cbutton class=\"btn btn-warning\" type=\"submit\"\u003eEdit Post\u003c/button\u003e\r\u003c/div\u003e\r\u003c/form\u003e\r\u003c/div\u003e\r\u003c/div\u003e\r\u003c/template\u003e\r 这是 Edit.vue 组件 script 标签中的内容 import { server } from \"../../utils/helper\";\rimport axios from \"axios\";\rimport router from \"../../router\";\rexport default {\rdata() {\rreturn {\rid: 0,\rpost: {}\r};\r},\rcreated() {\rthis.id = this.$route.params.id;\rthis.getPost();\r},\rmethods: {\reditPost() {\rlet postData = {\rtitle: this.post.title,\rdescription: this.post.description,\rcontent: this.post.content,\rauthor: this.post.author\r};\raxios\r.put(`${server.baseURL}/update/?notes_id=${this.id}`, postData)\r.then(data =\u003e {\rrouter.push({ name: \"home\" });\r});\r},\rgetPost() {\raxios\r.get(`${server.baseURL}/${this.id}`)\r.then(data =\u003e (this.post = data.data));\r},\rnavigate() {\rrouter.go(-1);\r}\r}\r};\r 帖子详情组件 Post.vue \u003ctemplate\u003e\r\u003cdiv class=\"text-center\"\u003e\r\u003cdiv class=\"col-sm-12\"\u003e\r\u003ch4 style=\"margin-top: 30px;\"\u003e\r\u003csmall\u003e\r\u003cbutton class=\"btn btn-info\" v-on:click=\"navigate()\"\u003eView All Posts\u003c/button\u003e\r\u003c/small\u003e\r\u003c/h4\u003e\r\u003chr /\u003e\r\u003ch2\u003e{{ post.title }}\u003c/h2\u003e\r\u003ch5\u003e\r\u003cspan class=\"glyphicon glyphicon-time\"\u003e\u003c/span\u003e\rPost by {{post.author}}, {{new Date(post.updateTime).toLocaleDateString()}}.\r\u003c/h5\u003e\r\u003cp\u003e{{ post.content }}\u003c/p\u003e\r\u003c/div\u003e\r\u003c/div\u003e\r\u003c/template\u003e\r 这是 Post.vue 组件 script 标签中的内容 import { server } from \"../../utils/h","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:2","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"III. 搭建路由 在根组件 App.vue 中修改链接: \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e\r 将 about 改为 create, 链接到 Create 组件: \u003crouter-link to=\"/Create\"\u003eCreate\u003c/router-link\u003e\r 最后将 router/index.js 改为以下代码： import Vue from 'vue'\rimport Router from 'vue-router'\rimport HomeComponent from '@/views/Home';\rimport EditComponent from '@/components/post/Edit';\rimport CreateComponent from '@/components/post/Create';\rimport PostComponent from '@/components/post/Post';\rVue.use(Router)\rexport default new Router({\rmode: 'history',\rbase: process.env.BASE_URL,\rroutes: [\r{ path: '/', redirect: { name: 'home' } },\r{ path: '/home', name: 'home', component: HomeComponent },\r{ path: '/create', name: 'Create', component: CreateComponent },\r{ path: '/edit/:id', name: 'Edit', component: EditComponent },\r{ path: '/post/:id', name: 'Post', component: PostComponent }\r]\r});\r 编写完前端代码，启动服务： $ npm run serve 浏览器打开 http://localhost:8080 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:2:3","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":"成果展示 pc端展示： \r移动端展示：\r\r附：源码地址 ","date":"2020-03-21","objectID":"/2020-03-21-spring/:3:0","tags":["Spring Boot","Vue.js"],"title":"用 Spring Boot 和 Vue.js 写一个全栈应用","uri":"/2020-03-21-spring/"},{"categories":["Coding"],"content":" ReactiveX 结合了 观察者模式、迭代器模式 和 使用集合的函数式编程，以满足以一种理想方式来管理事件序列所需要的一切。 在 RxJS 中用来解决异步事件管理的的基本概念是： Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。 Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。 Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。 Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。 Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。 Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。 以上文字来自 RxJS 中文文档，是 RxJS 的核心概念。 下面来学习创建 Observable 对象以加深对一些概念的理解。 本文将生成 observable 的操作符分为以下四类： 转换操作符：from，fromEvent，fromPromise，of 创建操作符：create, range 时间操作符：interval, timer 特殊操作符：empty, never, throw ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:0:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"项目初始化 我们使用 webpack 作为项目构建工具。使用 Babel 编译我们的代码。这是我们的项目依赖： \"devDependencies\": {\r\"@babel/core\": \"^7.8.7\",\r\"@babel/preset-env\": \"^7.8.7\",\r\"babel-loader\": \"^8.0.6\",\r\"webpack\": \"^4.42.0\"\r},\r\"dependencies\": {\r\"jquery\": \"^3.1.0\",\r\"rxjs\": \"^5.0.0-beta.12\"\r}\r webpack 配置文件 webpack.config.js: module.exports = {\rentry: './src/app.js',\routput: {\rpath: __dirname + '/dist',\rfilename: 'app.bundle.js'\r},\rmodule: {\rrules: [\r{\rtest: /\\.m?js$/,\rexclude: /(node_modules|bower_components)/,\ruse: {\rloader: 'babel-loader',\roptions: {\rpresets: ['@babel/preset-env']\r}\r}\r}\r]\r}\r}\r 新建文件夹src, 在里面新建文件 app.js, 我们在 app.js 中引入 jquery 和 RxJS。 import $ from 'jquery';\rimport Rx from 'rxjs/Rx';\rconsole.log('Code Running...');\r 在 html 文件中引入编译后的 js 文件。 \u003cbody\u003e\r\u003cinput type=\"text\" id=\"input\"\u003e\r\u003cdiv id=\"output\"\u003e\u003c/div\u003e\r\u003cul\u003e\r\u003cli id=\"name\"\u003e\u003c/li\u003e\r\u003cli id=\"artist\"\u003e\u003c/li\u003e\r\u003c/ul\u003e\r\u003cscript src=\"./dist/app.bundle.js\"\u003e\u003c/script\u003e\r\u003c/body\u003e\r 执行 webpack --watch --mode development，实时监视文件变化，并重新编译代码。 打开浏览器控制台没有任何报错，并输出 “Code Running…” 说明我们的项目构建成功。 高版本的 chrome 可能出现 DevTools failed to parse SourceMap，在控制台的setting中取消 Enable JavaScript source maps 这一项即可。 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:1:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"转换操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.from() Observable.from() 将 可迭代对象 转化为 observables 序列, 传入数据集合。 // from array\rconst numbers = [1, 2, 3, 4, 5];\rconst numbers$ = Rx.Observable.from(numbers);\rnumbers$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\r() =\u003e console.log('complete')\r);\r// from string\rconst str = 'hello world'\rconst str$ = Rx.Observable.from(str);\rstr$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\r() =\u003e console.log('complete')\r);\r// from array of objects\rconst posts = [\r{ title: 'post 1', body: 'body 1' },\r{ title: 'post 2', body: 'body 2' },\r{ title: 'post 3', body: 'body 3' }\r];\rconst posts$ = Rx.Observable.from(posts);\rposts$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\r() =\u003e console.log('complete')\r);\r// from set\rconst set = new Set(['hello', 123, { title: 'my title' }])\rconst set$ = Rx.Observable.from(set);\rset$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\r() =\u003e console.log('complete')\r);\r// from map\rconst map = new Map([[1, 2], [3, 4], [5, 6]])\rconst map$ = Rx.Observable.from(map);\rmap$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\r() =\u003e console.log('complete')\r);\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.fromEvent() Observable.fromEvent() 将 事件 转化为 observables 序列, 传入两个参数：页面元素 和 事件名称。从事件中创建的 observable 对象是持续不断产生的，不会输出 “completed”。 转化键盘事件: const input = $('#input');\rconst output = $('#output');\rconst inputStream$ = Rx.Observable.fromEvent(input, 'keyup');\rinputStream$.subscribe(\re =\u003e {\rconsole.log(e.target.value);\routput.text(e.target.value);\r},\rerr =\u003e console.log(err),\r() =\u003e console.log('completed')\r);\r 转化鼠标事件: const moveStream$ = Rx.Observable.fromEvent(document, 'mousemove');\rmoveStream$.subscribe(\re =\u003e {\rconsole.log(e.type);\routput.html('\u003ch1\u003eX: ' + e.clientX + ' Y: ' + e.clientY + '\u003c/h1\u003e');\r},\rerr =\u003e console.log('err'),\r() =\u003e console.log('completed')\r);\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:2","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.fromPromise() Observable.fromPromise() 将 promise 转化为 observables 序列, 传入 promise。 const myPromise = new Promise((resolve, reject) =\u003e {\rconsole.log('creating promise');\rsetTimeout(() =\u003e {\rresolve('hello from promise');\r}, 500);\r});\rconst myPromiseSource$ = Rx.Observable.fromPromise(myPromise);\rmyPromiseSource$.subscribe(x =\u003e console.log(x));\r 结合之前定义的 inputStream$ 嵌套使用： function getSong(username) {\rreturn $.ajax({\rtype: 'GET',\rurl: `https://autumnfish.cn/search?keywords=` + username,\r}).promise();\r}\rconst song = $('#input')\rconst inputStream$ = Rx.Observable.fromEvent(song, 'keyup')\rinputStream$.subscribe(e =\u003e {\rRx.Observable.fromPromise(getSong(e.target.value))\r.subscribe(x =\u003e {\r$('#name').text('Song: ' + x.result.songs[0].name)\rconsole.log(x.result.songs[0].name)\r$('#artist').text('Artist: ' + x.result.songs[0].artists[0].name)\r});\r}\r);\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:3","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.of() of 操作符接收1个或多个参数。转换为 Observable 对象。 const stream$ = Rx.Observable.of(1, 2, 3, 'hello');\rstream$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r);\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:2:4","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"创建操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.create() Rx.Observable.create 是 Observable 构造函数 的别名，它接收一个以 observer 作为参数的回调函数。这个回调函数会定义 observable 将会如何发送值给 observer。observer是什么？observer就是我们之前传入 subscribe() 的参数，是一个有三个回调函数的对象。 const source$ = new Rx.Observable.create(\robserver =\u003e {\robserver.next('hello')\robserver.next('another hello')\rsetTimeout(() =\u003e {\robserver.next('next hello')\robserver.complete();\r}, 2000);\r}\r);\rconst observer1 = {\rnext: v =\u003e console.log(v + '1'),\rerror: err =\u003e console.log(err),\rcomplete: () =\u003e console.log('complete')\r}\rsource$.subscribe(observer1);\r observable 是数据流的生产者，决定数据怎么给。observer 是数据流的消费者，决定数据怎么用。observable 是老板，observer 是顾客。 observable.subscribe()会实例化一个Subscription对象。Subscription表示Observable 的执行，可以被清理。这个对象最常用的方法是unsubscribe方法。 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.range() 接收两个数字参数产生有序序列，一个是开始序列数字。一个是序列个数。 const rangeSource$ = Rx.Observable.range(6, 5)\rrangeSource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r)\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:3:2","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"时间操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:4:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.interval 和 Observable.timer 从零开始产生数字，interval的参数是数字产生的间隔时间，timer 多了个开始延迟时间作为第一个参数。 const intervalSource$ = Rx.Observable.interval(1000).take(5)\rintervalSource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r)\rconst timerSource$ = Rx.Observable.timer(2000, 1000).take(5)\rtimerSource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r)\r ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:4:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"特殊操作符 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:5:0","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"Observable.empty(), Observable.never() 和 Observable.throw() Observable.empty 创建的 Observable 开始就结束，Observable.never 创建的 Observable 不会结束，Observable.throw 抛出异常不会结束。 const emptySource$ = Rx.Observable.empty()\remptySource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r)\rconst neverSource$ = Rx.Observable.never()\rneverSource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log(err),\rcomplete =\u003e console.log('complete')\r)\rconst errorSource$ = Rx.Observable.throw('err')\rerrorSource$.subscribe(\rv =\u003e console.log(v),\rerr =\u003e console.log('Throw Error: ' + err),\rcomplete =\u003e console.log('complete')\r)\r 附：源码地址 参考资料 RxJS Ultimate 中文版 30 天精通 RxJS RxJS 中文文档 ","date":"2020-03-13","objectID":"/2020-03-13-rxjs-01/:5:1","tags":["Rx","Angular"],"title":"初探 RxJS - Observable 的简单创建","uri":"/2020-03-13-rxjs-01/"},{"categories":["Coding"],"content":"前端中的状态指什么？前端中的状态指的是影响 UI 变化的数据。例如用户登入退出，用户的某种操作带来的 UI 视觉变化，UI 主题的切换，甚至路由的切换也是状态变化。 为什么要进行状态管理？通常来说前端中的状态是状态碎片，存在余各个组件中。这种碎片化的状态给开发团队带来的维护上的麻烦。为了规范开发流程，我们需要对状态进行集中统一管理。什么是ngrx？ngrx = rxjs + rudux。rudux是前端开发中主流状态管理库，不依赖平台。ngrx 相当于 rudux 在 angular 中的使用扩充。 注意 状态管理不是前端应用必须使用的，它让简单程序变复杂，让复杂程序变简单。 angular 有无 ngrx 的架构对比： \r没有状态管理前，构建 angular 程序我们仅需要 component, service, 以及后端数据 api 接口。而添加了状态管理后，我们的程序多出不少新的概念，状态管理将我们的应用复杂化了吗？对于复杂应用来说，是简化了。在软件开发中，一切看似的复杂往往是为了简单。其实状态管理这个概念类似于后端的数据库。 下面，我们对 ngrx 的各种新概念进行介绍，以下内容仅是个人理解。redux 中核心概念只有三个: Store, Action, Reducer，其他是 ngrx 的扩展。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:0:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["Coding"],"content":"Store 简单的理解就是前端状态的数据库，它有一个基本原则: 是\"唯一的、状态不可修改\"的树。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:1:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["Coding"],"content":"Action 可以理解为状态变化的信号，当状态发生变化时，通过 Action 显性定义状态变化，传递状态发生变化的数据。可配合 store-devtools 使用。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:2:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["Coding"],"content":"Reducer 它是前端数据状态映射成的 Store 数据库中的表，接收旧状态，返回新状态。它是一个纯函数, 需要通过 Action 告知能够进行的状态变化。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:3:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["Coding"],"content":"Effects 我们在进行一些 Action 时需要发送 http 请求，DOM 操作, 读写文件等。redux 状态管理只关心视图层的状态变化, 不会解决这些的需求。因此 ngrx 扩展了 Effects, 其实它是一个钩子函数。这大概就是示意图中虚线的含义。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:4:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["Coding"],"content":"Selector 性能优化，官方解释：因为选择器是纯函数，所以当参数匹配时可以返回最后的结果，而无需重新调用选择器函数。Store 通过 Selector 得到 component 状态。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:5:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["Coding"],"content":"Entity 性能优化，Reducer 实现 EntityState 接口，就能够注册数据集合 id 和 entity, 通过 id 来找到数据。配合 store-devtools 工具使用。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:6:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["Coding"],"content":"Router-store 侦听路由状态的变化。配合 store-devtools 工具使用。 ","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:7:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["Coding"],"content":"整体流程 当我们 component 中的 state 需要改变时，发出 Action 信号, Reducer 根据 Action 的信号选择更新 state, Store 收到 state 的变化，通过 selector 得到状态切片选择性地更新 compont 中的 state。 有些过程无法在这个流程中实现，例如从后端 api 获取数据，于是我们在发出 Action 时，套上 Effects 钩子函数，在钩子函数中调用 service 取得后端数据。 下面是使用各个 api 的例子, 关于如何注册各个模块，官网有详细说明，不在赘述。 现在我们需要管理 customer 的状态, customer 定义如下： //customer.model.ts\r\rexport interface Customer {\rid?: number;\rname: string;\rphone: string;\raddress: string;\rmembership: string;\r}\r 用 json.server 做服务器，创建 db.json 写入两个 customer： {\r\"customers\": [\r{\r\"name\": \"John Doe\",\r\"phone\": \"910928392098\",\r\"address\": \"123 Sun Street\",\r\"membership\": \"Platinum\",\r\"id\": 1\r},\r{\r\"name\": \"Mary Johnson\",\r\"phone\": \"808937482734\",\r\"address\": \"893 Main Voulevard\",\r\"membership\": \"Pro\",\r\"id\": 2\r}\r]\r}\r 我们要做的是管理监视页面加载 customer 的过程。coustom 有三种加载状态：加载中，加载成功，加载失败。 先定义 customer 的状态, loading, loaded, error, 实现 EntityState 接口性能优化，方便管理： //customer.entity.ts\r\rimport { EntityState, EntityAdapter, createEntityAdapter } from \"@ngrx/entity\";\rimport * as fromRoot from \"../../state/app-state\";\rimport { Customer } from \"../customer.model\";\rexport interface CustomerState extends EntityState\u003cCustomer\u003e {\rselectedCustomerId: number | null;\rloading: boolean;\rloaded: boolean;\rerror: string;\r}\rexport interface AppState extends fromRoot.AppState {\rcustomers: CustomerState;\r}\rexport const customerAdapter: EntityAdapter\u003cCustomer\u003e = createEntityAdapter\u003c\rCustomer\r\u003e();\r 接着实现 Action, Action 要实现两个属性 payload? 和 type，发出 Action 的方法是 store.dispatch()。 //customer.action.ts\r\rimport { Action } from \"@ngrx/store\";\rimport { Customer } from \"../customer.model\";\rexport enum CustomerActionTypes {\rLOAD_CUSTOMERS = \"[Customer] Load Customers\",\rLOAD_CUSTOMERS_SUCCESS = \"[Customer] Load Customers Success\",\rLOAD_CUSTOMERS_FAIL = \"[Customer] Load Customers Fail\"\r}\rexport class LoadCustomers implements Action {\rreadonly type = CustomerActionTypes.LOAD_CUSTOMERS;\r}\rexport class LoadCustomersSuccess implements Action {\rreadonly type = CustomerActionTypes.LOAD_CUSTOMERS_SUCCESS;\rconstructor(public payload: Customer[]) {}\r}\rexport class LoadCustomersFail implements Action {\rreadonly type = CustomerActionTypes.LOAD_CUSTOMERS_FAIL;\rconstructor(public payload: string) {}\r}\rexport type Action = LoadCustomers | LoadCustomersSuccess | LoadCustomersFail;\r 要从 json-server 中获取数据，我们必须实现 Effects, 调用 service: //customer.effects.ts\r\rimport { Injectable } from \"@angular/core\";\rimport { Actions, Effect, ofType } from \"@ngrx/effects\";\rimport { Action } from \"@ngrx/store\";\rimport { Observable, of } from \"rxjs\";\rimport { map, mergeMap, catchError } from \"rxjs/operators\";\rimport { CustomerService } from \"../customer.service\";\rimport * as customerActions from \"./customer.action\";\rimport { Customer } from \"../customer.model\";\r@Injectable()\rexport class CustomerEffect {\rconstructor(\rprivate actions$: Actions,\rprivate customerService: CustomerService\r) { }\r@Effect()\rloadCustomers$: Observable\u003cAction\u003e = this.actions$.pipe(\rofType\u003ccustomerActions.LoadCustomers\u003e(\rcustomerActions.CustomerActionTypes.LOAD_CUSTOMERS\r),\rmergeMap((actions: customerActions.LoadCustomers) =\u003e\rthis.customerService.getCustomers().pipe(\rmap(\r(customers: Customer[]) =\u003e\rnew customerActions.LoadCustomersSuccess(customers)\r),\rcatchError(err =\u003e of(new customerActions.LoadCustomersFail(err)))\r)\r)\r);\r}\r 接着实现 Reducer，其中的 state 显示在 store-devtools 工具中： //customer.reducer.ts\r\rimport * as customerActions from \"./customer.action\";\rimport { CustomerState, customerAdapter } from \".\";\rexport const defaultCustomer: CustomerState = {\rids: [],\rentities: {},\rselectedCustomerId: null,\rloading: false,\rloaded: false,\rerror: \"\"\r};\rexport const initialState = customerAdapter.getInitialState(defaultCustomer);\rexport function customerReducer(\rstate = initialState,\raction: customerActions.Action\r): CustomerState {\rswitch (action.type) {\rcase customerActions.CustomerActionTypes.LOAD_CUSTOMERS: {\rreturn {\r...state,\rloading: true\r};\r}\rcase customerActions.CustomerActionTypes.LOAD_CUSTOMERS_SUCCESS: {\rreturn customerAdapter.addAll(action.pa","date":"2020-03-02","objectID":"/2020-03-02-ngrx/:8:0","tags":["Rx","Angular"],"title":"通过 NgRx 体验前端状态管理","uri":"/2020-03-02-ngrx/"},{"categories":["Coding"],"content":"随着代码量的增长传统的 MVC 模式中 Modal 和 Controller 会变得含糊不清，导致难于维护。 传统 MVC 与 NestJS 架构对比： \rNest(Nest.js) 的分层借鉴自 Spring，更细化。我们应该要了解整个 Nest 框架的三层结构，Nest 和传统的 MVC 框架的区别在于它更注重于后端部分（控制器、服务与数据）的架构，视图层相对比较独立，完全可以由用户自定义配置。 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:0:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"创建 Nest 项目 $ npm install -g @nest/cli 全局安装 nest 脚手架 $ nest new nest-crud 新建 nest.js 项目, 选择 yarn 作为开发工具 $ nest g mo photo 建立 PhotoModule $ nest g co photo 建立 PhotoController $ nest g s photo 建立 PhotoService $ yarn add @nestjs/typeorm typeorm mysql 需要使用 typeorm, mysql 需要安装这些库 在 TypeORM 中数据库的表对应的就是一个类，通过定义一个类来创建实体。实体（Entity）是一个映射到数据库表的类 (类似于 mongoose 中的 Schema 映射到 MongoDB 的 collection)，通过@Entity()来标记。在photo文件夹中新建 photo.entity.ts: // photo.entity.ts\r\rimport { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';\r@Entity('photo')\rexport class PhotoEntity {\r@PrimaryGeneratedColumn()\rid: number;\r@Column({ length: 500 })\rname: string;\r@Column('text')\rdescription: string;\r@Column()\rfilename: string;\r@Column('int')\rviews: number;\r@Column()\risPublished: boolean;\r}\r 在 app.module.ts 中的 import 数组中配置数据库连接，可以配置多个数据库连接。 TypeOrmModule.forRoot({\rtype: 'mysql',\rhost: 'localhost',\rport: 3306,\rusername: 'root',\rpassword: '123456',\rdatabase: 'test',\rentities: [PhotoEntity],\rsynchronize: true,\r})\r 然后在 photo.mudule.ts 中 import 数组中注册要本模块使用的数据库。这样，我们就可以使用 @InjectRepository() 装饰器将 PhotoRepository 注入到 PhotoService 中 imports: [TypeOrmModule.forFeature([PhotoEntity])]\r 数据传输对象简称 DTO(Data Transfer Object)，是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。class-validator 可以很方便地验证前端传过来的参数。 // photo.dto.ts\r\rimport { IsString, IsInt, IsBoolean } from 'class-validator';\rexport class PhotoDto {\r@IsInt()\rreadonly id: number;\r@IsString()\rreadonly name: string;\r@IsString()\rreadonly description: string;\r@IsString()\rreadonly filename: string;\r@IsInt()\rreadonly views: number;\r@IsBoolean()\rreadonly isPublished: boolean;\r}\r ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:1:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"三层结构 将 PhotoRepository 注入到 PhotoService 中, 写数据库操作的 crud 代码: @Injectable()\rexport class PhotoService {\rconstructor(\r@InjectRepository(PhotoEntity)\rprivate readonly photoRepository: Repository\u003cPhotoEntity\u003e,\r) { }\rasync findAll(): Promise\u003cPhotoEntity[]\u003e {\rreturn this.photoRepository.find();\r}\rasync create(photoDto: PhotoDto): Promise\u003cPhotoEntity\u003e {\rreturn await this.photoRepository.save(photoDto)\r}\rasync delete(id: number) {\rreturn await this.photoRepository.delete(id)\r}\rasync update(photoDto: PhotoDto) {\rreturn await this.photoRepository.update(photoDto.id, photoDto)\r}\rasync findOne(id: number): Promise\u003cPhotoEntity\u003e {\rreturn await this.photoRepository.findOne(id)\r}\r}\r 将 PhotoService 注入到 PhotoController 中, 写 api 路由: @Controller('photo')\rexport class PhotoController {\rconstructor(private readonly photoService: PhotoService) { }\r@Get()\rfindAll(): Promise\u003cPhotoEntity[]\u003e {\rreturn this.photoService.findAll();\r}\r@Post('create')\rcreate(@Body() PhotoDto: PhotoDto): Promise\u003cPhotoEntity\u003e {\rreturn this.photoService.create(PhotoDto)\r}\r@Delete('delete/:id')\rdelete(@Param('id') id: number) {\rreturn this.photoService.delete(id)\r}\r@Put('update/:id')\rupdate(@Param('id') id: number, @Body() PhotoDto: PhotoDto) {\rreturn this.photoService.update(PhotoDto)\r}\r@Get(':id')\rfindOne(@Param('id') id: number): Promise\u003cPhotoEntity\u003e {\rreturn this.photoService.findOne(id)\r}\r}\r 接下来在 main.ts 中配置 swagger, 方便我们测试 api const app = await NestFactory.create(AppModule);\rconst options = new DocumentBuilder()\r.setTitle('photo example')\r.setDescription('The photo API description')\r.setVersion('0.0.1')\r.build();\rconst document = SwaggerModule.createDocument(app, options);\rSwaggerModule.setup('docs', app, document);\rawait app.listen(3000);\r $ npm run start 启动 nest 项目, 访问 http://localhost:3000/docs ，到这里基本的 crud 操作已经实现，此时，NestJS框架的三层结构已有体现。接下来再完善项目。 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:2:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"AOP 的思想 我们在 PhotoController 的路由请求参数中传入了 DTO, 做了直接的参数校验。传入类型不符合要求时，会直接报错。DTO 中的class-validator 还需要配合 pipe 才能完成校验功能。新建一个 pipe 捕获异常。$ nest g pi section/validation @Injectable()\rexport class ValidationPipe implements PipeTransform\u003cany\u003e {\rasync transform(value, metadata: ArgumentMetadata) {\rconst { metatype } = metadata\rif (!metatype || !this.toValidate(metatype)) {\rreturn value\r}\rconst object = plainToClass(metatype, value)\rconst errors = await validate(object)\rif (errors.length \u003e 0) {\rconst errorMessage = _.values(errors[0].constraints)[0]\rthrow new BadRequestException(errorMessage)\r}\rreturn value\r}\rprivate toValidate(metatype): boolean {\rconst types = [String, Boolean, Number, Array, Object]\rreturn !types.find(type =\u003e metatype === type)\r}\r}\r 有了这一层 pipe 帮助我们校验参数，有效地降低了类的复杂度，提高了可读性和可维护性。我们还可以对正确的请求，异常的请求进行包装，假设返回的格式是这样的： # 请求失败\r{\rstatus: 1,\rmessage: string,\r}\r# 请求成功\r{\rstatus: 0,\rmessage: '请求成功',\rdata: any\r}\r 可以利用 AOP 的思想去做这件事。全局捕获错误的切片层去处理所有的 exception，如果是一个成功的请求，需要把这个返回结果通过一个切片层包装一下。 在 NestJs 中，Exception Filter 是最后捕获 exception的机会。我们把它作为处理全局错误的切片层。$ nest g f section/errors @Catch()\rexport class ExceptionsFilter implements ExceptionFilter {\rasync catch(exception, host: ArgumentsHost) {\rconst ctx = host.switchToHttp()\rconst response = ctx.getResponse()\rconst request = ctx.getRequest()\rlet message = exception.message\rlet isDeepestMessage = false\rwhile (!isDeepestMessage) {\risDeepestMessage = !message.message\rmessage = isDeepestMessage ? message : message.message\r}\rconst errorResponse = {\rmessage: message || '请求失败',\rstatus: 1,\r}\rconst status = exception instanceof HttpException ?\rexception.getStatus() :\rHttpStatus.INTERNAL_SERVER_ERROR\rresponse.status(status)\rresponse.header('Content-Type', 'application/json; charset=utf-8')\rresponse.send(errorResponse)\r}\r}\r 而 Interceptor 则负责对成功请求结果进行包装：$ new g in section/transform interface Response\u003cT\u003e {\rdata: T\r}\r@Injectable()\rexport class TransformInterceptor\u003cT\u003e\rimplements NestInterceptor\u003cT, Response\u003cT\u003e\u003e {\rintercept(\rcontext: ExecutionContext,\rnext: CallHandler,\r): Observable\u003cResponse\u003cT\u003e\u003e {\rreturn next.handle().pipe(\rmap(rawData =\u003e {\rreturn {\rdata: rawData,\rstatus: 0,\rmessage: '请求成功',\r}\r}\r)\r)\r}\r}\r 将 Interceptor, Exception Filter 和 Pipe 定义在全局范围内: app.useGlobalFilters(new ExceptionsFilter());\rapp.useGlobalInterceptors(new TransformInterceptor());\rapp.useGlobalPipes(new ValidationPipe());\r $ npm run start 打开 http://localhost:3000/docs, 测试 api 结果正如我们预期的那样。 附：源码地址 参考资料 DI(依赖注入) NestJS 官方文档 TypeORM 官方文档 ","date":"2020-02-01","objectID":"/2020-02-01-nest-crud/:3:0","tags":["Nest","TypeORM"],"title":"NestJS + TypeORM 实现 crud 示例","uri":"/2020-02-01-nest-crud/"},{"categories":["Coding"],"content":"本文实践较多，建议跟着文章的步骤敲一遍代码以加深理解。 \r","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:0:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"1. 使用帮助 $ git help 可以查看 git 常用命令 $ git help -a 可以查看 git 所有命令，F 或者 空格 向下查看命令，B 向上查看命令，Q 退出 git-cli $ git help add help后接一个指令可以查看该指令的详细用法 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:1:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"2. git 配置范围 git 配置分为三个范围 system, global 和 项目范围 一般选择global进行配置 $ git config --global user.name '111hunter' $ git config --list 查看当前配置信息 $ git config --unset --global user.name 取消 user.name 配置 配置文件是当前用户主目录 $ cat ~/.gitconfig ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:2:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"3. git 项目文件 $ mkdir movietalk \u0026\u0026 cd movietalk 新建文件夹 $ git init 初始化项目 $ cd .git \u0026\u0026 ls -a config 目录就是项目级别的配置 $ cd .. \u0026\u0026 touch index.html 新建文件 $ vim index.html 编辑文件后保存 $ git add . 提交所有文件到暂存区 $ git commit -m \"first commit\" 暂存区文件提交仓库区 $ git log 查看提交日志信息 $ vim index.html 将index.html中 charset=\"UTF-8” 改为 charset=\"GBK” $ git status 查看文件状态 $ git diff index.html 查看暂存区文件与本地工作区的对比 $ git diff --staged 查看仓库区与暂存区对比，此时一致 $ git add . 然后 $ git diff index.html 此时没有区别了，因为已将文件提交暂存区 $ vim index.html 再次修改，在文件中新增适应移动端的 meta 标签 $ git diff --staged 查看仓库区与暂存区对比 $ git commit -m \"修改了charset属性\" 暂存区提交仓库 $ git diff --staged 此时暂存区与仓库一致 $ git log 查看提交日志信息, 此时有两条提交信息 $ git status 查看文件状态 $ git add . \u0026\u0026 git commit -m \"新增meta标签\" 工作区文件提交到仓库 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"重命名 git 已跟踪文件 $ touch style.css \u0026\u0026 vim style.css 新建css文件 $ mv style.css theme.css 修改文件名 $ git status 查看文件状态 $ git rm style.css \u0026\u0026 git add theme.css 就能修改文件名字 $ git commit -m \"mv style.css theme.css\" 上传仓库区 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:1","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"git 移动文件 $ git mv theme.css aha.css 移动文件，重命名 $ mkdir css \u0026\u0026 git status git 不会跟踪空文件 $ git mv aha.css /css 移动文件 $ git commit -m \"move aha.css\" 上传仓库区 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:2","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"git 删除文件与恢复 $ git rm index.html 从工作区与暂存区中删除index.html $ git checkout HEAD -- index.html HEAD 指针指向最近一次提交， – 表示当前分支，将index.html恢复到当前 commit 的状态 $ git rm index.html \u0026\u0026 git commit -m \"删除了index.html\" 从工作区与暂存区中删除index.html, 并提交仓库 $ git checkout \"HEAD^\" -- index.html 恢复到上一次提交，windows cmd 中 ^ 会被当做换行处理，需要加上引号 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:3","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"git 恢复某个操作状态 在 css 文件夹引入 bootstrap vim index.html 在 index.html 中引入 bootstrap git commit -am \"增加了bootstrap\" 提交仓库 新建 js 文件夹并引入 jquery vim index.html 在 index.html 中引入 jquery git commit -am \"增加了jquery\" 提交仓库 git log --oneline 查看提交日志 id, 添加 bootstrap 的 id 为 981eb52 git revert 981eb52 撤销对 bootstrap 的提交，查看工作区文件夹发现 index.html 对 bootstrap 的引入消失了 每次 git commit 后 HEAD 都会指向最后一次提交，用 git reset 可以帮助回到某次提交时的状态，有 3 个可选配置参数: –mixed, –soft, –hard –soft 软重置，不会修改任何文件状态。该参数用于git commit后，又要恢复还没commit的场景，重新审查代码，然后再推上去覆盖之后的提交。 $ git log --oneline 查看添加 jquery 的 id 为 e9ae8b5，Revert “添加了bootstrap\"的 id 为 3e3da01 $ git reset --soft e9ae8b5 回到提交 jquey 的 commit，但是不会对文件做任何操作 $ git status 会提示 撤销 bootstrap 时的消息 默认是 –mixed, 只影响暂存区文件状态 $ git reset --mixed e9ae8b5 \u0026\u0026 git status 发现 bootstrap 已经不在暂存区了 –hard 会直接重置暂存区和工作区文件到指定 id 状态，用 git reset –hard 可直接在不同提交状态切换。 $ git reset --hard e9ae8b5 \u0026\u0026 git log --oneline 查看工作区文件发现 bootstrap又回来了 $ git reset --hard 3e3da01 \u0026\u0026 git log --oneline 文件又到了最后一次提交时的状态 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:3:4","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"4. git 项目分支 $ git branch testing \u0026\u0026 git checkout testing 新建并切换分支，此时对文件的修改只影响 branch 分支 $ vim index.html 在 index.html 中引入 link 标签 $ git commit -am \"添加link标签\" 提交仓库区 $ git checkout master 切换回 master 分支，查看工作区文件发现对文件的修改没有了 $ git diff master..testing index.html 查看分支间的文件对比 $ git merge testing 分支合并 $ git diff master..testing 没有不同，已经合并了分支 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"解决分支合并冲突 $ vim index.html 修改 document 为 Movietalk $ git commit -am \"修改标题为Movietalk\" 提交仓库区 $ git checkout testing \u0026\u0026 vim index.html 切换分支，修改 document 为 Movie-talk $ git commit -am \"修改标题为Movie-talk\" 提交仓库区 $ git merge master 产生冲突。git 发现冲突，查看文件会有提示，编辑保留其中一个 document 修改 $ git commit -am \"解决冲突\" 提交 $ git log --oneline --all -10 --graph 查看所有分支提交信息 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:1","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"保存当前工作状态 git stash 指令能够保存当前工作状态到 git 栈 $ touch human.txt \u0026\u0026 git commit -am \"add human.txt\" 新建空文件 $ vim human.txt 加入任意内容 $ git status 查看修改，不提交 $ git stash save \"修改了human.txt\" 保存工作进度，查看文件 human.txt 又变成了空文件 $ git stash list 查看工作进度 $ git stash show -p stash@{0} 以补丁的方式查看工作进度与工作目录的区别 $ git stash apply stash@{0} 切换到之前的工作进度，发现对 human.txt 的修改又生效了 $ git stash pop 切换栈顶工作状态 $ git stash drop stash@{0} 删除工作状态 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:4:2","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"5. git 远程仓库 新建远程仓库后请清空仓库，不要保留任何文件 $ git remote add origin https://gitee.com/hunter_111/movietalk.git 关联远程仓库 $ git remote -v 查看是否关联, fetch 远程用来提取，push 远程用来推送 $ git push -u origin master 推送到远程分支，并跟踪远程分支变化 $ git push origin testing 推送远程分支，不跟踪变化 参考资料 廖雪峰的 git 教程 ","date":"2019-12-13","objectID":"/2019-12-13-git-learn/:5:0","tags":["Git"],"title":"git 快速上手指南","uri":"/2019-12-13-git-learn/"},{"categories":["Coding"],"content":"本次实践将不使用框架，尝试直接使用 Node.js 处理 http 请求，连接数据库，创建 api 接口。以及介绍一些 web 开发相关的常识。 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:0:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"搭建开发环境 使用 nodemon 监测文件变化，自动重启 node 使用 cross-env 设置环境变量，兼容Mac Linux 和 Windows 配置完后使用 $ npm run dev 命令启动项目 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:1:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"Node.js 处理 get，post 请求 const http = require('http')\rconst querystring = require('querystring')\rconst server = http.createServer((req, res) =\u003e {\rconst method = req.method\rconst url = req.url\rconst path = url.split('?')[0] //重点：split('?'[0])语法弄清楚\r const query = querystring.parse(url.split('?')[1])\r//设置返回值格式为 JSON\r res.setHeader('Content-type', 'application/json') //返回的数据\r const resData = {\rmethod,\rurl,\rpath,\rquery\r}\r//返回\r if (method === 'GET') {\rres.end(\rJSON.stringify(req.query)\r)\r} if (req.method === 'POST'){\rlet postData = ''\r//res.on('data')指每次发送的数据\r //chunk 逐步接收数据 req绑定一个data方法 chunk是变量\r req.on('data', chunk =\u003e {\rpostData += chunk.toString()\r})\r//req.on(end)数据发送完成；\r req.on('end', () =\u003e {\rconsole.log('postData:', postData)\rconsole.log('resData:', resData)\rresData.postData = postData\r//返回\r res.end(\rJSON.stringify(resData)\r)\r})\r}\r})\rserver.listen(8000)\rconsole.log('OK')\r https://github.com/username/xxx 每个斜线后面的唯一标识就是路由 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:2:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"接口设计方案 描述 接口 方法 url参数 备注 获取博客列表 /api/blog/list get author，keyword 参数为空则不进行查询过滤 获取一篇博客 /api/blog/detail get id 新增一篇博客 /api/blog/new post postData 有新增信息 更新一篇博客 /api/blog/update post id postData 有更新信息 删除一篇博客 /api/blog/del post id 登录 /api/user/login post postData 有用户名和密码 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:3:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"开发路由 业务分层 拆分业务 createServer 业务单独放在 ./bin/www.js 系统基本设置、基本信息 app.js 放在根目录 路由功能 ./src/router/xxx.js 数据管理 ./src/contoller/xxx.js 使用 promise 读取文件，避免 callback-hell ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:4:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"使用MySQL数据库 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:5:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"根据需求设计表 users： id username password realname 1 zhangsan admin 张三 2 lisi 123 李四 blogs： id title content createtime author 1 标题A 内容A 1573989043149 zhangsan 2 标题B 内容B 1573989111301 lisi ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:5:1","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"用 Node.js 操作 MySQL 示例：文件 mysql-test/index.js 演示 Node.js 操作 MySQL 封装：将其封装为系统可用的工具, 封装 exec 函数 使用：路由 api/user/xxx，api/blog/xxx 对接 MySQL ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:6:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"用户登录 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:7:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"Cookie 什么是 Cookie 存储在浏览器的字符串（最大5KB） 跨域不共享 格式如 K1=V1;K2=V3;K3=V3; 因此可以存储结构化数据 每次发送 Http 请求，会将请求域的 Cookie 一起发送给 Server Server 可以修改 Cookie 并返回给浏览器 浏览器也可以通过 JavaScript 修改 Cookie （有限制） Server 端操作 Cookie，实现登录验证 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:7:1","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"Session Cookie 存放用户信息非常危险 如何解决：cookie 中存储 userId， server 端对应 username 解决方案：session ，即 server 端储存用户信息 直接在代码中使用 session 的问题 session 是 JS 变量，放在 Node.js 进程内存中 进程内存有限，访问量过大，内存暴增 正式上线是多进程，进程之间内存无法共享 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:7:2","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"在 Redis 中存储 Session Web Server 最常用的缓存数据库，数据储存在内存中 相比于 MySQL，访问速度极快，成本更高，储存空间小 将 Web Server 和 Redis 拆分为两个单独服务，双方独立，可扩展 示例：文件 redis-test/index.js 演示 Node.js 操作 Redis 封装：将其封装为系统可用的工具, 封装 set, get 函数 使用：路由 api/user/xxx 对接 Redis ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:8:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"Nginx 反向代理前后端联调 登录依赖 Cookie，必须用浏览器 Cookie 跨域不共享，前端和 server 端必须同域 需要用到 Nginx 做代理，让前后端共域，实现前后端联调 开发前端界面：文件夹 html-test 包含用户登录，博客管理界面 启动服务： $ cd html-test $ npm i http-server -g $ http-server -p 8001 修改 nginx 配置: ..\\nginx-1.12.2\\conf\\nginx.conf worker_processes auto;\rlisten 8080;\r# location / {\r# root html;\r# index index.html index.htm;\r# }\rlocation / {\rproxy_pass http://localhost:8001;\r}\rlocation /api/ {\rproxy_pass http://localhost:8000;\rproxy_set_header Host $host;\r}\r 启动 nginx: $ start nginx ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:9:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"Web 安全 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:10:0","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"常见安全问题 SQL 注入：窃取数据库内容 XSS攻击：窃取前端的 Cookie 内容 密码加密：保障用户信息安全（重要） Server 端攻击方式很多，预防手段也很多 有些攻击需要硬件和服务来支持（需要 OP 支持），如 DDOS ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:10:1","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"SQL 注入 最原始、最简单的攻击，从有了 Web2.0 就有了 SQL 注入攻击 攻击方式：输入一个 SQL 片段，最终拼接成一段攻击代码 解决方案：使用 MySQL　的 escape 函数处理输入数据内容 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:10:2","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"XSS 攻击 前端同学熟知的攻击方式，但 Server 端更应该掌握 攻击方式：在页面展示内容中参杂 JS 代码，以获取网页信息 解决方案：在文件夹 blog-1 中安装 xss 库： npm i xss ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:10:3","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"密码加密 万一数据库被攻破，避免泄露用户信息 攻击方式：获取用户名和密码，再去尝试登录其它系统 解决方案：密码加密，密文储存，MD5加密 附：源码地址 ","date":"2019-11-22","objectID":"/2019-11-22-node-basis/:10:4","tags":["Node.js"],"title":"Node.js 搭建博客后台","uri":"/2019-11-22-node-basis/"},{"categories":["Coding"],"content":"扫雷是一款大众类的益智小游戏,于1992年发行。游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子,同时避免踩雷,踩到一个雷即全盘皆输。 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:0:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"游戏规则 \r在写扫雷之前，我们先了解下它的游戏规则： 扫雷是一个矩阵，地雷随机分布在其中的方格里。 方格上的数字代表着这个方格所在的九宫格内有多少个地雷。 游戏玩家用鼠标左键打开方格，用鼠标右键标记地雷。 踩到地雷，游戏失败。打开所有非雷方格，游戏胜利。 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:1:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"功能实现 ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:0","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"矩阵的生成 用 html 中的表格 table，span 生成矩阵方格。把矩阵方格放入二维数组中，然后对单个方格添加鼠标事件。 //初始化矩阵 (row-行数 col-列数)\rfunction init_grid() {\r//生成矩阵html \u003ctr\u003e--行标签 \u003ctd\u003e--列标签\r let gridHtml = '';\rfor (let i = 0; i \u003c row; i++) {\rgridHtml += '\u003ctr\u003e'\rfor (let j = 0; j \u003c col; j++) {\rgridHtml += '\u003ctd\u003e\u003cspan class=\"blocks\" onmousedown=\"block_click(' + i + ',' + j + ',event)\"\u003e\u003c/span\u003e\u003c/td\u003e';\r}\rgridHtml += '\u003ctr\u003e'\r}\r//写入html\r document.getElementById('grid').innerHTML = gridHtml;\r//返回矩阵二维数组\r let blocks = document.getElementsByClassName('blocks');\rlet grid = new Array();\rfor (let i = 0; i \u003c blocks.length; i++) {\rif (i % col === 0) {\rgrid.push(new Array());\r}\r//初始化计雷数\r blocks[i].count = 0;\rgrid[parseInt(i / col)].push(blocks[i]);\r}\rreturn grid;\r}\r ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:1","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"方格打开与标记 通过 onmousedown 事件，传入点击的方格的坐标及event，判断event为左键还是右键。左键打开方格，右键标记方格。 //方格点击事件 _i：坐标i _j:坐标j e:鼠标事件\rfunction block_click(_i, _j, e) {\r//跳过已打开的方格\r if (grid[_i][_j].isOpen) {\rreturn;\r}\r//鼠标左键打开方格\r if (e.button === 0) {\r...\r//执行递归打开方格函数\r block_open(_i, _j);\r}\r//鼠标右键标记方格\r else if (e.button === 2) {\rlet block = grid[_i][_j];\rif (block.innerHTML !== '▲') {\rblock.innerHTML = '▲';\r} else {\rblock.innerHTML = '';\r}\r}\r}\r ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:2","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"地雷随机分布 第一次打开的方格不能为地雷，把生成地雷的函数放在第一次点击方格后。 通过循环用 Math.random() 函数来随机生成地雷的二维坐标。 判断坐标是否不为第一次点击方格的坐标以及该坐标没有雷存在。 是则将方格设置为地雷，当前地雷数+1，将该方格所在九宫格内的方格的计雷数+1。 否则跳过进入下个循环，直到地雷的数量达到设定的最大雷数，结束循环。 //方格点击事件 _i：坐标i _j:坐标j e:鼠标事件\rfunction block_click(_i, _j, e) {\r//跳过已打开的方格\r if (grid[_i][_j].isOpen) {\rreturn;\r}\r//鼠标左键打开方格\r if (e.button === 0) {\r//第一次打开\r if (isFirstOpen) {\risFirstOpen = false;\rlet count = 0; //当前地雷数\r //生成地雷\r while (count \u003c maxCount) {\r//生成随机坐标\r let ri = Math.floor(Math.random() * row);\rlet rj = Math.floor(Math.random() * col);\r//坐标不等于第一次点击方格的坐标 \u0026\u0026 非雷方格\r if (! (ri === _i \u0026\u0026 rj === _j) \u0026\u0026 !grid[ri][rj].isMine) {\rgrid[ri][rj].isMine = true; //自定义属性isMine代表方格为地雷\r count++; //当前地雷数+1\r //更新九宫格内非雷方格的计雷数\r for (let i = ri - 1; i \u003c ri + 2; i++) {\rfor (let j = rj - 1; j \u003c rj + 2; j++) {\r//判断坐标防越界\r if (i \u003e -1 \u0026\u0026 j \u003e -1 \u0026\u0026 i \u003c row \u0026\u0026 j \u003c col) {\r//计雷数+1\r grid[i][j].count++;\r}\r}\r}\r}\r}\r}\r//执行打开方格函数\r block_open(_i, _j);\r}\r}\r ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:3","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"递归打开方格 当打开的方格为计雷数为0的方格，自动打开九宫格内的非雷方格。如果打开的非雷方格九宫格内仍有非雷方格，用递归继续打开九宫格内的非雷方格，直到没有为止。 //递归打开方格函数\rfunction block_open(_i, _j) {\rlet block = grid[_i][_j];\rop(block);\r//设定打开方格的状态与样式\r function op(block) {\rblock.isOpen = true; //isOpen为自定义属性，设置为true代表已打开\r block.style.background = '#ccc'; //将背景设置为灰色\r block.style.cursor = 'default'; //将鼠标停留样式设置为默认\r }\r//打开计雷数为0的方格\r if (block.count === 0) {\r//遍历九宫格内的方格\r for (let i = _i - 1; i \u003c _i + 2; i++) {\rfor (let j = _j - 1; j \u003c _j + 2; j++) {\r//判断是否越界\u0026\u0026跳过已打开的方格\u0026\u0026非雷\r if (i \u003e -1 \u0026\u0026 j \u003e -1 \u0026\u0026 i \u003c row \u0026\u0026 j \u003c col \u0026\u0026 !grid[i][j].isOpen \u0026\u0026 !grid[i][j].ismine) {\r//递归打开方格函数\r block_open(i, j);\r}\r}\r}\r} // 踩雷\r else if (block.isMine) {\r...\r} //打开计雷数不为0的方格\r else {\rblock.innerHTML = block.count; //显示计雷数\r }\r}\r ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:4","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"踩雷游戏结束 打开方格为地雷时，提示游戏结束。通过遍历矩阵打开所有埋地雷位置。 else if (block.isMine) {\rblock.innerHTML = '雷'; //显示为 '雷'\r //遍历矩阵打开所有埋地雷的方格\r for (let i = 0; i \u003c row; i++) {\rfor (let j = 0; j \u003c col; j++) {\r//找到地雷\r block = grid[i][j];\rif (!block.isOpen \u0026\u0026 block.isMine) {\rop(block); //设置打开状态和样式\r block.innerHTML = '雷'; //显示为 '雷'\r }\r}\r}\rclearInterval(timer); //游戏结束停止计时，清除定时器\r //提示游戏结束\r alert(\"你踩到雷了！游戏结束\");\r}\r ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:5","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"游戏胜利条件 当所有非雷方格被打开即为游戏胜利。在每次打开方格函数中都遍历一遍矩阵，当找到有未打开的非雷方格时则退出遍历，遍历完所有方格均未找到未打开的非雷方格时则游戏胜利。 //方块点击事件 _i：坐标i _j:坐标j e:鼠标事件\rfunction block_click(_i, _j, e) {\r//跳过已打开的方块\r if (grid[_i][_j].isOpen) {\r//...\r }\r//鼠标左键打开方块\r if (e.button === 0) {\r//...\r }\r//鼠标右键标记方块\r else if (e.button === 2) {\r//...\r }\r//遍历矩阵\r let isWin = true;\rfor (let i = 0; i \u003c row; i++) {\rfor (let j = 0; j \u003c col; j++) {\rlet block = grid[i][j];\r//如果有未打开的非雷方块\r if (!block.isMine \u0026\u0026 !block.isOpen) {\risWin = false;\r}\r}\r}\rif (isWin) {\ralert(\"游戏胜利\");\r}\r}\r 游戏逻辑部分到这里就结束了，剩余雷数和计时可用全局变量实现。 附：源码地址 参考资料 原生 JS 实现扫雷 (分析+代码实现) ","date":"2019-11-08","objectID":"/2019-11-08-js-saolei/:2:6","tags":["JavaScript"],"title":"JS 扫雷小游戏","uri":"/2019-11-08-js-saolei/"},{"categories":["Coding"],"content":"ECMAScript 6(以下简称ES6)是 JavaScript 语言的下一代标准,已经在2015年6月正式发布了。Mozilla公司将在这个标准的基础上,推出 JavaScript 2.0。ECMAScript 和 JavaScript 是什么关系？简单来说，ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:0:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"let和const var 函数作用域function scope,不在函数内时作用域是全局的 用let和const声明变量, let, const 块级作用域block scope,作用域是{}内 eg.执行以下语句判断区别： for (var i = 0; i \u003c 10; i++) {\rconsole.log(i);\rsetTimeout(function () {\rconsole.log(`i:${i}`);\r}, 1000)\r}\rfor (let i = 0; i \u003c 10; i++) {\rconsole.log(i);\rsetTimeout(function () {\rconsole.log(`i:${i}`);\r}, 1000)\r}\r let, const不能重复声明变量值 let声明的变量是可以重新赋值的, const声明的变量只能修改引用类型的属性值 变量提升：let, count有变量提升,未声明先使用存在临时性死区(Temporal dead zone),详见mdn ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:1:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"箭头函数 特点：简明的语法,隐式返回(省去return关键字),匿名函数 this:普通函数this是动态绑定的 const Jelly = {\rname: 'Jelly',\rhobbies: ['Coding', 'Sleeping', 'Reading'],\rprintHobbies: function () {\r// console.log(this);\r this.hobbies.map(function (hobby) {\r// console.log(this);\r console.log(`${this.name}loves ${hobby}`);\r})\r}\r}\rJelly.printHobbies(); map中的回调函数是一个独立的函数,不作为对象的方法,并且没有通过call bind apply 来改变里面的this，this指向window,严格模式下指向undefined const Jelly = {\rname: 'Jelly',\rhobbies: ['Coding', 'Sleeping', 'Reading'],\rprintHobbies: function () {\r// console.log(this);\r var self = this;\rthis.hobbies.map(function (hobby) {\r// console.log(this);\r console.log(`${self.name}loves ${hobby}`);\r})\r}\r}\rJelly.printHobbies();\r 箭头函数的this值继承父作用域,是词法作用域,定义的时候就指向明确,且不会绑定this： const Jelly = {\rname: 'Jelly',\rhobbies: ['Coding', 'Sleeping', 'Reading'],\rprintHobbies: function () {\r// console.log(this);\r this.hobbies.map(hobby =\u003e {\r// console.log(this);\r console.log(`${this.name}loves ${hobby}`);\r})\r}\r}\rJelly.printHobbies();\r 命名函数在递归,事件绑定时有用,在箭头函数中使用： const greet = name =\u003e {alert(`Hello ${name}`)}; 箭头函数不适用的情况： 需要使用this慎用 需要使用arguments(箭头函数没有arguments) ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:2:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"模板字符串 模板字符串中的换行和空格都是会被保留的。 模板字符串可嵌套,支持三元表达式。 标签模板字符串,是一个函数的调用。 alert`Hello world!`;\r// 等价于alert('Hello world!');\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:3:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"解构赋值 针对数组或者对象进行模式匹配,然后对其中的变量进行赋值。 是对赋值运算符的扩展,方便提取对象属性值,可嵌套可忽略。 let [a, b, c, d, e] = 'hello';\rlet obj = {p: ['hello', {y: 'world'}] };\rlet {p: [x, { y }] } = obj;\r// x = 'hello'\r// y = 'world'\rlet obj = {p: ['hello', {y: 'world'}] };\rlet {p: [x, { }] } = obj;\r// x = 'hello'\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:4:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"计算属性 对象字面定义属性名位置的 [ ] 中可以放置任意合法表达式。 const keys = ['name', 'age', 'birthday']\rconst values = ['jelly', 18, '2016-01']\rconst Laravist = {\r[keys.shift()]: values.shift(),\r[keys.shift()]: values.shift(),\r[keys.shift()]: values.shift(),\r}\rconsole.log(Laravist);\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:5:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Symbol ES6引入了一种新的原始数据类型表示独一无二的值,最大的用法是用来定义对象的唯一属性名。 用于生成唯一标识符避免命名冲突,可作为私有属性在对象内部使用,不能for循环遍历 const classRoom = {\r[Symbol('lily')]: { grade: 60, gender: 'female' },\r[Symbol('nina')]: { grade: 70, gender: 'female' },\r[Symbol('nina')]: { grade: 90, gender: 'female' },\r}\rconst syms = Object.getOwnPropertySymbols(classRoom).map(sym =\u003e classRoom[sym]);\rconsole.log(syms);\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:6:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"剩余参数 const player = ['jelly', 123, 2.4, 3.6, 1.7]\rconst [name, id, ...scores] = player;\rconsole.log(name, id, scores);\r 扩展运算符可以将可遍历对象元素扩展成新的参数序列,而不用改变原来的对象 const younger = ['aaa', 'bbb', 'ccc'];\rconst older = ['xxx', 'yyy', 'zzz'];\rconst members = [...younger, 'ddd', ...older];\rconst newmembers = members;\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:7:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Promise Promise用于避免回调地狱 const p = new Promise((resolve, reject) =\u003e {\rsetTimeout(() =\u003e {\rreject(Error('Laravist isn\\'t awesome!'));\r}, 2000);\r})\rp.then(data =\u003e { console.log(data) })\r.catch(err =\u003e { console.error(err) });\r await操作符用于等待一个Promise对象,它只能在异步函数async function内部使用。 await针对所跟不同表达式的处理方式： Promise对象：await 会暂停执行,等待Promise对象resolve,然后恢复async函数的执行并返回解析值。 非Promise对象：直接返回对应的值。 function testAwait(x) {\rreturn new Promise(resolve =\u003e {\rsetTimeout(() =\u003e {\rresolve(x);\r}, 2000);\r});\r}\rasync function helloAsync() {\rvar x = await testAwait(\"hello world\");\rconsole.log(x);\r}\rhelloAsync();\r ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:8:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Class class是语法糖,本质是funciton,没有变量提升 一个继承的例子: function MyArray() {\rArray.apply(this, arguments);\r}\rconst colors = new MyArray();\rcolors[0] = 'red';\rconsole.log(colors.length); //undefined\rcolors.length = 0;\rconsole.log(colors[0]); //red\r ES5 是先新建子类的实例对象this, 再将父类的属性添加到子类上,原生构造函数会忽略apply方法传入的this, 父类的内部属性无法获取,导致无法继承原生的构造函数。 class MyArray extends Array {\rconstructor() {\rsuper();\rconsole.log(this);\r}\r}\rconst colors = new MyArray();\rcolors[0] = 'red';\rconsole.log(colors.length); // 1\rcolors.length = 0;\rconsole.log(colors[0]); // undefined\r ES6 允许继承原生构造函数定义的子类,因为ES6是先新建父类的实例对象this, 然后再用子类的构造函数修饰this,使得父类的素有行为都可以继承。 ES6 可以自定义原生数据结构的子类，这是 ES5 无法做到的。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:9:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"一些补充 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:0","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"新增for…of循环： 先回顾js中for循环的几种写法 const fruits = ['apple', 'banana', 'orange', 'mango'];\rfor (let i = 0; i \u003c fruits.length; i++) {\rconsole.log(fruits[i]);\r}\r 可读性不是很好 fruits.forEach(fruit =\u003e {\rconsole.log(fruit);\r})\r 不能在循环中break或continue for (let index in fruits) {\rconsole.log(fruits[index]);\r}\r 会遍历对象上所有可枚举属性 for (let fruit of fruits) {\rconsole.log(fruit);\r}\r 不会遍历数组中非数字属性,能够break或continue 应用数组解构语法 for (let [index, fruit] of fruits.entries()) {\rconsole.log(`${fruit}rank in ${index + 1}in my favorite fruits`);\r}\r for…of可以应用于可迭代对象(部署了iterator接口或提供Symbol.iterator方法的数据结构) 数组,字符串,arguments,NodeList,map.set等,但不支持对象 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:1","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Array.from()和Array.of() es6新增数组方法Array.from()和Array.of()： 注意是数组原型对象上的静态方法 Array.from()用于把可迭代对象转化成数组,Array.of()传入参数生成数组 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:2","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Proxy与Reflect Proxy与Reflect是ES6为了操作对象引入的 API 。 Proxy 可以对目标对象的读取、函数调用等操作进行拦截,然后进行操作处理。它不直接操作对象,而是像代理模式,通过对象的代理对象进行操作。 ES6中将Object的一些明显属于语言内部的方法移植到了Reflect对象上。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:3","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"迭代器与生成器 Iterator是ES6引入的一种新的遍历机制,通过一个键为Symbol.iterator的方法来实现。 Generator函数:在function后面,函数名之前有个*,函数内部有yield表达式。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:4","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"Map与Set Object的键只能是字符串或者Symbols, Map的键可以是任意值,Map中的键值是有序的(FIFO原则),Map的键值对个数可以从size属性获取。 Set对象允许你存储任何类型的唯一值,NaN与NaN是不恒等的,但是在Set中只能存一个。 ","date":"2019-10-30","objectID":"/2019-10-30-js-es6/:10:5","tags":["JavaScript"],"title":"ES6 学习笔记","uri":"/2019-10-30-js-es6/"},{"categories":["Coding"],"content":"闭包就是能够读取其他函数内部变量的函数。在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成\"定义在一个函数内部的函数”。闭包是将函数内部和函数外部连接起来的桥梁，实现了变量的私有化问题。 有如下例子，我们想要用一个counter记录add函数的执行次数。 function add() {\rvar counter = 0; //局部变量\r counter++;\rconsole.log(\"counter = \" + counter);\r}\radd(); // counter = 1\radd(); // counter = 1\r 由于counter是局部变量，每次我们执行add()函数，都是输出 counter = 1; 我们想要执行函数时改变counter的值，一种可行的办法是： var counter = 0; //全局变量，谁都可以访问，修改\rfunction add() {\rcounter++;\rconsole.log(\"counter = \" + counter);\r}\radd(); // counter = 1\radd(); // counter = 2\r 但是这样会带来问题，由于counter是全局变量，我们可能会在函数外不小心改变了counter的值， 比如在函数外写了一句counter = -100；就打乱了我们原来的计数，显然我们并不希望在函数外任意地改变counter的值。 我们可以这样写： function add() {\rvar counter = 1; //局部变量\r console.log(\"counter = \" + counter);\rplus = function() { //全局函数\r counter++; console.log(\"counter = \" + counter);\r}\r}\radd(); //counter = 1 counter初始化\rplus(); //counter = 2\r 这样我们就无法在函数外任意改变counter了，进一步的写法是： function add() {\rvar counter = 1; //局部变量\r console.log(\"counter = \" + counter);\rvar plus = function() { //局部函数\r counter++; console.log(\"counter = \" + counter);\r};\rreturn plus;\r}\rvar plus1 = add(); // counter = 1\rplus1(); // counter = 2\r plus函数名有些多余，add可以简化为立即执行函数。 var plus1 = (function add() {\rvar counter = 0; //局部变量\r return function() { //全局函数\r counter++; console.log(\"counter = \" + counter);\r};\r})();\rplus1(); // counter = 1\rplus1(); // counter = 2\r 发现add函数名也可以去掉了，简化为匿名函数，如下就是闭包的一般写法： var plus1 = (function() {\rvar counter = 0; //局部变量\r return function() { counter++; console.log(\"counter = \" + counter);\r};\r})();\rplus1(); // counter = 1\rplus1(); // counter = 2\r 闭包实现了变量私有化，局部变量的本质，全局变量的生命周期。 ","date":"2019-10-07","objectID":"/2019-10-17-js-basis/:0:0","tags":["JavaScript"],"title":"JS 闭包写法的演变过程","uri":"/2019-10-17-js-basis/"},{"categories":null,"content":"关于网站 个人博客，记录所学所思 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于我  喜欢编程，音乐和阅读。  拖延症患者。  种一颗树的最好时间是十年前，其次是现在。 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于版权 本站所有原创文章均受 创作共享 署名-非商业性 4.0 许可协议 / CC BY-NC 4.0 保护。 任何个人及媒体在转载本站原创内容 (包含文字、图像、摄影作品等) 时请遵守以下版权要求： 注明转载 注明来源为本站首页网址，或所转内容在本站的完整网址 ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"}]