<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - 浮槎的博客</title>
        <link>http://example.org/posts/</link>
        <description>所有文章 | 浮槎的博客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 13 Dec 2020 09:50:34 &#43;0800</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml" /><item>
    <title>实现 λ 演算解释器</title>
    <link>http://example.org/2020-12-13-%CE%BB-interpreter/</link>
    <pubDate>Sun, 13 Dec 2020 09:50:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://example.org/2020-12-13-%CE%BB-interpreter/</guid>
    <description><![CDATA[如果你没有听说过 λ 演算，可以阅读我的这篇文章。如果你没有编译原理相关知识，可以阅读我的这篇文章。首先介绍调度场算法，后面的实现中会用到。 调度]]></description>
</item><item>
    <title>程序解释与编译</title>
    <link>http://example.org/2020-12-10-lex-parse/</link>
    <pubDate>Thu, 10 Dec 2020 09:50:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://example.org/2020-12-10-lex-parse/</guid>
    <description><![CDATA[程序的解释和编译通常需要经过词法分析，语法分析和生成抽象语法树等阶段。 前置知识 算术表达式根据运算符所在的位置可以分为三种表示方法： 前缀表达式]]></description>
</item><item>
    <title>λ 演算: 程序从无到有</title>
    <link>http://example.org/2020-11-26-%CE%BB-calculus/</link>
    <pubDate>Thu, 26 Nov 2020 09:50:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://example.org/2020-11-26-%CE%BB-calculus/</guid>
    <description><![CDATA[由邱奇 (Alonzo Church) 创造的 λ 演算(λ-calculus) 是世界上最小的程序设计语言。虽然没有数(number)，字符串(string)，布尔型(boo]]></description>
</item><item>
    <title>图灵机的极简实现</title>
    <link>http://example.org/2020-11-17-brainfuck/</link>
    <pubDate>Tue, 17 Nov 2020 22:00:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://example.org/2020-11-17-brainfuck/</guid>
    <description><![CDATA[图灵机是英国数学家图灵于 1936 年提出的一种将人的计算行为抽象化的数学逻辑机，其更抽象的意义为一种计算模型，可以看作等价于任何有限逻辑数学过程的终]]></description>
</item><item>
    <title>自我指涉与数理逻辑</title>
    <link>http://example.org/2020-11-16-self-ref/</link>
    <pubDate>Mon, 16 Nov 2020 00:27:34 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://example.org/2020-11-16-self-ref/</guid>
    <description><![CDATA[“我是谁？”，这种对指代自身的疑问每个人都会有。在自然语言和形式语言中，如果一个句子直接或间接提及自身，就称为自指(Self-referen]]></description>
</item><item>
    <title>了解防抖与节流</title>
    <link>http://example.org/2020-11-10-js-closure/</link>
    <pubDate>Tue, 10 Nov 2020 22:30:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://example.org/2020-11-10-js-closure/</guid>
    <description><![CDATA[在前端开发的过程中，我们经常需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等，然而有些时候我们并不希望在事件持]]></description>
</item><item>
    <title>以 useEffect 为圆心</title>
    <link>http://example.org/2020-11-02-react-hooks/</link>
    <pubDate>Mon, 02 Nov 2020 20:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://example.org/2020-11-02-react-hooks/</guid>
    <description><![CDATA[以 useEffect 为圆心，其他 Hooks 为半径，构建 React Hooks 的知识圆环。为什么会想出这样一个标题呢？Hooks 的知识点过于分散，很多朋友在读过 React 官方文档后，还是不知道]]></description>
</item><item>
    <title>构建自己的 mini React</title>
    <link>http://example.org/2020-10-18-mini-react/</link>
    <pubDate>Sun, 18 Oct 2020 22:40:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://example.org/2020-10-18-mini-react/</guid>
    <description><![CDATA[现在，我们遵循 React 16.8 的代码体系结构，一步一步地构建我们自己的 mini React。 基础回顾 开始之前，我们先回顾 React 是怎么将 JSX 转换成 DOM 节点的： 1 2 3 const element =]]></description>
</item><item>
    <title>实现仿 Recoil 的状态共享</title>
    <link>http://example.org/2020-10-07-recoil-clone/</link>
    <pubDate>Wed, 07 Oct 2020 19:40:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://example.org/2020-10-07-recoil-clone/</guid>
    <description><![CDATA[本文是我最近阅读一篇英文技术文章后写的小结。阅读前请注意，本文不涉及任何 Recoil 源码。仿写的代码并不是 Recoil 真正的实现方式，本文只仿造实现了 Recoil 中两个重]]></description>
</item><item>
    <title>Next.js 概览</title>
    <link>http://example.org/2020-09-29-next/</link>
    <pubDate>Tue, 29 Sep 2020 23:30:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://example.org/2020-09-29-next/</guid>
    <description><![CDATA[我们知道，如今流行的前端框架都是 SPA(单页应用)，在投入生产时会出现中首屏加载慢，不利于 SEO 等问题。于是，现代前端同构框架应运而生。Next]]></description>
</item></channel>
</rss>
