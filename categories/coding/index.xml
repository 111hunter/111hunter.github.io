<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Coding - 分类 - 寂的博客</title>
        <link>http://localhost:1313/categories/coding/</link>
        <description>Coding - 分类 - 寂的博客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>1621209357@qq.com (寂)</managingEditor>
            <webMaster>1621209357@qq.com (寂)</webMaster><lastBuildDate>Tue, 25 May 2021 19:50:34 &#43;0800</lastBuildDate><atom:link href="http://localhost:1313/categories/coding/" rel="self" type="application/rss+xml" /><item>
    <title>单机版区块链</title>
    <link>http://localhost:1313/2021-05-25-blockchain/</link>
    <pubDate>Tue, 25 May 2021 19:50:34 &#43;0800</pubDate>
    <author>寂</author>
    <guid>http://localhost:1313/2021-05-25-blockchain/</guid>
    <description><![CDATA[<p>区块链是一个分布式数据库，任何人都可以读取的它的区块数据。区块链是不可变的，意味着一旦将区块添加到链中，就只能在使链的其余部分无效的情况下才能对其进行更改，这就是加密货币基于区块链来实现的原因。</p>]]></description>
</item>
<item>
    <title>Docker 极速入门</title>
    <link>http://localhost:1313/2021-05-02-docker/</link>
    <pubDate>Sun, 02 May 2021 11:50:34 &#43;0800</pubDate>
    <author>寂</author>
    <guid>http://localhost:1313/2021-05-02-docker/</guid>
    <description><![CDATA[<p>Docker 包括三个基本概念: Image(镜像)、Container(容器)、Repository(仓库)，理解了这三个概念，就理解了 Docker 的整个生命周期。</p>]]></description>
</item>
<item>
    <title>实现 λ 演算解释器</title>
    <link>http://localhost:1313/2020-12-13-%CE%BB-interpreter/</link>
    <pubDate>Sun, 13 Dec 2020 09:50:34 &#43;0800</pubDate>
    <author>寂</author>
    <guid>http://localhost:1313/2020-12-13-%CE%BB-interpreter/</guid>
    <description><![CDATA[<p>如果你没有听说过 λ 演算，可以阅读我的这篇<a href="https://111hunter.github.io/2020-11-26-%CE%BB-calculus/" target="_blank" rel="noopener noreffer">文章</a>
。如果你没有编译原理相关知识，可以阅读我的这篇<a href="https://111hunter.github.io/2020-12-10-lex-parse" target="_blank" rel="noopener noreffer">文章</a>
。首先介绍调度场算法，后面的实现中会用到。</p>]]></description>
</item>
<item>
    <title>了解防抖与节流</title>
    <link>http://localhost:1313/2020-11-10-debounce/</link>
    <pubDate>Tue, 10 Nov 2020 22:30:00 &#43;0800</pubDate>
    <author>寂</author>
    <guid>http://localhost:1313/2020-11-10-debounce/</guid>
    <description><![CDATA[<p>在前端开发的过程中，我们经常需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等，然而有些时候我们并不希望在事件持续触发的过程中频繁地去执行函数，这时候就会用到函数防抖(Debounce)与节流(Throttle)：</p>]]></description>
</item>
<item>
    <title>以 useEffect 为圆心</title>
    <link>http://localhost:1313/2020-11-02-react-hooks/</link>
    <pubDate>Mon, 02 Nov 2020 20:00:00 &#43;0800</pubDate>
    <author>寂</author>
    <guid>http://localhost:1313/2020-11-02-react-hooks/</guid>
    <description><![CDATA[<p>以 useEffect 为圆心，其他 Hooks 为半径，构建 React Hooks 的知识圆环。为什么会想出这样一个标题呢？Hooks 的知识点过于分散，很多朋友在读过 React 官方文档后，还是不知道 Hooks 如何在实际项目中使用。本文希望从 useEffect 的具体用法中引出其他 Hooks，从而构建出完整的 React Hooks 知识体系。</p>]]></description>
</item>
<item>
    <title>构建自己的 mini React</title>
    <link>http://localhost:1313/2020-10-18-mini-react/</link>
    <pubDate>Sun, 18 Oct 2020 22:40:00 &#43;0800</pubDate>
    <author>寂</author>
    <guid>http://localhost:1313/2020-10-18-mini-react/</guid>
    <description><![CDATA[<p>现在，我们遵循 React 16.8 的代码体系结构，一步一步地构建我们自己的 mini React。</p>
<h2 id="基础回顾">基础回顾</h2>
<p>开始之前，我们先回顾 React 是怎么将 JSX 转换成 DOM 节点的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">&lt;</span><span class="nt">h1</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;foo&#34;</span><span class="p">&gt;</span><span class="nx">Hello</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">container</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&#34;root&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">container</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第一行使用 JSX 来创建元素，但 JSX 不是有效的 JS 代码。React 用 Babel 将 JSX 代码转换为原生 JS 代码。转换过程就是调用 createElement 函数，并将 JSX 的元素类型、props 属性和 childen 元素作为参数依次传入：</p>]]></description>
</item>
<item>
    <title>实现仿 Recoil 的状态共享</title>
    <link>http://localhost:1313/2020-10-07-recoil-clone/</link>
    <pubDate>Wed, 07 Oct 2020 19:40:00 &#43;0800</pubDate>
    <author>寂</author>
    <guid>http://localhost:1313/2020-10-07-recoil-clone/</guid>
    <description><![CDATA[<p>本文是我最近阅读一篇英文技术文章后写的小结。阅读前请注意，本文不涉及任何 Recoil 源码。仿写的代码并不是 Recoil 真正的实现方式，本文只仿造实现了 Recoil 中两个重要的 API 接口：Atom 和 Selector。</p>]]></description>
</item>
<item>
    <title>Next.js 概览</title>
    <link>http://localhost:1313/2020-09-29-next/</link>
    <pubDate>Tue, 29 Sep 2020 23:30:00 &#43;0800</pubDate>
    <author>寂</author>
    <guid>http://localhost:1313/2020-09-29-next/</guid>
    <description><![CDATA[<p><figure><a class="lightgallery" href="/img/nextjs-slug.webp" title="https://www.reddit.com/r/nextjs/comments/17iy9sx/nextjs_server_action_is_crazy" data-thumbnail="/img/nextjs-slug.webp" data-sub-html="<h2>Next.js Reddit Meme</h2><p>https://www.reddit.com/r/nextjs/comments/17iy9sx/nextjs_server_action_is_crazy</p>">
        
    </a><figcaption class="image-caption">Next.js Reddit Meme</figcaption>
    </figure></p>
<p>我们知道，如今流行的前端框架都是 SPA(单页应用)，在投入生产时会出现中首屏加载慢，不利于 SEO 等问题。于是，现代前端同构框架应运而生。Next.js 是 React 的同构框架，它的页面由 React 组件构成。</p>]]></description>
</item>
<item>
    <title>浅析函数式编程</title>
    <link>http://localhost:1313/2020-09-02-js-functional/</link>
    <pubDate>Wed, 02 Sep 2020 08:30:00 &#43;0800</pubDate>
    <author>寂</author>
    <guid>http://localhost:1313/2020-09-02-js-functional/</guid>
    <description><![CDATA[<blockquote>
<p>在计算机科学中，<a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener noreffer">函数式编程</a>
是一种编程范式，其中通过应用和组合函数来构造程序。它是一种声明式编程范式，其中函数定义是每个返回一个值的表达式树，而不是一系列更改程序状态的命令性语句。 &ndash; wikipedia</p>]]></description>
</item>
<item>
    <title>入门 AST 抽象语法树</title>
    <link>http://localhost:1313/2020-08-23-ast/</link>
    <pubDate>Sun, 23 Aug 2020 00:30:00 &#43;0800</pubDate>
    <author>寂</author>
    <guid>http://localhost:1313/2020-08-23-ast/</guid>
    <description><![CDATA[<p>如果你想了解 Javascript 的编译原理，那么你就得了解 AST(Abstract Syntax Tree)，目前前端常用的一些插件或者工具，比如 JS 转译、代码压缩、CSS 预处理器、ESLint、Prettier 等功能的实现，都是建立在 AST 的基础之上的。</p>]]></description>
</item>
</channel>
</rss>
